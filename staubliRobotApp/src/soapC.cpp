/* soapC.cpp
   Generated by gSOAP 2.8.52 for CS8Server.h

gSOAP XML Web services tools
Copyright (C) 2000-2017, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "../soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.52 2017-08-29 09:04:14 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, ""))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", "");
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_ns1__SessionId:
		return soap_in_ns1__SessionId(soap, NULL, NULL, "ns1:SessionId");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_unsignedByte:
		return soap_in_unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ns7__replaceLineReturnCode:
		return soap_in_ns7__replaceLineReturnCode(soap, NULL, NULL, "ns7:replaceLineReturnCode");
	case SOAP_TYPE_ns7__execVal3ReturnCode:
		return soap_in_ns7__execVal3ReturnCode(soap, NULL, NULL, "ns7:execVal3ReturnCode");
	case SOAP_TYPE_ns7__SoapPhysicalIoEnumState:
		return soap_in_ns7__SoapPhysicalIoEnumState(soap, NULL, NULL, "ns7:SoapPhysicalIoEnumState");
	case SOAP_TYPE_ns7__SoapTaskStep:
		return soap_in_ns7__SoapTaskStep(soap, NULL, NULL, "ns7:SoapTaskStep");
	case SOAP_TYPE_ns7__SoapTaskState:
		return soap_in_ns7__SoapTaskState(soap, NULL, NULL, "ns7:SoapTaskState");
	case SOAP_TYPE_ns1__DiameterAxis3:
		return soap_in_ns1__DiameterAxis3(soap, NULL, NULL, "ns1:DiameterAxis3");
	case SOAP_TYPE_ns1__LengthAxis3:
		return soap_in_ns1__LengthAxis3(soap, NULL, NULL, "ns1:LengthAxis3");
	case SOAP_TYPE_ns1__MountType:
		return soap_in_ns1__MountType(soap, NULL, NULL, "ns1:MountType");
	case SOAP_TYPE_ns1__Kinematic:
		return soap_in_ns1__Kinematic(soap, NULL, NULL, "ns1:Kinematic");
	case SOAP_TYPE_ns1__ServerExceptionCode:
		return soap_in_ns1__ServerExceptionCode(soap, NULL, NULL, "ns1:ServerExceptionCode");
	case SOAP_TYPE_ns4__hexBinary:
		return soap_in_ns4__hexBinary(soap, NULL, NULL, "ns4:hexBinary");
	case SOAP_TYPE_ns4__base64Binary:
		return soap_in_ns4__base64Binary(soap, NULL, NULL, "ns4:base64Binary");
	case SOAP_TYPE_ns2__JointRange:
		return soap_in_ns2__JointRange(soap, NULL, NULL, "ns2:JointRange");
	case SOAP_TYPE_ns2__Records:
		return soap_in_ns2__Records(soap, NULL, NULL, "ns2:Records");
	case SOAP_TYPE_ns2__Data:
		return soap_in_ns2__Data(soap, NULL, NULL, "ns2:Data");
	case SOAP_TYPE_ns2__VALApplications:
		return soap_in_ns2__VALApplications(soap, NULL, NULL, "ns2:VALApplications");
	case SOAP_TYPE_ns2__VALApplication:
		return soap_in_ns2__VALApplication(soap, NULL, NULL, "ns2:VALApplication");
	case SOAP_TYPE_ns3__Include:
		return soap_in_ns3__Include(soap, NULL, NULL, "ns3:Include");
	case SOAP_TYPE_ns7__SoapDhParametersArray:
		return soap_in_ns7__SoapDhParametersArray(soap, NULL, NULL, "ns7:SoapDhParametersArray");
	case SOAP_TYPE_ns7__SoapDhParameters:
		return soap_in_ns7__SoapDhParameters(soap, NULL, NULL, "ns7:SoapDhParameters");
	case SOAP_TYPE_ns7__SoapPhysicalIoUnlockResponses:
		return soap_in_ns7__SoapPhysicalIoUnlockResponses(soap, NULL, NULL, "ns7:SoapPhysicalIoUnlockResponses");
	case SOAP_TYPE_ns7__SoapPhysicalIoUnlockResponse:
		return soap_in_ns7__SoapPhysicalIoUnlockResponse(soap, NULL, NULL, "ns7:SoapPhysicalIoUnlockResponse");
	case SOAP_TYPE_ns7__SoapPhysicalIoResponses:
		return soap_in_ns7__SoapPhysicalIoResponses(soap, NULL, NULL, "ns7:SoapPhysicalIoResponses");
	case SOAP_TYPE_ns7__SoapPhysicalIoResponse:
		return soap_in_ns7__SoapPhysicalIoResponse(soap, NULL, NULL, "ns7:SoapPhysicalIoResponse");
	case SOAP_TYPE_ns7__SoapPhysicalIosStates:
		return soap_in_ns7__SoapPhysicalIosStates(soap, NULL, NULL, "ns7:SoapPhysicalIosStates");
	case SOAP_TYPE_ns7__SoapPhysicalIoValues:
		return soap_in_ns7__SoapPhysicalIoValues(soap, NULL, NULL, "ns7:SoapPhysicalIoValues");
	case SOAP_TYPE_ns7__SoapPhysicalIoState:
		return soap_in_ns7__SoapPhysicalIoState(soap, NULL, NULL, "ns7:SoapPhysicalIoState");
	case SOAP_TYPE_ns7__SoapPhysicalIoAttrib:
		return soap_in_ns7__SoapPhysicalIoAttrib(soap, NULL, NULL, "ns7:SoapPhysicalIoAttrib");
	case SOAP_TYPE_ns7__SoapPhysicalAioAttrib:
		return soap_in_ns7__SoapPhysicalAioAttrib(soap, NULL, NULL, "ns7:SoapPhysicalAioAttrib");
	case SOAP_TYPE_ns7__SoapPhysicalDioAttrib:
		return soap_in_ns7__SoapPhysicalDioAttrib(soap, NULL, NULL, "ns7:SoapPhysicalDioAttrib");
	case SOAP_TYPE_ns7__SoapPhysicalIoLinks:
		return soap_in_ns7__SoapPhysicalIoLinks(soap, NULL, NULL, "ns7:SoapPhysicalIoLinks");
	case SOAP_TYPE_ns7__SoapWatches:
		return soap_in_ns7__SoapWatches(soap, NULL, NULL, "ns7:SoapWatches");
	case SOAP_TYPE_ns7__SoapData:
		return soap_in_ns7__SoapData(soap, NULL, NULL, "ns7:SoapData");
	case SOAP_TYPE_ns7__SoapCallStack:
		return soap_in_ns7__SoapCallStack(soap, NULL, NULL, "ns7:SoapCallStack");
	case SOAP_TYPE_ns7__SoapStackFrameAbstract:
		return soap_in_ns7__SoapStackFrameAbstract(soap, NULL, NULL, "ns7:SoapStackFrameAbstract");
	case SOAP_TYPE_ns7__SoapInstruction:
		return soap_in_ns7__SoapInstruction(soap, NULL, NULL, "ns7:SoapInstruction");
	case SOAP_TYPE_ns7__SoapTasks:
		return soap_in_ns7__SoapTasks(soap, NULL, NULL, "ns7:SoapTasks");
	case SOAP_TYPE_ns7__SoapTask:
		return soap_in_ns7__SoapTask(soap, NULL, NULL, "ns7:SoapTask");
	case SOAP_TYPE_ns7__MimeData:
		return soap_in_ns7__MimeData(soap, NULL, NULL, "ns7:MimeData");
	case SOAP_TYPE_ns7__BreakpointsResponses:
		return soap_in_ns7__BreakpointsResponses(soap, NULL, NULL, "ns7:BreakpointsResponses");
	case SOAP_TYPE_ns7__BreakpointsResponse:
		return soap_in_ns7__BreakpointsResponse(soap, NULL, NULL, "ns7:BreakpointsResponse");
	case SOAP_TYPE_ns7__SoapBreakpoints:
		return soap_in_ns7__SoapBreakpoints(soap, NULL, NULL, "ns7:SoapBreakpoints");
	case SOAP_TYPE_ns7__SoapBreakpoint:
		return soap_in_ns7__SoapBreakpoint(soap, NULL, NULL, "ns7:SoapBreakpoint");
	case SOAP_TYPE_ns7__SoapProgramLine:
		return soap_in_ns7__SoapProgramLine(soap, NULL, NULL, "ns7:SoapProgramLine");
	case SOAP_TYPE_ns7__Records:
		return soap_in_ns7__Records(soap, NULL, NULL, "ns7:Records");
	case SOAP_TYPE_ns7__VALApplications:
		return soap_in_ns7__VALApplications(soap, NULL, NULL, "ns7:VALApplications");
	case SOAP_TYPE_ns7__Robots:
		return soap_in_ns7__Robots(soap, NULL, NULL, "ns7:Robots");
	case SOAP_TYPE_ns7__Versions:
		return soap_in_ns7__Versions(soap, NULL, NULL, "ns7:Versions");
	case SOAP_TYPE_ns7__Parameters:
		return soap_in_ns7__Parameters(soap, NULL, NULL, "ns7:Parameters");
	case SOAP_TYPE_ns7__JointPos:
		return soap_in_ns7__JointPos(soap, NULL, NULL, "ns7:JointPos");
	case SOAP_TYPE_ns5__SoapDhParametersArray:
		return soap_in_ns5__SoapDhParametersArray(soap, NULL, NULL, "ns5:SoapDhParametersArray");
	case SOAP_TYPE_ns5__SoapPhysicalIoUnlockResponses:
		return soap_in_ns5__SoapPhysicalIoUnlockResponses(soap, NULL, NULL, "ns5:SoapPhysicalIoUnlockResponses");
	case SOAP_TYPE_ns5__SoapPhysicalIoResponses:
		return soap_in_ns5__SoapPhysicalIoResponses(soap, NULL, NULL, "ns5:SoapPhysicalIoResponses");
	case SOAP_TYPE_ns5__SoapPhysicalIosStates:
		return soap_in_ns5__SoapPhysicalIosStates(soap, NULL, NULL, "ns5:SoapPhysicalIosStates");
	case SOAP_TYPE_ns5__SoapPhysicalIoValues:
		return soap_in_ns5__SoapPhysicalIoValues(soap, NULL, NULL, "ns5:SoapPhysicalIoValues");
	case SOAP_TYPE_ns5__SoapPhysicalIoLinks:
		return soap_in_ns5__SoapPhysicalIoLinks(soap, NULL, NULL, "ns5:SoapPhysicalIoLinks");
	case SOAP_TYPE_ns5__SoapWatches:
		return soap_in_ns5__SoapWatches(soap, NULL, NULL, "ns5:SoapWatches");
	case SOAP_TYPE_ns5__SoapCallStack:
		return soap_in_ns5__SoapCallStack(soap, NULL, NULL, "ns5:SoapCallStack");
	case SOAP_TYPE_ns5__SoapTasks:
		return soap_in_ns5__SoapTasks(soap, NULL, NULL, "ns5:SoapTasks");
	case SOAP_TYPE_ns5__BreakpointsResponses:
		return soap_in_ns5__BreakpointsResponses(soap, NULL, NULL, "ns5:BreakpointsResponses");
	case SOAP_TYPE_ns5__SoapBreakpoints:
		return soap_in_ns5__SoapBreakpoints(soap, NULL, NULL, "ns5:SoapBreakpoints");
	case SOAP_TYPE_ns5__Records:
		return soap_in_ns5__Records(soap, NULL, NULL, "ns5:Records");
	case SOAP_TYPE_ns5__VALApplications:
		return soap_in_ns5__VALApplications(soap, NULL, NULL, "ns5:VALApplications");
	case SOAP_TYPE_ns5__Robots:
		return soap_in_ns5__Robots(soap, NULL, NULL, "ns5:Robots");
	case SOAP_TYPE_ns5__Versions:
		return soap_in_ns5__Versions(soap, NULL, NULL, "ns5:Versions");
	case SOAP_TYPE_ns5__Parameters:
		return soap_in_ns5__Parameters(soap, NULL, NULL, "ns5:Parameters");
	case SOAP_TYPE_ns5__JointPos:
		return soap_in_ns5__JointPos(soap, NULL, NULL, "ns5:JointPos");
	case SOAP_TYPE_ns1__Robots:
		return soap_in_ns1__Robots(soap, NULL, NULL, "ns1:Robots");
	case SOAP_TYPE_ns1__SoapServerVersion:
		return soap_in_ns1__SoapServerVersion(soap, NULL, NULL, "ns1:SoapServerVersion");
	case SOAP_TYPE_ns1__Versions:
		return soap_in_ns1__Versions(soap, NULL, NULL, "ns1:Versions");
	case SOAP_TYPE_ns1__Parameters:
		return soap_in_ns1__Parameters(soap, NULL, NULL, "ns1:Parameters");
	case SOAP_TYPE_ns1__Parameter:
		return soap_in_ns1__Parameter(soap, NULL, NULL, "ns1:Parameter");
	case SOAP_TYPE_ns1__Version:
		return soap_in_ns1__Version(soap, NULL, NULL, "ns1:Version");
	case SOAP_TYPE_ns1__Robot:
		return soap_in_ns1__Robot(soap, NULL, NULL, "ns1:Robot");
	case SOAP_TYPE_ns1__CartesianPos:
		return soap_in_ns1__CartesianPos(soap, NULL, NULL, "ns1:CartesianPos");
	case SOAP_TYPE_ns1__JointPos:
		return soap_in_ns1__JointPos(soap, NULL, NULL, "ns1:JointPos");
	case SOAP_TYPE_ns1__ServerException:
		return soap_in_ns1__ServerException(soap, NULL, NULL, "ns1:ServerException");
	case SOAP_TYPE_xsd__hexBinary:
		return soap_in_xsd__hexBinary(soap, NULL, NULL, "xsd:hexBinary");
	case SOAP_TYPE_xsd__base64Binary:
		return soap_in_xsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_xsd__anyURI:
		return soap_in_xsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTo_ns7__getProjectResponse:
		return soap_in_PointerTo_ns7__getProjectResponse(soap, NULL, NULL, "ns7:getProjectResponse");
	case SOAP_TYPE_PointerTo_ns7__getProject:
		return soap_in_PointerTo_ns7__getProject(soap, NULL, NULL, "ns7:getProject");
	case SOAP_TYPE_PointerTo_ns7__SoapRobotDhParameters:
		return soap_in_PointerTo_ns7__SoapRobotDhParameters(soap, NULL, NULL, "ns7:SoapRobotDhParameters");
	case SOAP_TYPE_PointerTo_ns7__getRobotDhParameters:
		return soap_in_PointerTo_ns7__getRobotDhParameters(soap, NULL, NULL, "ns7:getRobotDhParameters");
	case SOAP_TYPE_PointerTo_ns7__getAllPhysicalIosResponse:
		return soap_in_PointerTo_ns7__getAllPhysicalIosResponse(soap, NULL, NULL, "ns7:getAllPhysicalIosResponse");
	case SOAP_TYPE_PointerTo_ns7__getAllPhysicalIos:
		return soap_in_PointerTo_ns7__getAllPhysicalIos(soap, NULL, NULL, "ns7:getAllPhysicalIos");
	case SOAP_TYPE_PointerTo_ns7__unlockAllIos:
		return soap_in_PointerTo_ns7__unlockAllIos(soap, NULL, NULL, "ns7:unlockAllIos");
	case SOAP_TYPE_PointerTo_ns7__SoapAllPhysicalIoResponse:
		return soap_in_PointerTo_ns7__SoapAllPhysicalIoResponse(soap, NULL, NULL, "ns7:SoapAllPhysicalIoResponse");
	case SOAP_TYPE_PointerTo_ns7__lockAllIos:
		return soap_in_PointerTo_ns7__lockAllIos(soap, NULL, NULL, "ns7:lockAllIos");
	case SOAP_TYPE_PointerTo_ns7__unlockIosResponse:
		return soap_in_PointerTo_ns7__unlockIosResponse(soap, NULL, NULL, "ns7:unlockIosResponse");
	case SOAP_TYPE_PointerTo_ns7__unlockIos:
		return soap_in_PointerTo_ns7__unlockIos(soap, NULL, NULL, "ns7:unlockIos");
	case SOAP_TYPE_PointerTo_ns7__lockIosResponse:
		return soap_in_PointerTo_ns7__lockIosResponse(soap, NULL, NULL, "ns7:lockIosResponse");
	case SOAP_TYPE_PointerTo_ns7__lockIos:
		return soap_in_PointerTo_ns7__lockIos(soap, NULL, NULL, "ns7:lockIos");
	case SOAP_TYPE_PointerTo_ns7__writeIosResponse:
		return soap_in_PointerTo_ns7__writeIosResponse(soap, NULL, NULL, "ns7:writeIosResponse");
	case SOAP_TYPE_PointerTo_ns7__writeIos:
		return soap_in_PointerTo_ns7__writeIos(soap, NULL, NULL, "ns7:writeIos");
	case SOAP_TYPE_PointerTo_ns7__readIosResponse:
		return soap_in_PointerTo_ns7__readIosResponse(soap, NULL, NULL, "ns7:readIosResponse");
	case SOAP_TYPE_PointerTo_ns7__readIos:
		return soap_in_PointerTo_ns7__readIos(soap, NULL, NULL, "ns7:readIos");
	case SOAP_TYPE_PointerTo_ns7__replaceLineResponse:
		return soap_in_PointerTo_ns7__replaceLineResponse(soap, NULL, NULL, "ns7:replaceLineResponse");
	case SOAP_TYPE_PointerTo_ns7__replaceLine:
		return soap_in_PointerTo_ns7__replaceLine(soap, NULL, NULL, "ns7:replaceLine");
	case SOAP_TYPE_PointerTo_ns7__setCurrentInstructionResponse:
		return soap_in_PointerTo_ns7__setCurrentInstructionResponse(soap, NULL, NULL, "ns7:setCurrentInstructionResponse");
	case SOAP_TYPE_PointerTo_ns7__setCurrentInstruction:
		return soap_in_PointerTo_ns7__setCurrentInstruction(soap, NULL, NULL, "ns7:setCurrentInstruction");
	case SOAP_TYPE_PointerTo_ns7__setProjectAsModifiedResponse:
		return soap_in_PointerTo_ns7__setProjectAsModifiedResponse(soap, NULL, NULL, "ns7:setProjectAsModifiedResponse");
	case SOAP_TYPE_PointerTo_ns7__setProjectAsModified:
		return soap_in_PointerTo_ns7__setProjectAsModified(soap, NULL, NULL, "ns7:setProjectAsModified");
	case SOAP_TYPE_PointerTo_ns7__execVal3Response:
		return soap_in_PointerTo_ns7__execVal3Response(soap, NULL, NULL, "ns7:execVal3Response");
	case SOAP_TYPE_PointerTo_ns7__execVal3:
		return soap_in_PointerTo_ns7__execVal3(soap, NULL, NULL, "ns7:execVal3");
	case SOAP_TYPE_PointerTo_ns7__getWatchResponse:
		return soap_in_PointerTo_ns7__getWatchResponse(soap, NULL, NULL, "ns7:getWatchResponse");
	case SOAP_TYPE_PointerTo_ns7__getWatches:
		return soap_in_PointerTo_ns7__getWatches(soap, NULL, NULL, "ns7:getWatches");
	case SOAP_TYPE_PointerTo_ns7__getStackFrameResponse:
		return soap_in_PointerTo_ns7__getStackFrameResponse(soap, NULL, NULL, "ns7:getStackFrameResponse");
	case SOAP_TYPE_PointerTo_ns7__getStackFrame:
		return soap_in_PointerTo_ns7__getStackFrame(soap, NULL, NULL, "ns7:getStackFrame");
	case SOAP_TYPE_PointerTo_ns7__getCallStackResponse:
		return soap_in_PointerTo_ns7__getCallStackResponse(soap, NULL, NULL, "ns7:getCallStackResponse");
	case SOAP_TYPE_PointerTo_ns7__getCallStack:
		return soap_in_PointerTo_ns7__getCallStack(soap, NULL, NULL, "ns7:getCallStack");
	case SOAP_TYPE_PointerTo_ns7__unsubscribeResponse:
		return soap_in_PointerTo_ns7__unsubscribeResponse(soap, NULL, NULL, "ns7:unsubscribeResponse");
	case SOAP_TYPE_PointerTo_ns7__unsubscribeToControllerEvents:
		return soap_in_PointerTo_ns7__unsubscribeToControllerEvents(soap, NULL, NULL, "ns7:unsubscribeToControllerEvents");
	case SOAP_TYPE_PointerTo_ns7__subscribeResponse:
		return soap_in_PointerTo_ns7__subscribeResponse(soap, NULL, NULL, "ns7:subscribeResponse");
	case SOAP_TYPE_PointerTo_ns7__subscribeToControllerEvents:
		return soap_in_PointerTo_ns7__subscribeToControllerEvents(soap, NULL, NULL, "ns7:subscribeToControllerEvents");
	case SOAP_TYPE_PointerTo_ns7__taskStepResponse:
		return soap_in_PointerTo_ns7__taskStepResponse(soap, NULL, NULL, "ns7:taskStepResponse");
	case SOAP_TYPE_PointerTo_ns7__taskStep:
		return soap_in_PointerTo_ns7__taskStep(soap, NULL, NULL, "ns7:taskStep");
	case SOAP_TYPE_PointerTo_ns7__taskKillResponse:
		return soap_in_PointerTo_ns7__taskKillResponse(soap, NULL, NULL, "ns7:taskKillResponse");
	case SOAP_TYPE_PointerTo_ns7__taskKill:
		return soap_in_PointerTo_ns7__taskKill(soap, NULL, NULL, "ns7:taskKill");
	case SOAP_TYPE_PointerTo_ns7__taskResumeResponse:
		return soap_in_PointerTo_ns7__taskResumeResponse(soap, NULL, NULL, "ns7:taskResumeResponse");
	case SOAP_TYPE_PointerTo_ns7__taskResume:
		return soap_in_PointerTo_ns7__taskResume(soap, NULL, NULL, "ns7:taskResume");
	case SOAP_TYPE_PointerTo_ns7__taskSuspendResponse:
		return soap_in_PointerTo_ns7__taskSuspendResponse(soap, NULL, NULL, "ns7:taskSuspendResponse");
	case SOAP_TYPE_PointerTo_ns7__taskSuspend:
		return soap_in_PointerTo_ns7__taskSuspend(soap, NULL, NULL, "ns7:taskSuspend");
	case SOAP_TYPE_PointerTo_ns7__getTasksResponse:
		return soap_in_PointerTo_ns7__getTasksResponse(soap, NULL, NULL, "ns7:getTasksResponse");
	case SOAP_TYPE_PointerTo_ns7__getTasks:
		return soap_in_PointerTo_ns7__getTasks(soap, NULL, NULL, "ns7:getTasks");
	case SOAP_TYPE_PointerTo_ns7__clearAllBreakpointsResponse:
		return soap_in_PointerTo_ns7__clearAllBreakpointsResponse(soap, NULL, NULL, "ns7:clearAllBreakpointsResponse");
	case SOAP_TYPE_PointerTo_ns7__clearAllBreakpoints:
		return soap_in_PointerTo_ns7__clearAllBreakpoints(soap, NULL, NULL, "ns7:clearAllBreakpoints");
	case SOAP_TYPE_PointerTo_ns7__clearBreakpointsResponse:
		return soap_in_PointerTo_ns7__clearBreakpointsResponse(soap, NULL, NULL, "ns7:clearBreakpointsResponse");
	case SOAP_TYPE_PointerTo_ns7__clearBreakpoints:
		return soap_in_PointerTo_ns7__clearBreakpoints(soap, NULL, NULL, "ns7:clearBreakpoints");
	case SOAP_TYPE_PointerTo_ns7__getBreakpointsResponse:
		return soap_in_PointerTo_ns7__getBreakpointsResponse(soap, NULL, NULL, "ns7:getBreakpointsResponse");
	case SOAP_TYPE_PointerTo_ns7__getBreakpoints:
		return soap_in_PointerTo_ns7__getBreakpoints(soap, NULL, NULL, "ns7:getBreakpoints");
	case SOAP_TYPE_PointerTo_ns7__setBreakpointsResponse:
		return soap_in_PointerTo_ns7__setBreakpointsResponse(soap, NULL, NULL, "ns7:setBreakpointsResponse");
	case SOAP_TYPE_PointerTo_ns7__setBreakpoints:
		return soap_in_PointerTo_ns7__setBreakpoints(soap, NULL, NULL, "ns7:setBreakpoints");
	case SOAP_TYPE_PointerTo_ns1__setRobotPosResponse:
		return soap_in_PointerTo_ns1__setRobotPosResponse(soap, NULL, NULL, "ns1:setRobotPosResponse");
	case SOAP_TYPE_PointerTo_ns1__setRobotJointPos:
		return soap_in_PointerTo_ns1__setRobotJointPos(soap, NULL, NULL, "ns1:setRobotJointPos");
	case SOAP_TYPE_PointerTo_ns1__getRobotJntCartPosResponse:
		return soap_in_PointerTo_ns1__getRobotJntCartPosResponse(soap, NULL, NULL, "ns1:getRobotJntCartPosResponse");
	case SOAP_TYPE_PointerTo_ns1__getRobotJntCartPos:
		return soap_in_PointerTo_ns1__getRobotJntCartPos(soap, NULL, NULL, "ns1:getRobotJntCartPos");
	case SOAP_TYPE_PointerTo_ns1__getRobotJointPosResponse:
		return soap_in_PointerTo_ns1__getRobotJointPosResponse(soap, NULL, NULL, "ns1:getRobotJointPosResponse");
	case SOAP_TYPE_PointerTo_ns1__getRobotJointPos:
		return soap_in_PointerTo_ns1__getRobotJointPos(soap, NULL, NULL, "ns1:getRobotJointPos");
	case SOAP_TYPE_PointerTo_ns1__getRobotsResponse:
		return soap_in_PointerTo_ns1__getRobotsResponse(soap, NULL, NULL, "ns1:getRobotsResponse");
	case SOAP_TYPE_PointerTo_ns1__getRobots:
		return soap_in_PointerTo_ns1__getRobots(soap, NULL, NULL, "ns1:getRobots");
	case SOAP_TYPE_PointerTo_ns1__logoutResponse:
		return soap_in_PointerTo_ns1__logoutResponse(soap, NULL, NULL, "ns1:logoutResponse");
	case SOAP_TYPE_PointerTo_ns1__logout:
		return soap_in_PointerTo_ns1__logout(soap, NULL, NULL, "ns1:logout");
	case SOAP_TYPE_PointerTo_ns1__loginResponse:
		return soap_in_PointerTo_ns1__loginResponse(soap, NULL, NULL, "ns1:loginResponse");
	case SOAP_TYPE_PointerTo_ns1__login:
		return soap_in_PointerTo_ns1__login(soap, NULL, NULL, "ns1:login");
	case SOAP_TYPE_PointerTo_ns1__getCS8CompatibilityResponse:
		return soap_in_PointerTo_ns1__getCS8CompatibilityResponse(soap, NULL, NULL, "ns1:getCS8CompatibilityResponse");
	case SOAP_TYPE_PointerTo_ns1__getCS8Compatibility:
		return soap_in_PointerTo_ns1__getCS8Compatibility(soap, NULL, NULL, "ns1:getCS8Compatibility");
	case SOAP_TYPE_PointerTo_ns1__getControllerParametersResponse:
		return soap_in_PointerTo_ns1__getControllerParametersResponse(soap, NULL, NULL, "ns1:getControllerParametersResponse");
	case SOAP_TYPE_PointerTo_ns1__getControllerParameters:
		return soap_in_PointerTo_ns1__getControllerParameters(soap, NULL, NULL, "ns1:getControllerParameters");
	case SOAP_TYPE_PointerTo_ns1__getCS8VersionsResponse:
		return soap_in_PointerTo_ns1__getCS8VersionsResponse(soap, NULL, NULL, "ns1:getCS8VersionsResponse");
	case SOAP_TYPE_PointerTo_ns1__getCS8Versions:
		return soap_in_PointerTo_ns1__getCS8Versions(soap, NULL, NULL, "ns1:getCS8Versions");
	case SOAP_TYPE_PointerTo_ns1__pingResponse:
		return soap_in_PointerTo_ns1__pingResponse(soap, NULL, NULL, "ns1:pingResponse");
	case SOAP_TYPE_PointerTo_ns1__ping:
		return soap_in_PointerTo_ns1__ping(soap, NULL, NULL, "ns1:ping");
	case SOAP_TYPE_PointerTo_ns1__findServerResponse:
		return soap_in_PointerTo_ns1__findServerResponse(soap, NULL, NULL, "ns1:findServerResponse");
	case SOAP_TYPE_PointerTo_ns1__findServer:
		return soap_in_PointerTo_ns1__findServer(soap, NULL, NULL, "ns1:findServer");
	case SOAP_TYPE_PointerTo_ns1__getSoapServerVersionResponse:
		return soap_in_PointerTo_ns1__getSoapServerVersionResponse(soap, NULL, NULL, "ns1:getSoapServerVersionResponse");
	case SOAP_TYPE_PointerTo_ns1__getSoapServerVersion:
		return soap_in_PointerTo_ns1__getSoapServerVersion(soap, NULL, NULL, "ns1:getSoapServerVersion");
	case SOAP_TYPE_PointerTons1__ServerException:
		return soap_in_PointerTons1__ServerException(soap, NULL, NULL, "ns1:ServerException");
	case SOAP_TYPE_PointerTons1__SessionId:
		return soap_in_PointerTons1__SessionId(soap, NULL, NULL, "ns1:SessionId");
	case SOAP_TYPE_PointerTons2__JointRange:
		return soap_in_PointerTons2__JointRange(soap, NULL, NULL, "ns2:JointRange");
	case SOAP_TYPE_PointerTons2__Records:
		return soap_in_PointerTons2__Records(soap, NULL, NULL, "ns2:Records");
	case SOAP_TYPE_PointerTons2__Data:
		return soap_in_PointerTons2__Data(soap, NULL, NULL, "ns2:Data");
	case SOAP_TYPE_PointerTons2__VALApplications:
		return soap_in_PointerTons2__VALApplications(soap, NULL, NULL, "ns2:VALApplications");
	case SOAP_TYPE_PointerTons3__Include:
		return soap_in_PointerTons3__Include(soap, NULL, NULL, "ns3:Include");
	case SOAP_TYPE_PointerTons7__SoapDhParametersArray:
		return soap_in_PointerTons7__SoapDhParametersArray(soap, NULL, NULL, "ns7:SoapDhParametersArray");
	case SOAP_TYPE_PointerTons7__SoapPhysicalIoUnlockResponses:
		return soap_in_PointerTons7__SoapPhysicalIoUnlockResponses(soap, NULL, NULL, "ns7:SoapPhysicalIoUnlockResponses");
	case SOAP_TYPE_PointerTons7__SoapPhysicalIoResponses:
		return soap_in_PointerTons7__SoapPhysicalIoResponses(soap, NULL, NULL, "ns7:SoapPhysicalIoResponses");
	case SOAP_TYPE_PointerTons7__SoapPhysicalIoValues:
		return soap_in_PointerTons7__SoapPhysicalIoValues(soap, NULL, NULL, "ns7:SoapPhysicalIoValues");
	case SOAP_TYPE_PointerTons7__SoapPhysicalIosStates:
		return soap_in_PointerTons7__SoapPhysicalIosStates(soap, NULL, NULL, "ns7:SoapPhysicalIosStates");
	case SOAP_TYPE_PointerTons7__SoapPhysicalIoLinks:
		return soap_in_PointerTons7__SoapPhysicalIoLinks(soap, NULL, NULL, "ns7:SoapPhysicalIoLinks");
	case SOAP_TYPE_PointerTons7__SoapWatches:
		return soap_in_PointerTons7__SoapWatches(soap, NULL, NULL, "ns7:SoapWatches");
	case SOAP_TYPE_PointerTons7__MimeData:
		return soap_in_PointerTons7__MimeData(soap, NULL, NULL, "ns7:MimeData");
	case SOAP_TYPE_PointerTons7__SoapCallStack:
		return soap_in_PointerTons7__SoapCallStack(soap, NULL, NULL, "ns7:SoapCallStack");
	case SOAP_TYPE_PointerTons7__SoapTasks:
		return soap_in_PointerTons7__SoapTasks(soap, NULL, NULL, "ns7:SoapTasks");
	case SOAP_TYPE_PointerTons7__BreakpointsResponses:
		return soap_in_PointerTons7__BreakpointsResponses(soap, NULL, NULL, "ns7:BreakpointsResponses");
	case SOAP_TYPE_PointerTons7__SoapBreakpoints:
		return soap_in_PointerTons7__SoapBreakpoints(soap, NULL, NULL, "ns7:SoapBreakpoints");
	case SOAP_TYPE_PointerTons7__SoapPhysicalIoAttrib:
		return soap_in_PointerTons7__SoapPhysicalIoAttrib(soap, NULL, NULL, "ns7:SoapPhysicalIoAttrib");
	case SOAP_TYPE_PointerTons7__SoapPhysicalAioAttrib:
		return soap_in_PointerTons7__SoapPhysicalAioAttrib(soap, NULL, NULL, "ns7:SoapPhysicalAioAttrib");
	case SOAP_TYPE_PointerTons7__SoapPhysicalDioAttrib:
		return soap_in_PointerTons7__SoapPhysicalDioAttrib(soap, NULL, NULL, "ns7:SoapPhysicalDioAttrib");
	case SOAP_TYPE_PointerTons7__SoapInstruction:
		return soap_in_PointerTons7__SoapInstruction(soap, NULL, NULL, "ns7:SoapInstruction");
	case SOAP_TYPE_PointerTons7__SoapProgramLine:
		return soap_in_PointerTons7__SoapProgramLine(soap, NULL, NULL, "ns7:SoapProgramLine");
	case SOAP_TYPE_PointerTons7__SoapDhParameters:
		return soap_in_PointerTons7__SoapDhParameters(soap, NULL, NULL, "ns7:SoapDhParameters");
	case SOAP_TYPE_PointerTons7__SoapPhysicalIoUnlockResponse:
		return soap_in_PointerTons7__SoapPhysicalIoUnlockResponse(soap, NULL, NULL, "ns7:SoapPhysicalIoUnlockResponse");
	case SOAP_TYPE_PointerTons7__SoapPhysicalIoResponse:
		return soap_in_PointerTons7__SoapPhysicalIoResponse(soap, NULL, NULL, "ns7:SoapPhysicalIoResponse");
	case SOAP_TYPE_PointerTons7__SoapPhysicalIoState:
		return soap_in_PointerTons7__SoapPhysicalIoState(soap, NULL, NULL, "ns7:SoapPhysicalIoState");
	case SOAP_TYPE_PointerTons7__SoapData:
		return soap_in_PointerTons7__SoapData(soap, NULL, NULL, "ns7:SoapData");
	case SOAP_TYPE_PointerTons7__SoapStackFrameAbstract:
		return soap_in_PointerTons7__SoapStackFrameAbstract(soap, NULL, NULL, "ns7:SoapStackFrameAbstract");
	case SOAP_TYPE_PointerTons7__SoapTask:
		return soap_in_PointerTons7__SoapTask(soap, NULL, NULL, "ns7:SoapTask");
	case SOAP_TYPE_PointerTons7__BreakpointsResponse:
		return soap_in_PointerTons7__BreakpointsResponse(soap, NULL, NULL, "ns7:BreakpointsResponse");
	case SOAP_TYPE_PointerTons7__SoapBreakpoint:
		return soap_in_PointerTons7__SoapBreakpoint(soap, NULL, NULL, "ns7:SoapBreakpoint");
	case SOAP_TYPE_PointerTons2__VALApplication:
		return soap_in_PointerTons2__VALApplication(soap, NULL, NULL, "ns2:VALApplication");
	case SOAP_TYPE_PointerTons1__CartesianPos:
		return soap_in_PointerTons1__CartesianPos(soap, NULL, NULL, "ns1:CartesianPos");
	case SOAP_TYPE_PointerTons1__JointPos:
		return soap_in_PointerTons1__JointPos(soap, NULL, NULL, "ns1:JointPos");
	case SOAP_TYPE_PointerTons1__Robots:
		return soap_in_PointerTons1__Robots(soap, NULL, NULL, "ns1:Robots");
	case SOAP_TYPE_PointerTons1__Parameters:
		return soap_in_PointerTons1__Parameters(soap, NULL, NULL, "ns1:Parameters");
	case SOAP_TYPE_PointerTons1__Versions:
		return soap_in_PointerTons1__Versions(soap, NULL, NULL, "ns1:Versions");
	case SOAP_TYPE_PointerTons1__SoapServerVersion:
		return soap_in_PointerTons1__SoapServerVersion(soap, NULL, NULL, "ns1:SoapServerVersion");
	case SOAP_TYPE_PointerTons1__Robot:
		return soap_in_PointerTons1__Robot(soap, NULL, NULL, "ns1:Robot");
	case SOAP_TYPE_PointerTons1__Version:
		return soap_in_PointerTons1__Version(soap, NULL, NULL, "ns1:Version");
	case SOAP_TYPE_PointerTons1__Parameter:
		return soap_in_PointerTons1__Parameter(soap, NULL, NULL, "ns1:Parameter");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_in_PointerTounsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ns4:hexBinary"))
		{	*type = SOAP_TYPE_ns4__hexBinary;
			return soap_in_ns4__hexBinary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:base64Binary"))
		{	*type = SOAP_TYPE_ns4__base64Binary;
			return soap_in_ns4__base64Binary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:JointRange"))
		{	*type = SOAP_TYPE_ns2__JointRange;
			return soap_in_ns2__JointRange(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Records"))
		{	*type = SOAP_TYPE_ns2__Records;
			return soap_in_ns2__Records(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Data"))
		{	*type = SOAP_TYPE_ns2__Data;
			return soap_in_ns2__Data(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:VALApplications"))
		{	*type = SOAP_TYPE_ns2__VALApplications;
			return soap_in_ns2__VALApplications(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:VALApplication"))
		{	*type = SOAP_TYPE_ns2__VALApplication;
			return soap_in_ns2__VALApplication(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:Include"))
		{	*type = SOAP_TYPE_ns3__Include;
			return soap_in_ns3__Include(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:SoapDhParametersArray"))
		{	*type = SOAP_TYPE_ns7__SoapDhParametersArray;
			return soap_in_ns7__SoapDhParametersArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:SoapDhParameters"))
		{	*type = SOAP_TYPE_ns7__SoapDhParameters;
			return soap_in_ns7__SoapDhParameters(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:SoapPhysicalIoUnlockResponses"))
		{	*type = SOAP_TYPE_ns7__SoapPhysicalIoUnlockResponses;
			return soap_in_ns7__SoapPhysicalIoUnlockResponses(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:SoapPhysicalIoUnlockResponse"))
		{	*type = SOAP_TYPE_ns7__SoapPhysicalIoUnlockResponse;
			return soap_in_ns7__SoapPhysicalIoUnlockResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:SoapPhysicalIoResponses"))
		{	*type = SOAP_TYPE_ns7__SoapPhysicalIoResponses;
			return soap_in_ns7__SoapPhysicalIoResponses(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:SoapPhysicalIoResponse"))
		{	*type = SOAP_TYPE_ns7__SoapPhysicalIoResponse;
			return soap_in_ns7__SoapPhysicalIoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:SoapPhysicalIosStates"))
		{	*type = SOAP_TYPE_ns7__SoapPhysicalIosStates;
			return soap_in_ns7__SoapPhysicalIosStates(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:SoapPhysicalIoValues"))
		{	*type = SOAP_TYPE_ns7__SoapPhysicalIoValues;
			return soap_in_ns7__SoapPhysicalIoValues(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:SoapPhysicalIoState"))
		{	*type = SOAP_TYPE_ns7__SoapPhysicalIoState;
			return soap_in_ns7__SoapPhysicalIoState(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:SoapPhysicalIoAttrib"))
		{	*type = SOAP_TYPE_ns7__SoapPhysicalIoAttrib;
			return soap_in_ns7__SoapPhysicalIoAttrib(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:SoapPhysicalAioAttrib"))
		{	*type = SOAP_TYPE_ns7__SoapPhysicalAioAttrib;
			return soap_in_ns7__SoapPhysicalAioAttrib(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:SoapPhysicalDioAttrib"))
		{	*type = SOAP_TYPE_ns7__SoapPhysicalDioAttrib;
			return soap_in_ns7__SoapPhysicalDioAttrib(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:SoapPhysicalIoLinks"))
		{	*type = SOAP_TYPE_ns7__SoapPhysicalIoLinks;
			return soap_in_ns7__SoapPhysicalIoLinks(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:SoapWatches"))
		{	*type = SOAP_TYPE_ns7__SoapWatches;
			return soap_in_ns7__SoapWatches(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:SoapData"))
		{	*type = SOAP_TYPE_ns7__SoapData;
			return soap_in_ns7__SoapData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:SoapCallStack"))
		{	*type = SOAP_TYPE_ns7__SoapCallStack;
			return soap_in_ns7__SoapCallStack(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:SoapStackFrameAbstract"))
		{	*type = SOAP_TYPE_ns7__SoapStackFrameAbstract;
			return soap_in_ns7__SoapStackFrameAbstract(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:SoapInstruction"))
		{	*type = SOAP_TYPE_ns7__SoapInstruction;
			return soap_in_ns7__SoapInstruction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:SoapTasks"))
		{	*type = SOAP_TYPE_ns7__SoapTasks;
			return soap_in_ns7__SoapTasks(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:SoapTask"))
		{	*type = SOAP_TYPE_ns7__SoapTask;
			return soap_in_ns7__SoapTask(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:MimeData"))
		{	*type = SOAP_TYPE_ns7__MimeData;
			return soap_in_ns7__MimeData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:BreakpointsResponses"))
		{	*type = SOAP_TYPE_ns7__BreakpointsResponses;
			return soap_in_ns7__BreakpointsResponses(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:BreakpointsResponse"))
		{	*type = SOAP_TYPE_ns7__BreakpointsResponse;
			return soap_in_ns7__BreakpointsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:SoapBreakpoints"))
		{	*type = SOAP_TYPE_ns7__SoapBreakpoints;
			return soap_in_ns7__SoapBreakpoints(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:SoapBreakpoint"))
		{	*type = SOAP_TYPE_ns7__SoapBreakpoint;
			return soap_in_ns7__SoapBreakpoint(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:SoapProgramLine"))
		{	*type = SOAP_TYPE_ns7__SoapProgramLine;
			return soap_in_ns7__SoapProgramLine(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:Records"))
		{	*type = SOAP_TYPE_ns7__Records;
			return soap_in_ns7__Records(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:VALApplications"))
		{	*type = SOAP_TYPE_ns7__VALApplications;
			return soap_in_ns7__VALApplications(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:Robots"))
		{	*type = SOAP_TYPE_ns7__Robots;
			return soap_in_ns7__Robots(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:Versions"))
		{	*type = SOAP_TYPE_ns7__Versions;
			return soap_in_ns7__Versions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:Parameters"))
		{	*type = SOAP_TYPE_ns7__Parameters;
			return soap_in_ns7__Parameters(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:JointPos"))
		{	*type = SOAP_TYPE_ns7__JointPos;
			return soap_in_ns7__JointPos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:SoapDhParametersArray"))
		{	*type = SOAP_TYPE_ns5__SoapDhParametersArray;
			return soap_in_ns5__SoapDhParametersArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:SoapPhysicalIoUnlockResponses"))
		{	*type = SOAP_TYPE_ns5__SoapPhysicalIoUnlockResponses;
			return soap_in_ns5__SoapPhysicalIoUnlockResponses(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:SoapPhysicalIoResponses"))
		{	*type = SOAP_TYPE_ns5__SoapPhysicalIoResponses;
			return soap_in_ns5__SoapPhysicalIoResponses(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:SoapPhysicalIosStates"))
		{	*type = SOAP_TYPE_ns5__SoapPhysicalIosStates;
			return soap_in_ns5__SoapPhysicalIosStates(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:SoapPhysicalIoValues"))
		{	*type = SOAP_TYPE_ns5__SoapPhysicalIoValues;
			return soap_in_ns5__SoapPhysicalIoValues(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:SoapPhysicalIoLinks"))
		{	*type = SOAP_TYPE_ns5__SoapPhysicalIoLinks;
			return soap_in_ns5__SoapPhysicalIoLinks(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:SoapWatches"))
		{	*type = SOAP_TYPE_ns5__SoapWatches;
			return soap_in_ns5__SoapWatches(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:SoapCallStack"))
		{	*type = SOAP_TYPE_ns5__SoapCallStack;
			return soap_in_ns5__SoapCallStack(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:SoapTasks"))
		{	*type = SOAP_TYPE_ns5__SoapTasks;
			return soap_in_ns5__SoapTasks(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:BreakpointsResponses"))
		{	*type = SOAP_TYPE_ns5__BreakpointsResponses;
			return soap_in_ns5__BreakpointsResponses(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:SoapBreakpoints"))
		{	*type = SOAP_TYPE_ns5__SoapBreakpoints;
			return soap_in_ns5__SoapBreakpoints(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:Records"))
		{	*type = SOAP_TYPE_ns5__Records;
			return soap_in_ns5__Records(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:VALApplications"))
		{	*type = SOAP_TYPE_ns5__VALApplications;
			return soap_in_ns5__VALApplications(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:Robots"))
		{	*type = SOAP_TYPE_ns5__Robots;
			return soap_in_ns5__Robots(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:Versions"))
		{	*type = SOAP_TYPE_ns5__Versions;
			return soap_in_ns5__Versions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:Parameters"))
		{	*type = SOAP_TYPE_ns5__Parameters;
			return soap_in_ns5__Parameters(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:JointPos"))
		{	*type = SOAP_TYPE_ns5__JointPos;
			return soap_in_ns5__JointPos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Robots"))
		{	*type = SOAP_TYPE_ns1__Robots;
			return soap_in_ns1__Robots(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SoapServerVersion"))
		{	*type = SOAP_TYPE_ns1__SoapServerVersion;
			return soap_in_ns1__SoapServerVersion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Versions"))
		{	*type = SOAP_TYPE_ns1__Versions;
			return soap_in_ns1__Versions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Parameters"))
		{	*type = SOAP_TYPE_ns1__Parameters;
			return soap_in_ns1__Parameters(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Parameter"))
		{	*type = SOAP_TYPE_ns1__Parameter;
			return soap_in_ns1__Parameter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Version"))
		{	*type = SOAP_TYPE_ns1__Version;
			return soap_in_ns1__Version(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Robot"))
		{	*type = SOAP_TYPE_ns1__Robot;
			return soap_in_ns1__Robot(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CartesianPos"))
		{	*type = SOAP_TYPE_ns1__CartesianPos;
			return soap_in_ns1__CartesianPos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:JointPos"))
		{	*type = SOAP_TYPE_ns1__JointPos;
			return soap_in_ns1__JointPos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ServerException"))
		{	*type = SOAP_TYPE_ns1__ServerException;
			return soap_in_ns1__ServerException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:hexBinary"))
		{	*type = SOAP_TYPE_xsd__hexBinary;
			return soap_in_xsd__hexBinary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:base64Binary"))
		{	*type = SOAP_TYPE_xsd__base64Binary;
			return soap_in_xsd__base64Binary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	*type = SOAP_TYPE_xsd__anyURI;
			return soap_in_xsd__anyURI(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SessionId"))
		{	*type = SOAP_TYPE_ns1__SessionId;
			return soap_in_ns1__SessionId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_unsignedByte;
			return soap_in_unsignedByte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:replaceLineReturnCode"))
		{	*type = SOAP_TYPE_ns7__replaceLineReturnCode;
			return soap_in_ns7__replaceLineReturnCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:execVal3ReturnCode"))
		{	*type = SOAP_TYPE_ns7__execVal3ReturnCode;
			return soap_in_ns7__execVal3ReturnCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:SoapPhysicalIoEnumState"))
		{	*type = SOAP_TYPE_ns7__SoapPhysicalIoEnumState;
			return soap_in_ns7__SoapPhysicalIoEnumState(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:SoapTaskStep"))
		{	*type = SOAP_TYPE_ns7__SoapTaskStep;
			return soap_in_ns7__SoapTaskStep(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:SoapTaskState"))
		{	*type = SOAP_TYPE_ns7__SoapTaskState;
			return soap_in_ns7__SoapTaskState(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DiameterAxis3"))
		{	*type = SOAP_TYPE_ns1__DiameterAxis3;
			return soap_in_ns1__DiameterAxis3(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LengthAxis3"))
		{	*type = SOAP_TYPE_ns1__LengthAxis3;
			return soap_in_ns1__LengthAxis3(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MountType"))
		{	*type = SOAP_TYPE_ns1__MountType;
			return soap_in_ns1__MountType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Kinematic"))
		{	*type = SOAP_TYPE_ns1__Kinematic;
			return soap_in_ns1__Kinematic(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ServerExceptionCode"))
		{	*type = SOAP_TYPE_ns1__ServerExceptionCode;
			return soap_in_ns1__ServerExceptionCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns2:getJointRangeResponse"))
		{	*type = SOAP_TYPE__ns2__getJointRangeResponse;
			return soap_in__ns2__getJointRangeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getJointRange"))
		{	*type = SOAP_TYPE__ns2__getJointRange;
			return soap_in__ns2__getJointRange(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getRecordResponse"))
		{	*type = SOAP_TYPE__ns2__getRecordResponse;
			return soap_in__ns2__getRecordResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getRecord"))
		{	*type = SOAP_TYPE__ns2__getRecord;
			return soap_in__ns2__getRecord(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getRecordsResponse"))
		{	*type = SOAP_TYPE__ns2__getRecordsResponse;
			return soap_in__ns2__getRecordsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getRecords"))
		{	*type = SOAP_TYPE__ns2__getRecords;
			return soap_in__ns2__getRecords(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getApplicationDatasResponse"))
		{	*type = SOAP_TYPE__ns2__getApplicationDatasResponse;
			return soap_in__ns2__getApplicationDatasResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getApplicationDatas"))
		{	*type = SOAP_TYPE__ns2__getApplicationDatas;
			return soap_in__ns2__getApplicationDatas(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getApplicationsResponse"))
		{	*type = SOAP_TYPE__ns2__getApplicationsResponse;
			return soap_in__ns2__getApplicationsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getApplications"))
		{	*type = SOAP_TYPE__ns2__getApplications;
			return soap_in__ns2__getApplications(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:getProjectResponse"))
		{	*type = SOAP_TYPE__ns7__getProjectResponse;
			return soap_in__ns7__getProjectResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:getProject"))
		{	*type = SOAP_TYPE__ns7__getProject;
			return soap_in__ns7__getProject(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:SoapRobotDhParameters"))
		{	*type = SOAP_TYPE__ns7__SoapRobotDhParameters;
			return soap_in__ns7__SoapRobotDhParameters(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:getRobotDhParameters"))
		{	*type = SOAP_TYPE__ns7__getRobotDhParameters;
			return soap_in__ns7__getRobotDhParameters(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:getAllPhysicalIosResponse"))
		{	*type = SOAP_TYPE__ns7__getAllPhysicalIosResponse;
			return soap_in__ns7__getAllPhysicalIosResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:getAllPhysicalIos"))
		{	*type = SOAP_TYPE__ns7__getAllPhysicalIos;
			return soap_in__ns7__getAllPhysicalIos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:unlockAllIos"))
		{	*type = SOAP_TYPE__ns7__unlockAllIos;
			return soap_in__ns7__unlockAllIos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:SoapAllPhysicalIoResponse"))
		{	*type = SOAP_TYPE__ns7__SoapAllPhysicalIoResponse;
			return soap_in__ns7__SoapAllPhysicalIoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:lockAllIos"))
		{	*type = SOAP_TYPE__ns7__lockAllIos;
			return soap_in__ns7__lockAllIos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:unlockIosResponse"))
		{	*type = SOAP_TYPE__ns7__unlockIosResponse;
			return soap_in__ns7__unlockIosResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:unlockIos"))
		{	*type = SOAP_TYPE__ns7__unlockIos;
			return soap_in__ns7__unlockIos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:lockIosResponse"))
		{	*type = SOAP_TYPE__ns7__lockIosResponse;
			return soap_in__ns7__lockIosResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:lockIos"))
		{	*type = SOAP_TYPE__ns7__lockIos;
			return soap_in__ns7__lockIos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:writeIosResponse"))
		{	*type = SOAP_TYPE__ns7__writeIosResponse;
			return soap_in__ns7__writeIosResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:writeIos"))
		{	*type = SOAP_TYPE__ns7__writeIos;
			return soap_in__ns7__writeIos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:readIosResponse"))
		{	*type = SOAP_TYPE__ns7__readIosResponse;
			return soap_in__ns7__readIosResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:readIos"))
		{	*type = SOAP_TYPE__ns7__readIos;
			return soap_in__ns7__readIos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:replaceLineResponse"))
		{	*type = SOAP_TYPE__ns7__replaceLineResponse;
			return soap_in__ns7__replaceLineResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:replaceLine"))
		{	*type = SOAP_TYPE__ns7__replaceLine;
			return soap_in__ns7__replaceLine(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:setCurrentInstructionResponse"))
		{	*type = SOAP_TYPE__ns7__setCurrentInstructionResponse;
			return soap_in__ns7__setCurrentInstructionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:setCurrentInstruction"))
		{	*type = SOAP_TYPE__ns7__setCurrentInstruction;
			return soap_in__ns7__setCurrentInstruction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:setProjectAsModifiedResponse"))
		{	*type = SOAP_TYPE__ns7__setProjectAsModifiedResponse;
			return soap_in__ns7__setProjectAsModifiedResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:setProjectAsModified"))
		{	*type = SOAP_TYPE__ns7__setProjectAsModified;
			return soap_in__ns7__setProjectAsModified(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:execVal3Response"))
		{	*type = SOAP_TYPE__ns7__execVal3Response;
			return soap_in__ns7__execVal3Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:execVal3"))
		{	*type = SOAP_TYPE__ns7__execVal3;
			return soap_in__ns7__execVal3(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:getWatchResponse"))
		{	*type = SOAP_TYPE__ns7__getWatchResponse;
			return soap_in__ns7__getWatchResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:getWatches"))
		{	*type = SOAP_TYPE__ns7__getWatches;
			return soap_in__ns7__getWatches(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:getStackFrameResponse"))
		{	*type = SOAP_TYPE__ns7__getStackFrameResponse;
			return soap_in__ns7__getStackFrameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:getStackFrame"))
		{	*type = SOAP_TYPE__ns7__getStackFrame;
			return soap_in__ns7__getStackFrame(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:getCallStackResponse"))
		{	*type = SOAP_TYPE__ns7__getCallStackResponse;
			return soap_in__ns7__getCallStackResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:getCallStack"))
		{	*type = SOAP_TYPE__ns7__getCallStack;
			return soap_in__ns7__getCallStack(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:unsubscribeResponse"))
		{	*type = SOAP_TYPE__ns7__unsubscribeResponse;
			return soap_in__ns7__unsubscribeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:unsubscribeToControllerEvents"))
		{	*type = SOAP_TYPE__ns7__unsubscribeToControllerEvents;
			return soap_in__ns7__unsubscribeToControllerEvents(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:subscribeResponse"))
		{	*type = SOAP_TYPE__ns7__subscribeResponse;
			return soap_in__ns7__subscribeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:subscribeToControllerEvents"))
		{	*type = SOAP_TYPE__ns7__subscribeToControllerEvents;
			return soap_in__ns7__subscribeToControllerEvents(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:taskStepResponse"))
		{	*type = SOAP_TYPE__ns7__taskStepResponse;
			return soap_in__ns7__taskStepResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:taskStep"))
		{	*type = SOAP_TYPE__ns7__taskStep;
			return soap_in__ns7__taskStep(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:taskKillResponse"))
		{	*type = SOAP_TYPE__ns7__taskKillResponse;
			return soap_in__ns7__taskKillResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:taskKill"))
		{	*type = SOAP_TYPE__ns7__taskKill;
			return soap_in__ns7__taskKill(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:taskResumeResponse"))
		{	*type = SOAP_TYPE__ns7__taskResumeResponse;
			return soap_in__ns7__taskResumeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:taskResume"))
		{	*type = SOAP_TYPE__ns7__taskResume;
			return soap_in__ns7__taskResume(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:taskSuspendResponse"))
		{	*type = SOAP_TYPE__ns7__taskSuspendResponse;
			return soap_in__ns7__taskSuspendResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:taskSuspend"))
		{	*type = SOAP_TYPE__ns7__taskSuspend;
			return soap_in__ns7__taskSuspend(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:getTasksResponse"))
		{	*type = SOAP_TYPE__ns7__getTasksResponse;
			return soap_in__ns7__getTasksResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:getTasks"))
		{	*type = SOAP_TYPE__ns7__getTasks;
			return soap_in__ns7__getTasks(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:clearAllBreakpointsResponse"))
		{	*type = SOAP_TYPE__ns7__clearAllBreakpointsResponse;
			return soap_in__ns7__clearAllBreakpointsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:clearAllBreakpoints"))
		{	*type = SOAP_TYPE__ns7__clearAllBreakpoints;
			return soap_in__ns7__clearAllBreakpoints(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:clearBreakpointsResponse"))
		{	*type = SOAP_TYPE__ns7__clearBreakpointsResponse;
			return soap_in__ns7__clearBreakpointsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:clearBreakpoints"))
		{	*type = SOAP_TYPE__ns7__clearBreakpoints;
			return soap_in__ns7__clearBreakpoints(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:getBreakpointsResponse"))
		{	*type = SOAP_TYPE__ns7__getBreakpointsResponse;
			return soap_in__ns7__getBreakpointsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:getBreakpoints"))
		{	*type = SOAP_TYPE__ns7__getBreakpoints;
			return soap_in__ns7__getBreakpoints(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:setBreakpointsResponse"))
		{	*type = SOAP_TYPE__ns7__setBreakpointsResponse;
			return soap_in__ns7__setBreakpointsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:setBreakpoints"))
		{	*type = SOAP_TYPE__ns7__setBreakpoints;
			return soap_in__ns7__setBreakpoints(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setRobotPosResponse"))
		{	*type = SOAP_TYPE__ns1__setRobotPosResponse;
			return soap_in__ns1__setRobotPosResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setRobotJointPos"))
		{	*type = SOAP_TYPE__ns1__setRobotJointPos;
			return soap_in__ns1__setRobotJointPos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getRobotJntCartPosResponse"))
		{	*type = SOAP_TYPE__ns1__getRobotJntCartPosResponse;
			return soap_in__ns1__getRobotJntCartPosResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getRobotJntCartPos"))
		{	*type = SOAP_TYPE__ns1__getRobotJntCartPos;
			return soap_in__ns1__getRobotJntCartPos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getRobotJointPosResponse"))
		{	*type = SOAP_TYPE__ns1__getRobotJointPosResponse;
			return soap_in__ns1__getRobotJointPosResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getRobotJointPos"))
		{	*type = SOAP_TYPE__ns1__getRobotJointPos;
			return soap_in__ns1__getRobotJointPos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getRobotsResponse"))
		{	*type = SOAP_TYPE__ns1__getRobotsResponse;
			return soap_in__ns1__getRobotsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getRobots"))
		{	*type = SOAP_TYPE__ns1__getRobots;
			return soap_in__ns1__getRobots(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:logoutResponse"))
		{	*type = SOAP_TYPE__ns1__logoutResponse;
			return soap_in__ns1__logoutResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:logout"))
		{	*type = SOAP_TYPE__ns1__logout;
			return soap_in__ns1__logout(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:loginResponse"))
		{	*type = SOAP_TYPE__ns1__loginResponse;
			return soap_in__ns1__loginResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:login"))
		{	*type = SOAP_TYPE__ns1__login;
			return soap_in__ns1__login(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getCS8CompatibilityResponse"))
		{	*type = SOAP_TYPE__ns1__getCS8CompatibilityResponse;
			return soap_in__ns1__getCS8CompatibilityResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getCS8Compatibility"))
		{	*type = SOAP_TYPE__ns1__getCS8Compatibility;
			return soap_in__ns1__getCS8Compatibility(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getControllerParametersResponse"))
		{	*type = SOAP_TYPE__ns1__getControllerParametersResponse;
			return soap_in__ns1__getControllerParametersResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getControllerParameters"))
		{	*type = SOAP_TYPE__ns1__getControllerParameters;
			return soap_in__ns1__getControllerParameters(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getCS8VersionsResponse"))
		{	*type = SOAP_TYPE__ns1__getCS8VersionsResponse;
			return soap_in__ns1__getCS8VersionsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getCS8Versions"))
		{	*type = SOAP_TYPE__ns1__getCS8Versions;
			return soap_in__ns1__getCS8Versions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:pingResponse"))
		{	*type = SOAP_TYPE__ns1__pingResponse;
			return soap_in__ns1__pingResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ping"))
		{	*type = SOAP_TYPE__ns1__ping;
			return soap_in__ns1__ping(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findServerResponse"))
		{	*type = SOAP_TYPE__ns1__findServerResponse;
			return soap_in__ns1__findServerResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findServer"))
		{	*type = SOAP_TYPE__ns1__findServer;
			return soap_in__ns1__findServer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getSoapServerVersionResponse"))
		{	*type = SOAP_TYPE__ns1__getSoapServerVersionResponse;
			return soap_in__ns1__getSoapServerVersionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getSoapServerVersion"))
		{	*type = SOAP_TYPE__ns1__getSoapServerVersion;
			return soap_in__ns1__getSoapServerVersion(soap, NULL, NULL, NULL);
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level = %u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other && !soap->fignore)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				if (soap_ignore(soap) || soap_element_end_in(soap, NULL))
					return soap->error;
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_ns1__SessionId:
		return soap_out_ns1__SessionId(soap, tag, id, (const int *)ptr, "ns1:SessionId");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_unsignedByte:
		return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_ns7__replaceLineReturnCode:
		return soap_out_ns7__replaceLineReturnCode(soap, tag, id, (const enum ns7__replaceLineReturnCode *)ptr, "ns7:replaceLineReturnCode");
	case SOAP_TYPE_ns7__execVal3ReturnCode:
		return soap_out_ns7__execVal3ReturnCode(soap, tag, id, (const enum ns7__execVal3ReturnCode *)ptr, "ns7:execVal3ReturnCode");
	case SOAP_TYPE_ns7__SoapPhysicalIoEnumState:
		return soap_out_ns7__SoapPhysicalIoEnumState(soap, tag, id, (const enum ns7__SoapPhysicalIoEnumState *)ptr, "ns7:SoapPhysicalIoEnumState");
	case SOAP_TYPE_ns7__SoapTaskStep:
		return soap_out_ns7__SoapTaskStep(soap, tag, id, (const enum ns7__SoapTaskStep *)ptr, "ns7:SoapTaskStep");
	case SOAP_TYPE_ns7__SoapTaskState:
		return soap_out_ns7__SoapTaskState(soap, tag, id, (const enum ns7__SoapTaskState *)ptr, "ns7:SoapTaskState");
	case SOAP_TYPE_ns1__DiameterAxis3:
		return soap_out_ns1__DiameterAxis3(soap, tag, id, (const enum ns1__DiameterAxis3 *)ptr, "ns1:DiameterAxis3");
	case SOAP_TYPE_ns1__LengthAxis3:
		return soap_out_ns1__LengthAxis3(soap, tag, id, (const enum ns1__LengthAxis3 *)ptr, "ns1:LengthAxis3");
	case SOAP_TYPE_ns1__MountType:
		return soap_out_ns1__MountType(soap, tag, id, (const enum ns1__MountType *)ptr, "ns1:MountType");
	case SOAP_TYPE_ns1__Kinematic:
		return soap_out_ns1__Kinematic(soap, tag, id, (const enum ns1__Kinematic *)ptr, "ns1:Kinematic");
	case SOAP_TYPE_ns1__ServerExceptionCode:
		return soap_out_ns1__ServerExceptionCode(soap, tag, id, (const enum ns1__ServerExceptionCode *)ptr, "ns1:ServerExceptionCode");
	case SOAP_TYPE_ns4__hexBinary:
		return ((ns4__hexBinary *)ptr)->soap_out(soap, tag, id, "ns4:hexBinary");
	case SOAP_TYPE_ns4__base64Binary:
		return ((ns4__base64Binary *)ptr)->soap_out(soap, tag, id, "ns4:base64Binary");
	case SOAP_TYPE__ns2__getJointRangeResponse:
		return ((_ns2__getJointRangeResponse *)ptr)->soap_out(soap, "ns2:getJointRangeResponse", id, "");
	case SOAP_TYPE__ns2__getJointRange:
		return ((_ns2__getJointRange *)ptr)->soap_out(soap, "ns2:getJointRange", id, "");
	case SOAP_TYPE__ns2__getRecordResponse:
		return ((_ns2__getRecordResponse *)ptr)->soap_out(soap, "ns2:getRecordResponse", id, "");
	case SOAP_TYPE__ns2__getRecord:
		return ((_ns2__getRecord *)ptr)->soap_out(soap, "ns2:getRecord", id, "");
	case SOAP_TYPE__ns2__getRecordsResponse:
		return ((_ns2__getRecordsResponse *)ptr)->soap_out(soap, "ns2:getRecordsResponse", id, "");
	case SOAP_TYPE__ns2__getRecords:
		return ((_ns2__getRecords *)ptr)->soap_out(soap, "ns2:getRecords", id, "");
	case SOAP_TYPE__ns2__getApplicationDatasResponse:
		return ((_ns2__getApplicationDatasResponse *)ptr)->soap_out(soap, "ns2:getApplicationDatasResponse", id, "");
	case SOAP_TYPE__ns2__getApplicationDatas:
		return ((_ns2__getApplicationDatas *)ptr)->soap_out(soap, "ns2:getApplicationDatas", id, "");
	case SOAP_TYPE__ns2__getApplicationsResponse:
		return ((_ns2__getApplicationsResponse *)ptr)->soap_out(soap, "ns2:getApplicationsResponse", id, "");
	case SOAP_TYPE__ns2__getApplications:
		return ((_ns2__getApplications *)ptr)->soap_out(soap, "ns2:getApplications", id, "");
	case SOAP_TYPE_ns2__JointRange:
		return ((ns2__JointRange *)ptr)->soap_out(soap, tag, id, "ns2:JointRange");
	case SOAP_TYPE_ns2__Records:
		return ((ns2__Records *)ptr)->soap_out(soap, tag, id, "ns2:Records");
	case SOAP_TYPE_ns2__Data:
		return ((ns2__Data *)ptr)->soap_out(soap, tag, id, "ns2:Data");
	case SOAP_TYPE_ns2__VALApplications:
		return ((ns2__VALApplications *)ptr)->soap_out(soap, tag, id, "ns2:VALApplications");
	case SOAP_TYPE_ns2__VALApplication:
		return ((ns2__VALApplication *)ptr)->soap_out(soap, tag, id, "ns2:VALApplication");
	case SOAP_TYPE_ns3__Include:
		return ((ns3__Include *)ptr)->soap_out(soap, tag, id, "ns3:Include");
	case SOAP_TYPE__ns7__getProjectResponse:
		return ((_ns7__getProjectResponse *)ptr)->soap_out(soap, "ns7:getProjectResponse", id, "");
	case SOAP_TYPE__ns7__getProject:
		return ((_ns7__getProject *)ptr)->soap_out(soap, "ns7:getProject", id, "");
	case SOAP_TYPE__ns7__SoapRobotDhParameters:
		return ((_ns7__SoapRobotDhParameters *)ptr)->soap_out(soap, "ns7:SoapRobotDhParameters", id, "");
	case SOAP_TYPE__ns7__getRobotDhParameters:
		return ((_ns7__getRobotDhParameters *)ptr)->soap_out(soap, "ns7:getRobotDhParameters", id, "");
	case SOAP_TYPE__ns7__getAllPhysicalIosResponse:
		return ((_ns7__getAllPhysicalIosResponse *)ptr)->soap_out(soap, "ns7:getAllPhysicalIosResponse", id, "");
	case SOAP_TYPE__ns7__getAllPhysicalIos:
		return ((_ns7__getAllPhysicalIos *)ptr)->soap_out(soap, "ns7:getAllPhysicalIos", id, "");
	case SOAP_TYPE__ns7__unlockAllIos:
		return ((_ns7__unlockAllIos *)ptr)->soap_out(soap, "ns7:unlockAllIos", id, "");
	case SOAP_TYPE__ns7__SoapAllPhysicalIoResponse:
		return ((_ns7__SoapAllPhysicalIoResponse *)ptr)->soap_out(soap, "ns7:SoapAllPhysicalIoResponse", id, "");
	case SOAP_TYPE__ns7__lockAllIos:
		return ((_ns7__lockAllIos *)ptr)->soap_out(soap, "ns7:lockAllIos", id, "");
	case SOAP_TYPE__ns7__unlockIosResponse:
		return ((_ns7__unlockIosResponse *)ptr)->soap_out(soap, "ns7:unlockIosResponse", id, "");
	case SOAP_TYPE__ns7__unlockIos:
		return ((_ns7__unlockIos *)ptr)->soap_out(soap, "ns7:unlockIos", id, "");
	case SOAP_TYPE__ns7__lockIosResponse:
		return ((_ns7__lockIosResponse *)ptr)->soap_out(soap, "ns7:lockIosResponse", id, "");
	case SOAP_TYPE__ns7__lockIos:
		return ((_ns7__lockIos *)ptr)->soap_out(soap, "ns7:lockIos", id, "");
	case SOAP_TYPE__ns7__writeIosResponse:
		return ((_ns7__writeIosResponse *)ptr)->soap_out(soap, "ns7:writeIosResponse", id, "");
	case SOAP_TYPE__ns7__writeIos:
		return ((_ns7__writeIos *)ptr)->soap_out(soap, "ns7:writeIos", id, "");
	case SOAP_TYPE__ns7__readIosResponse:
		return ((_ns7__readIosResponse *)ptr)->soap_out(soap, "ns7:readIosResponse", id, "");
	case SOAP_TYPE__ns7__readIos:
		return ((_ns7__readIos *)ptr)->soap_out(soap, "ns7:readIos", id, "");
	case SOAP_TYPE__ns7__replaceLineResponse:
		return ((_ns7__replaceLineResponse *)ptr)->soap_out(soap, "ns7:replaceLineResponse", id, "");
	case SOAP_TYPE__ns7__replaceLine:
		return ((_ns7__replaceLine *)ptr)->soap_out(soap, "ns7:replaceLine", id, "");
	case SOAP_TYPE__ns7__setCurrentInstructionResponse:
		return ((_ns7__setCurrentInstructionResponse *)ptr)->soap_out(soap, "ns7:setCurrentInstructionResponse", id, "");
	case SOAP_TYPE__ns7__setCurrentInstruction:
		return ((_ns7__setCurrentInstruction *)ptr)->soap_out(soap, "ns7:setCurrentInstruction", id, "");
	case SOAP_TYPE__ns7__setProjectAsModifiedResponse:
		return ((_ns7__setProjectAsModifiedResponse *)ptr)->soap_out(soap, "ns7:setProjectAsModifiedResponse", id, "");
	case SOAP_TYPE__ns7__setProjectAsModified:
		return ((_ns7__setProjectAsModified *)ptr)->soap_out(soap, "ns7:setProjectAsModified", id, "");
	case SOAP_TYPE__ns7__execVal3Response:
		return ((_ns7__execVal3Response *)ptr)->soap_out(soap, "ns7:execVal3Response", id, "");
	case SOAP_TYPE__ns7__execVal3:
		return ((_ns7__execVal3 *)ptr)->soap_out(soap, "ns7:execVal3", id, "");
	case SOAP_TYPE__ns7__getWatchResponse:
		return ((_ns7__getWatchResponse *)ptr)->soap_out(soap, "ns7:getWatchResponse", id, "");
	case SOAP_TYPE__ns7__getWatches:
		return ((_ns7__getWatches *)ptr)->soap_out(soap, "ns7:getWatches", id, "");
	case SOAP_TYPE__ns7__getStackFrameResponse:
		return ((_ns7__getStackFrameResponse *)ptr)->soap_out(soap, "ns7:getStackFrameResponse", id, "");
	case SOAP_TYPE__ns7__getStackFrame:
		return ((_ns7__getStackFrame *)ptr)->soap_out(soap, "ns7:getStackFrame", id, "");
	case SOAP_TYPE__ns7__getCallStackResponse:
		return ((_ns7__getCallStackResponse *)ptr)->soap_out(soap, "ns7:getCallStackResponse", id, "");
	case SOAP_TYPE__ns7__getCallStack:
		return ((_ns7__getCallStack *)ptr)->soap_out(soap, "ns7:getCallStack", id, "");
	case SOAP_TYPE__ns7__unsubscribeResponse:
		return ((_ns7__unsubscribeResponse *)ptr)->soap_out(soap, "ns7:unsubscribeResponse", id, "");
	case SOAP_TYPE__ns7__unsubscribeToControllerEvents:
		return ((_ns7__unsubscribeToControllerEvents *)ptr)->soap_out(soap, "ns7:unsubscribeToControllerEvents", id, "");
	case SOAP_TYPE__ns7__subscribeResponse:
		return ((_ns7__subscribeResponse *)ptr)->soap_out(soap, "ns7:subscribeResponse", id, "");
	case SOAP_TYPE__ns7__subscribeToControllerEvents:
		return ((_ns7__subscribeToControllerEvents *)ptr)->soap_out(soap, "ns7:subscribeToControllerEvents", id, "");
	case SOAP_TYPE__ns7__taskStepResponse:
		return ((_ns7__taskStepResponse *)ptr)->soap_out(soap, "ns7:taskStepResponse", id, "");
	case SOAP_TYPE__ns7__taskStep:
		return ((_ns7__taskStep *)ptr)->soap_out(soap, "ns7:taskStep", id, "");
	case SOAP_TYPE__ns7__taskKillResponse:
		return ((_ns7__taskKillResponse *)ptr)->soap_out(soap, "ns7:taskKillResponse", id, "");
	case SOAP_TYPE__ns7__taskKill:
		return ((_ns7__taskKill *)ptr)->soap_out(soap, "ns7:taskKill", id, "");
	case SOAP_TYPE__ns7__taskResumeResponse:
		return ((_ns7__taskResumeResponse *)ptr)->soap_out(soap, "ns7:taskResumeResponse", id, "");
	case SOAP_TYPE__ns7__taskResume:
		return ((_ns7__taskResume *)ptr)->soap_out(soap, "ns7:taskResume", id, "");
	case SOAP_TYPE__ns7__taskSuspendResponse:
		return ((_ns7__taskSuspendResponse *)ptr)->soap_out(soap, "ns7:taskSuspendResponse", id, "");
	case SOAP_TYPE__ns7__taskSuspend:
		return ((_ns7__taskSuspend *)ptr)->soap_out(soap, "ns7:taskSuspend", id, "");
	case SOAP_TYPE__ns7__getTasksResponse:
		return ((_ns7__getTasksResponse *)ptr)->soap_out(soap, "ns7:getTasksResponse", id, "");
	case SOAP_TYPE__ns7__getTasks:
		return ((_ns7__getTasks *)ptr)->soap_out(soap, "ns7:getTasks", id, "");
	case SOAP_TYPE__ns7__clearAllBreakpointsResponse:
		return ((_ns7__clearAllBreakpointsResponse *)ptr)->soap_out(soap, "ns7:clearAllBreakpointsResponse", id, "");
	case SOAP_TYPE__ns7__clearAllBreakpoints:
		return ((_ns7__clearAllBreakpoints *)ptr)->soap_out(soap, "ns7:clearAllBreakpoints", id, "");
	case SOAP_TYPE__ns7__clearBreakpointsResponse:
		return ((_ns7__clearBreakpointsResponse *)ptr)->soap_out(soap, "ns7:clearBreakpointsResponse", id, "");
	case SOAP_TYPE__ns7__clearBreakpoints:
		return ((_ns7__clearBreakpoints *)ptr)->soap_out(soap, "ns7:clearBreakpoints", id, "");
	case SOAP_TYPE__ns7__getBreakpointsResponse:
		return ((_ns7__getBreakpointsResponse *)ptr)->soap_out(soap, "ns7:getBreakpointsResponse", id, "");
	case SOAP_TYPE__ns7__getBreakpoints:
		return ((_ns7__getBreakpoints *)ptr)->soap_out(soap, "ns7:getBreakpoints", id, "");
	case SOAP_TYPE__ns7__setBreakpointsResponse:
		return ((_ns7__setBreakpointsResponse *)ptr)->soap_out(soap, "ns7:setBreakpointsResponse", id, "");
	case SOAP_TYPE__ns7__setBreakpoints:
		return ((_ns7__setBreakpoints *)ptr)->soap_out(soap, "ns7:setBreakpoints", id, "");
	case SOAP_TYPE_ns7__SoapDhParametersArray:
		return ((ns7__SoapDhParametersArray *)ptr)->soap_out(soap, tag, id, "ns7:SoapDhParametersArray");
	case SOAP_TYPE_ns7__SoapDhParameters:
		return ((ns7__SoapDhParameters *)ptr)->soap_out(soap, tag, id, "ns7:SoapDhParameters");
	case SOAP_TYPE_ns7__SoapPhysicalIoUnlockResponses:
		return ((ns7__SoapPhysicalIoUnlockResponses *)ptr)->soap_out(soap, tag, id, "ns7:SoapPhysicalIoUnlockResponses");
	case SOAP_TYPE_ns7__SoapPhysicalIoUnlockResponse:
		return ((ns7__SoapPhysicalIoUnlockResponse *)ptr)->soap_out(soap, tag, id, "ns7:SoapPhysicalIoUnlockResponse");
	case SOAP_TYPE_ns7__SoapPhysicalIoResponses:
		return ((ns7__SoapPhysicalIoResponses *)ptr)->soap_out(soap, tag, id, "ns7:SoapPhysicalIoResponses");
	case SOAP_TYPE_ns7__SoapPhysicalIoResponse:
		return ((ns7__SoapPhysicalIoResponse *)ptr)->soap_out(soap, tag, id, "ns7:SoapPhysicalIoResponse");
	case SOAP_TYPE_ns7__SoapPhysicalIosStates:
		return ((ns7__SoapPhysicalIosStates *)ptr)->soap_out(soap, tag, id, "ns7:SoapPhysicalIosStates");
	case SOAP_TYPE_ns7__SoapPhysicalIoValues:
		return ((ns7__SoapPhysicalIoValues *)ptr)->soap_out(soap, tag, id, "ns7:SoapPhysicalIoValues");
	case SOAP_TYPE_ns7__SoapPhysicalIoState:
		return ((ns7__SoapPhysicalIoState *)ptr)->soap_out(soap, tag, id, "ns7:SoapPhysicalIoState");
	case SOAP_TYPE_ns7__SoapPhysicalIoAttrib:
		return ((ns7__SoapPhysicalIoAttrib *)ptr)->soap_out(soap, tag, id, "ns7:SoapPhysicalIoAttrib");
	case SOAP_TYPE_ns7__SoapPhysicalAioAttrib:
		return ((ns7__SoapPhysicalAioAttrib *)ptr)->soap_out(soap, tag, id, "ns7:SoapPhysicalAioAttrib");
	case SOAP_TYPE_ns7__SoapPhysicalDioAttrib:
		return ((ns7__SoapPhysicalDioAttrib *)ptr)->soap_out(soap, tag, id, "ns7:SoapPhysicalDioAttrib");
	case SOAP_TYPE_ns7__SoapPhysicalIoLinks:
		return ((ns7__SoapPhysicalIoLinks *)ptr)->soap_out(soap, tag, id, "ns7:SoapPhysicalIoLinks");
	case SOAP_TYPE_ns7__SoapWatches:
		return ((ns7__SoapWatches *)ptr)->soap_out(soap, tag, id, "ns7:SoapWatches");
	case SOAP_TYPE_ns7__SoapData:
		return ((ns7__SoapData *)ptr)->soap_out(soap, tag, id, "ns7:SoapData");
	case SOAP_TYPE_ns7__SoapCallStack:
		return ((ns7__SoapCallStack *)ptr)->soap_out(soap, tag, id, "ns7:SoapCallStack");
	case SOAP_TYPE_ns7__SoapStackFrameAbstract:
		return ((ns7__SoapStackFrameAbstract *)ptr)->soap_out(soap, tag, id, "ns7:SoapStackFrameAbstract");
	case SOAP_TYPE_ns7__SoapInstruction:
		return ((ns7__SoapInstruction *)ptr)->soap_out(soap, tag, id, "ns7:SoapInstruction");
	case SOAP_TYPE_ns7__SoapTasks:
		return ((ns7__SoapTasks *)ptr)->soap_out(soap, tag, id, "ns7:SoapTasks");
	case SOAP_TYPE_ns7__SoapTask:
		return ((ns7__SoapTask *)ptr)->soap_out(soap, tag, id, "ns7:SoapTask");
	case SOAP_TYPE_ns7__MimeData:
		return ((ns7__MimeData *)ptr)->soap_out(soap, tag, id, "ns7:MimeData");
	case SOAP_TYPE_ns7__BreakpointsResponses:
		return ((ns7__BreakpointsResponses *)ptr)->soap_out(soap, tag, id, "ns7:BreakpointsResponses");
	case SOAP_TYPE_ns7__BreakpointsResponse:
		return ((ns7__BreakpointsResponse *)ptr)->soap_out(soap, tag, id, "ns7:BreakpointsResponse");
	case SOAP_TYPE_ns7__SoapBreakpoints:
		return ((ns7__SoapBreakpoints *)ptr)->soap_out(soap, tag, id, "ns7:SoapBreakpoints");
	case SOAP_TYPE_ns7__SoapBreakpoint:
		return ((ns7__SoapBreakpoint *)ptr)->soap_out(soap, tag, id, "ns7:SoapBreakpoint");
	case SOAP_TYPE_ns7__SoapProgramLine:
		return ((ns7__SoapProgramLine *)ptr)->soap_out(soap, tag, id, "ns7:SoapProgramLine");
	case SOAP_TYPE_ns7__Records:
		return ((ns7__Records *)ptr)->soap_out(soap, tag, id, "ns7:Records");
	case SOAP_TYPE_ns7__VALApplications:
		return ((ns7__VALApplications *)ptr)->soap_out(soap, tag, id, "ns7:VALApplications");
	case SOAP_TYPE_ns7__Robots:
		return ((ns7__Robots *)ptr)->soap_out(soap, tag, id, "ns7:Robots");
	case SOAP_TYPE_ns7__Versions:
		return ((ns7__Versions *)ptr)->soap_out(soap, tag, id, "ns7:Versions");
	case SOAP_TYPE_ns7__Parameters:
		return ((ns7__Parameters *)ptr)->soap_out(soap, tag, id, "ns7:Parameters");
	case SOAP_TYPE_ns7__JointPos:
		return ((ns7__JointPos *)ptr)->soap_out(soap, tag, id, "ns7:JointPos");
	case SOAP_TYPE_ns5__SoapDhParametersArray:
		return ((ns5__SoapDhParametersArray *)ptr)->soap_out(soap, tag, id, "ns5:SoapDhParametersArray");
	case SOAP_TYPE_ns5__SoapPhysicalIoUnlockResponses:
		return ((ns5__SoapPhysicalIoUnlockResponses *)ptr)->soap_out(soap, tag, id, "ns5:SoapPhysicalIoUnlockResponses");
	case SOAP_TYPE_ns5__SoapPhysicalIoResponses:
		return ((ns5__SoapPhysicalIoResponses *)ptr)->soap_out(soap, tag, id, "ns5:SoapPhysicalIoResponses");
	case SOAP_TYPE_ns5__SoapPhysicalIosStates:
		return ((ns5__SoapPhysicalIosStates *)ptr)->soap_out(soap, tag, id, "ns5:SoapPhysicalIosStates");
	case SOAP_TYPE_ns5__SoapPhysicalIoValues:
		return ((ns5__SoapPhysicalIoValues *)ptr)->soap_out(soap, tag, id, "ns5:SoapPhysicalIoValues");
	case SOAP_TYPE_ns5__SoapPhysicalIoLinks:
		return ((ns5__SoapPhysicalIoLinks *)ptr)->soap_out(soap, tag, id, "ns5:SoapPhysicalIoLinks");
	case SOAP_TYPE_ns5__SoapWatches:
		return ((ns5__SoapWatches *)ptr)->soap_out(soap, tag, id, "ns5:SoapWatches");
	case SOAP_TYPE_ns5__SoapCallStack:
		return ((ns5__SoapCallStack *)ptr)->soap_out(soap, tag, id, "ns5:SoapCallStack");
	case SOAP_TYPE_ns5__SoapTasks:
		return ((ns5__SoapTasks *)ptr)->soap_out(soap, tag, id, "ns5:SoapTasks");
	case SOAP_TYPE_ns5__BreakpointsResponses:
		return ((ns5__BreakpointsResponses *)ptr)->soap_out(soap, tag, id, "ns5:BreakpointsResponses");
	case SOAP_TYPE_ns5__SoapBreakpoints:
		return ((ns5__SoapBreakpoints *)ptr)->soap_out(soap, tag, id, "ns5:SoapBreakpoints");
	case SOAP_TYPE_ns5__Records:
		return ((ns5__Records *)ptr)->soap_out(soap, tag, id, "ns5:Records");
	case SOAP_TYPE_ns5__VALApplications:
		return ((ns5__VALApplications *)ptr)->soap_out(soap, tag, id, "ns5:VALApplications");
	case SOAP_TYPE_ns5__Robots:
		return ((ns5__Robots *)ptr)->soap_out(soap, tag, id, "ns5:Robots");
	case SOAP_TYPE_ns5__Versions:
		return ((ns5__Versions *)ptr)->soap_out(soap, tag, id, "ns5:Versions");
	case SOAP_TYPE_ns5__Parameters:
		return ((ns5__Parameters *)ptr)->soap_out(soap, tag, id, "ns5:Parameters");
	case SOAP_TYPE_ns5__JointPos:
		return ((ns5__JointPos *)ptr)->soap_out(soap, tag, id, "ns5:JointPos");
	case SOAP_TYPE__ns1__setRobotPosResponse:
		return ((_ns1__setRobotPosResponse *)ptr)->soap_out(soap, "ns1:setRobotPosResponse", id, "");
	case SOAP_TYPE__ns1__setRobotJointPos:
		return ((_ns1__setRobotJointPos *)ptr)->soap_out(soap, "ns1:setRobotJointPos", id, "");
	case SOAP_TYPE__ns1__getRobotJntCartPosResponse:
		return ((_ns1__getRobotJntCartPosResponse *)ptr)->soap_out(soap, "ns1:getRobotJntCartPosResponse", id, "");
	case SOAP_TYPE__ns1__getRobotJntCartPos:
		return ((_ns1__getRobotJntCartPos *)ptr)->soap_out(soap, "ns1:getRobotJntCartPos", id, "");
	case SOAP_TYPE__ns1__getRobotJointPosResponse:
		return ((_ns1__getRobotJointPosResponse *)ptr)->soap_out(soap, "ns1:getRobotJointPosResponse", id, "");
	case SOAP_TYPE__ns1__getRobotJointPos:
		return ((_ns1__getRobotJointPos *)ptr)->soap_out(soap, "ns1:getRobotJointPos", id, "");
	case SOAP_TYPE__ns1__getRobotsResponse:
		return ((_ns1__getRobotsResponse *)ptr)->soap_out(soap, "ns1:getRobotsResponse", id, "");
	case SOAP_TYPE__ns1__getRobots:
		return ((_ns1__getRobots *)ptr)->soap_out(soap, "ns1:getRobots", id, "");
	case SOAP_TYPE__ns1__logoutResponse:
		return ((_ns1__logoutResponse *)ptr)->soap_out(soap, "ns1:logoutResponse", id, "");
	case SOAP_TYPE__ns1__logout:
		return ((_ns1__logout *)ptr)->soap_out(soap, "ns1:logout", id, "");
	case SOAP_TYPE__ns1__loginResponse:
		return ((_ns1__loginResponse *)ptr)->soap_out(soap, "ns1:loginResponse", id, "");
	case SOAP_TYPE__ns1__login:
		return ((_ns1__login *)ptr)->soap_out(soap, "ns1:login", id, "");
	case SOAP_TYPE__ns1__getCS8CompatibilityResponse:
		return ((_ns1__getCS8CompatibilityResponse *)ptr)->soap_out(soap, "ns1:getCS8CompatibilityResponse", id, "");
	case SOAP_TYPE__ns1__getCS8Compatibility:
		return ((_ns1__getCS8Compatibility *)ptr)->soap_out(soap, "ns1:getCS8Compatibility", id, "");
	case SOAP_TYPE__ns1__getControllerParametersResponse:
		return ((_ns1__getControllerParametersResponse *)ptr)->soap_out(soap, "ns1:getControllerParametersResponse", id, "");
	case SOAP_TYPE__ns1__getControllerParameters:
		return ((_ns1__getControllerParameters *)ptr)->soap_out(soap, "ns1:getControllerParameters", id, "");
	case SOAP_TYPE__ns1__getCS8VersionsResponse:
		return ((_ns1__getCS8VersionsResponse *)ptr)->soap_out(soap, "ns1:getCS8VersionsResponse", id, "");
	case SOAP_TYPE__ns1__getCS8Versions:
		return ((_ns1__getCS8Versions *)ptr)->soap_out(soap, "ns1:getCS8Versions", id, "");
	case SOAP_TYPE__ns1__pingResponse:
		return ((_ns1__pingResponse *)ptr)->soap_out(soap, "ns1:pingResponse", id, "");
	case SOAP_TYPE__ns1__ping:
		return ((_ns1__ping *)ptr)->soap_out(soap, "ns1:ping", id, "");
	case SOAP_TYPE__ns1__findServerResponse:
		return ((_ns1__findServerResponse *)ptr)->soap_out(soap, "ns1:findServerResponse", id, "");
	case SOAP_TYPE__ns1__findServer:
		return ((_ns1__findServer *)ptr)->soap_out(soap, "ns1:findServer", id, "");
	case SOAP_TYPE__ns1__getSoapServerVersionResponse:
		return ((_ns1__getSoapServerVersionResponse *)ptr)->soap_out(soap, "ns1:getSoapServerVersionResponse", id, "");
	case SOAP_TYPE__ns1__getSoapServerVersion:
		return ((_ns1__getSoapServerVersion *)ptr)->soap_out(soap, "ns1:getSoapServerVersion", id, "");
	case SOAP_TYPE_ns1__Robots:
		return ((ns1__Robots *)ptr)->soap_out(soap, tag, id, "ns1:Robots");
	case SOAP_TYPE_ns1__SoapServerVersion:
		return ((ns1__SoapServerVersion *)ptr)->soap_out(soap, tag, id, "ns1:SoapServerVersion");
	case SOAP_TYPE_ns1__Versions:
		return ((ns1__Versions *)ptr)->soap_out(soap, tag, id, "ns1:Versions");
	case SOAP_TYPE_ns1__Parameters:
		return ((ns1__Parameters *)ptr)->soap_out(soap, tag, id, "ns1:Parameters");
	case SOAP_TYPE_ns1__Parameter:
		return ((ns1__Parameter *)ptr)->soap_out(soap, tag, id, "ns1:Parameter");
	case SOAP_TYPE_ns1__Version:
		return ((ns1__Version *)ptr)->soap_out(soap, tag, id, "ns1:Version");
	case SOAP_TYPE_ns1__Robot:
		return ((ns1__Robot *)ptr)->soap_out(soap, tag, id, "ns1:Robot");
	case SOAP_TYPE_ns1__CartesianPos:
		return ((ns1__CartesianPos *)ptr)->soap_out(soap, tag, id, "ns1:CartesianPos");
	case SOAP_TYPE_ns1__JointPos:
		return ((ns1__JointPos *)ptr)->soap_out(soap, tag, id, "ns1:JointPos");
	case SOAP_TYPE_ns1__ServerException:
		return ((ns1__ServerException *)ptr)->soap_out(soap, tag, id, "ns1:ServerException");
	case SOAP_TYPE_xsd__hexBinary:
		return ((xsd__hexBinary *)ptr)->soap_out(soap, tag, id, "xsd:hexBinary");
	case SOAP_TYPE_xsd__base64Binary:
		return ((xsd__base64Binary *)ptr)->soap_out(soap, tag, id, "xsd:base64Binary");
	case SOAP_TYPE_xsd__anyURI:
		return soap_out_xsd__anyURI(soap, tag, id, (const std::string *)ptr, "xsd:anyURI");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_PointerTo_ns7__getProjectResponse:
		return soap_out_PointerTo_ns7__getProjectResponse(soap, tag, id, (_ns7__getProjectResponse *const*)ptr, "ns7:getProjectResponse");
	case SOAP_TYPE_PointerTo_ns7__getProject:
		return soap_out_PointerTo_ns7__getProject(soap, tag, id, (_ns7__getProject *const*)ptr, "ns7:getProject");
	case SOAP_TYPE_PointerTo_ns7__SoapRobotDhParameters:
		return soap_out_PointerTo_ns7__SoapRobotDhParameters(soap, tag, id, (_ns7__SoapRobotDhParameters *const*)ptr, "ns7:SoapRobotDhParameters");
	case SOAP_TYPE_PointerTo_ns7__getRobotDhParameters:
		return soap_out_PointerTo_ns7__getRobotDhParameters(soap, tag, id, (_ns7__getRobotDhParameters *const*)ptr, "ns7:getRobotDhParameters");
	case SOAP_TYPE_PointerTo_ns7__getAllPhysicalIosResponse:
		return soap_out_PointerTo_ns7__getAllPhysicalIosResponse(soap, tag, id, (_ns7__getAllPhysicalIosResponse *const*)ptr, "ns7:getAllPhysicalIosResponse");
	case SOAP_TYPE_PointerTo_ns7__getAllPhysicalIos:
		return soap_out_PointerTo_ns7__getAllPhysicalIos(soap, tag, id, (_ns7__getAllPhysicalIos *const*)ptr, "ns7:getAllPhysicalIos");
	case SOAP_TYPE_PointerTo_ns7__unlockAllIos:
		return soap_out_PointerTo_ns7__unlockAllIos(soap, tag, id, (_ns7__unlockAllIos *const*)ptr, "ns7:unlockAllIos");
	case SOAP_TYPE_PointerTo_ns7__SoapAllPhysicalIoResponse:
		return soap_out_PointerTo_ns7__SoapAllPhysicalIoResponse(soap, tag, id, (_ns7__SoapAllPhysicalIoResponse *const*)ptr, "ns7:SoapAllPhysicalIoResponse");
	case SOAP_TYPE_PointerTo_ns7__lockAllIos:
		return soap_out_PointerTo_ns7__lockAllIos(soap, tag, id, (_ns7__lockAllIos *const*)ptr, "ns7:lockAllIos");
	case SOAP_TYPE_PointerTo_ns7__unlockIosResponse:
		return soap_out_PointerTo_ns7__unlockIosResponse(soap, tag, id, (_ns7__unlockIosResponse *const*)ptr, "ns7:unlockIosResponse");
	case SOAP_TYPE_PointerTo_ns7__unlockIos:
		return soap_out_PointerTo_ns7__unlockIos(soap, tag, id, (_ns7__unlockIos *const*)ptr, "ns7:unlockIos");
	case SOAP_TYPE_PointerTo_ns7__lockIosResponse:
		return soap_out_PointerTo_ns7__lockIosResponse(soap, tag, id, (_ns7__lockIosResponse *const*)ptr, "ns7:lockIosResponse");
	case SOAP_TYPE_PointerTo_ns7__lockIos:
		return soap_out_PointerTo_ns7__lockIos(soap, tag, id, (_ns7__lockIos *const*)ptr, "ns7:lockIos");
	case SOAP_TYPE_PointerTo_ns7__writeIosResponse:
		return soap_out_PointerTo_ns7__writeIosResponse(soap, tag, id, (_ns7__writeIosResponse *const*)ptr, "ns7:writeIosResponse");
	case SOAP_TYPE_PointerTo_ns7__writeIos:
		return soap_out_PointerTo_ns7__writeIos(soap, tag, id, (_ns7__writeIos *const*)ptr, "ns7:writeIos");
	case SOAP_TYPE_PointerTo_ns7__readIosResponse:
		return soap_out_PointerTo_ns7__readIosResponse(soap, tag, id, (_ns7__readIosResponse *const*)ptr, "ns7:readIosResponse");
	case SOAP_TYPE_PointerTo_ns7__readIos:
		return soap_out_PointerTo_ns7__readIos(soap, tag, id, (_ns7__readIos *const*)ptr, "ns7:readIos");
	case SOAP_TYPE_PointerTo_ns7__replaceLineResponse:
		return soap_out_PointerTo_ns7__replaceLineResponse(soap, tag, id, (_ns7__replaceLineResponse *const*)ptr, "ns7:replaceLineResponse");
	case SOAP_TYPE_PointerTo_ns7__replaceLine:
		return soap_out_PointerTo_ns7__replaceLine(soap, tag, id, (_ns7__replaceLine *const*)ptr, "ns7:replaceLine");
	case SOAP_TYPE_PointerTo_ns7__setCurrentInstructionResponse:
		return soap_out_PointerTo_ns7__setCurrentInstructionResponse(soap, tag, id, (_ns7__setCurrentInstructionResponse *const*)ptr, "ns7:setCurrentInstructionResponse");
	case SOAP_TYPE_PointerTo_ns7__setCurrentInstruction:
		return soap_out_PointerTo_ns7__setCurrentInstruction(soap, tag, id, (_ns7__setCurrentInstruction *const*)ptr, "ns7:setCurrentInstruction");
	case SOAP_TYPE_PointerTo_ns7__setProjectAsModifiedResponse:
		return soap_out_PointerTo_ns7__setProjectAsModifiedResponse(soap, tag, id, (_ns7__setProjectAsModifiedResponse *const*)ptr, "ns7:setProjectAsModifiedResponse");
	case SOAP_TYPE_PointerTo_ns7__setProjectAsModified:
		return soap_out_PointerTo_ns7__setProjectAsModified(soap, tag, id, (_ns7__setProjectAsModified *const*)ptr, "ns7:setProjectAsModified");
	case SOAP_TYPE_PointerTo_ns7__execVal3Response:
		return soap_out_PointerTo_ns7__execVal3Response(soap, tag, id, (_ns7__execVal3Response *const*)ptr, "ns7:execVal3Response");
	case SOAP_TYPE_PointerTo_ns7__execVal3:
		return soap_out_PointerTo_ns7__execVal3(soap, tag, id, (_ns7__execVal3 *const*)ptr, "ns7:execVal3");
	case SOAP_TYPE_PointerTo_ns7__getWatchResponse:
		return soap_out_PointerTo_ns7__getWatchResponse(soap, tag, id, (_ns7__getWatchResponse *const*)ptr, "ns7:getWatchResponse");
	case SOAP_TYPE_PointerTo_ns7__getWatches:
		return soap_out_PointerTo_ns7__getWatches(soap, tag, id, (_ns7__getWatches *const*)ptr, "ns7:getWatches");
	case SOAP_TYPE_PointerTo_ns7__getStackFrameResponse:
		return soap_out_PointerTo_ns7__getStackFrameResponse(soap, tag, id, (_ns7__getStackFrameResponse *const*)ptr, "ns7:getStackFrameResponse");
	case SOAP_TYPE_PointerTo_ns7__getStackFrame:
		return soap_out_PointerTo_ns7__getStackFrame(soap, tag, id, (_ns7__getStackFrame *const*)ptr, "ns7:getStackFrame");
	case SOAP_TYPE_PointerTo_ns7__getCallStackResponse:
		return soap_out_PointerTo_ns7__getCallStackResponse(soap, tag, id, (_ns7__getCallStackResponse *const*)ptr, "ns7:getCallStackResponse");
	case SOAP_TYPE_PointerTo_ns7__getCallStack:
		return soap_out_PointerTo_ns7__getCallStack(soap, tag, id, (_ns7__getCallStack *const*)ptr, "ns7:getCallStack");
	case SOAP_TYPE_PointerTo_ns7__unsubscribeResponse:
		return soap_out_PointerTo_ns7__unsubscribeResponse(soap, tag, id, (_ns7__unsubscribeResponse *const*)ptr, "ns7:unsubscribeResponse");
	case SOAP_TYPE_PointerTo_ns7__unsubscribeToControllerEvents:
		return soap_out_PointerTo_ns7__unsubscribeToControllerEvents(soap, tag, id, (_ns7__unsubscribeToControllerEvents *const*)ptr, "ns7:unsubscribeToControllerEvents");
	case SOAP_TYPE_PointerTo_ns7__subscribeResponse:
		return soap_out_PointerTo_ns7__subscribeResponse(soap, tag, id, (_ns7__subscribeResponse *const*)ptr, "ns7:subscribeResponse");
	case SOAP_TYPE_PointerTo_ns7__subscribeToControllerEvents:
		return soap_out_PointerTo_ns7__subscribeToControllerEvents(soap, tag, id, (_ns7__subscribeToControllerEvents *const*)ptr, "ns7:subscribeToControllerEvents");
	case SOAP_TYPE_PointerTo_ns7__taskStepResponse:
		return soap_out_PointerTo_ns7__taskStepResponse(soap, tag, id, (_ns7__taskStepResponse *const*)ptr, "ns7:taskStepResponse");
	case SOAP_TYPE_PointerTo_ns7__taskStep:
		return soap_out_PointerTo_ns7__taskStep(soap, tag, id, (_ns7__taskStep *const*)ptr, "ns7:taskStep");
	case SOAP_TYPE_PointerTo_ns7__taskKillResponse:
		return soap_out_PointerTo_ns7__taskKillResponse(soap, tag, id, (_ns7__taskKillResponse *const*)ptr, "ns7:taskKillResponse");
	case SOAP_TYPE_PointerTo_ns7__taskKill:
		return soap_out_PointerTo_ns7__taskKill(soap, tag, id, (_ns7__taskKill *const*)ptr, "ns7:taskKill");
	case SOAP_TYPE_PointerTo_ns7__taskResumeResponse:
		return soap_out_PointerTo_ns7__taskResumeResponse(soap, tag, id, (_ns7__taskResumeResponse *const*)ptr, "ns7:taskResumeResponse");
	case SOAP_TYPE_PointerTo_ns7__taskResume:
		return soap_out_PointerTo_ns7__taskResume(soap, tag, id, (_ns7__taskResume *const*)ptr, "ns7:taskResume");
	case SOAP_TYPE_PointerTo_ns7__taskSuspendResponse:
		return soap_out_PointerTo_ns7__taskSuspendResponse(soap, tag, id, (_ns7__taskSuspendResponse *const*)ptr, "ns7:taskSuspendResponse");
	case SOAP_TYPE_PointerTo_ns7__taskSuspend:
		return soap_out_PointerTo_ns7__taskSuspend(soap, tag, id, (_ns7__taskSuspend *const*)ptr, "ns7:taskSuspend");
	case SOAP_TYPE_PointerTo_ns7__getTasksResponse:
		return soap_out_PointerTo_ns7__getTasksResponse(soap, tag, id, (_ns7__getTasksResponse *const*)ptr, "ns7:getTasksResponse");
	case SOAP_TYPE_PointerTo_ns7__getTasks:
		return soap_out_PointerTo_ns7__getTasks(soap, tag, id, (_ns7__getTasks *const*)ptr, "ns7:getTasks");
	case SOAP_TYPE_PointerTo_ns7__clearAllBreakpointsResponse:
		return soap_out_PointerTo_ns7__clearAllBreakpointsResponse(soap, tag, id, (_ns7__clearAllBreakpointsResponse *const*)ptr, "ns7:clearAllBreakpointsResponse");
	case SOAP_TYPE_PointerTo_ns7__clearAllBreakpoints:
		return soap_out_PointerTo_ns7__clearAllBreakpoints(soap, tag, id, (_ns7__clearAllBreakpoints *const*)ptr, "ns7:clearAllBreakpoints");
	case SOAP_TYPE_PointerTo_ns7__clearBreakpointsResponse:
		return soap_out_PointerTo_ns7__clearBreakpointsResponse(soap, tag, id, (_ns7__clearBreakpointsResponse *const*)ptr, "ns7:clearBreakpointsResponse");
	case SOAP_TYPE_PointerTo_ns7__clearBreakpoints:
		return soap_out_PointerTo_ns7__clearBreakpoints(soap, tag, id, (_ns7__clearBreakpoints *const*)ptr, "ns7:clearBreakpoints");
	case SOAP_TYPE_PointerTo_ns7__getBreakpointsResponse:
		return soap_out_PointerTo_ns7__getBreakpointsResponse(soap, tag, id, (_ns7__getBreakpointsResponse *const*)ptr, "ns7:getBreakpointsResponse");
	case SOAP_TYPE_PointerTo_ns7__getBreakpoints:
		return soap_out_PointerTo_ns7__getBreakpoints(soap, tag, id, (_ns7__getBreakpoints *const*)ptr, "ns7:getBreakpoints");
	case SOAP_TYPE_PointerTo_ns7__setBreakpointsResponse:
		return soap_out_PointerTo_ns7__setBreakpointsResponse(soap, tag, id, (_ns7__setBreakpointsResponse *const*)ptr, "ns7:setBreakpointsResponse");
	case SOAP_TYPE_PointerTo_ns7__setBreakpoints:
		return soap_out_PointerTo_ns7__setBreakpoints(soap, tag, id, (_ns7__setBreakpoints *const*)ptr, "ns7:setBreakpoints");
	case SOAP_TYPE_PointerTo_ns1__setRobotPosResponse:
		return soap_out_PointerTo_ns1__setRobotPosResponse(soap, tag, id, (_ns1__setRobotPosResponse *const*)ptr, "ns1:setRobotPosResponse");
	case SOAP_TYPE_PointerTo_ns1__setRobotJointPos:
		return soap_out_PointerTo_ns1__setRobotJointPos(soap, tag, id, (_ns1__setRobotJointPos *const*)ptr, "ns1:setRobotJointPos");
	case SOAP_TYPE_PointerTo_ns1__getRobotJntCartPosResponse:
		return soap_out_PointerTo_ns1__getRobotJntCartPosResponse(soap, tag, id, (_ns1__getRobotJntCartPosResponse *const*)ptr, "ns1:getRobotJntCartPosResponse");
	case SOAP_TYPE_PointerTo_ns1__getRobotJntCartPos:
		return soap_out_PointerTo_ns1__getRobotJntCartPos(soap, tag, id, (_ns1__getRobotJntCartPos *const*)ptr, "ns1:getRobotJntCartPos");
	case SOAP_TYPE_PointerTo_ns1__getRobotJointPosResponse:
		return soap_out_PointerTo_ns1__getRobotJointPosResponse(soap, tag, id, (_ns1__getRobotJointPosResponse *const*)ptr, "ns1:getRobotJointPosResponse");
	case SOAP_TYPE_PointerTo_ns1__getRobotJointPos:
		return soap_out_PointerTo_ns1__getRobotJointPos(soap, tag, id, (_ns1__getRobotJointPos *const*)ptr, "ns1:getRobotJointPos");
	case SOAP_TYPE_PointerTo_ns1__getRobotsResponse:
		return soap_out_PointerTo_ns1__getRobotsResponse(soap, tag, id, (_ns1__getRobotsResponse *const*)ptr, "ns1:getRobotsResponse");
	case SOAP_TYPE_PointerTo_ns1__getRobots:
		return soap_out_PointerTo_ns1__getRobots(soap, tag, id, (_ns1__getRobots *const*)ptr, "ns1:getRobots");
	case SOAP_TYPE_PointerTo_ns1__logoutResponse:
		return soap_out_PointerTo_ns1__logoutResponse(soap, tag, id, (_ns1__logoutResponse *const*)ptr, "ns1:logoutResponse");
	case SOAP_TYPE_PointerTo_ns1__logout:
		return soap_out_PointerTo_ns1__logout(soap, tag, id, (_ns1__logout *const*)ptr, "ns1:logout");
	case SOAP_TYPE_PointerTo_ns1__loginResponse:
		return soap_out_PointerTo_ns1__loginResponse(soap, tag, id, (_ns1__loginResponse *const*)ptr, "ns1:loginResponse");
	case SOAP_TYPE_PointerTo_ns1__login:
		return soap_out_PointerTo_ns1__login(soap, tag, id, (_ns1__login *const*)ptr, "ns1:login");
	case SOAP_TYPE_PointerTo_ns1__getCS8CompatibilityResponse:
		return soap_out_PointerTo_ns1__getCS8CompatibilityResponse(soap, tag, id, (_ns1__getCS8CompatibilityResponse *const*)ptr, "ns1:getCS8CompatibilityResponse");
	case SOAP_TYPE_PointerTo_ns1__getCS8Compatibility:
		return soap_out_PointerTo_ns1__getCS8Compatibility(soap, tag, id, (_ns1__getCS8Compatibility *const*)ptr, "ns1:getCS8Compatibility");
	case SOAP_TYPE_PointerTo_ns1__getControllerParametersResponse:
		return soap_out_PointerTo_ns1__getControllerParametersResponse(soap, tag, id, (_ns1__getControllerParametersResponse *const*)ptr, "ns1:getControllerParametersResponse");
	case SOAP_TYPE_PointerTo_ns1__getControllerParameters:
		return soap_out_PointerTo_ns1__getControllerParameters(soap, tag, id, (_ns1__getControllerParameters *const*)ptr, "ns1:getControllerParameters");
	case SOAP_TYPE_PointerTo_ns1__getCS8VersionsResponse:
		return soap_out_PointerTo_ns1__getCS8VersionsResponse(soap, tag, id, (_ns1__getCS8VersionsResponse *const*)ptr, "ns1:getCS8VersionsResponse");
	case SOAP_TYPE_PointerTo_ns1__getCS8Versions:
		return soap_out_PointerTo_ns1__getCS8Versions(soap, tag, id, (_ns1__getCS8Versions *const*)ptr, "ns1:getCS8Versions");
	case SOAP_TYPE_PointerTo_ns1__pingResponse:
		return soap_out_PointerTo_ns1__pingResponse(soap, tag, id, (_ns1__pingResponse *const*)ptr, "ns1:pingResponse");
	case SOAP_TYPE_PointerTo_ns1__ping:
		return soap_out_PointerTo_ns1__ping(soap, tag, id, (_ns1__ping *const*)ptr, "ns1:ping");
	case SOAP_TYPE_PointerTo_ns1__findServerResponse:
		return soap_out_PointerTo_ns1__findServerResponse(soap, tag, id, (_ns1__findServerResponse *const*)ptr, "ns1:findServerResponse");
	case SOAP_TYPE_PointerTo_ns1__findServer:
		return soap_out_PointerTo_ns1__findServer(soap, tag, id, (_ns1__findServer *const*)ptr, "ns1:findServer");
	case SOAP_TYPE_PointerTo_ns1__getSoapServerVersionResponse:
		return soap_out_PointerTo_ns1__getSoapServerVersionResponse(soap, tag, id, (_ns1__getSoapServerVersionResponse *const*)ptr, "ns1:getSoapServerVersionResponse");
	case SOAP_TYPE_PointerTo_ns1__getSoapServerVersion:
		return soap_out_PointerTo_ns1__getSoapServerVersion(soap, tag, id, (_ns1__getSoapServerVersion *const*)ptr, "ns1:getSoapServerVersion");
	case SOAP_TYPE_PointerTons1__ServerException:
		return soap_out_PointerTons1__ServerException(soap, tag, id, (ns1__ServerException *const*)ptr, "ns1:ServerException");
	case SOAP_TYPE_PointerTons1__SessionId:
		return soap_out_PointerTons1__SessionId(soap, tag, id, (int *const*)ptr, "ns1:SessionId");
	case SOAP_TYPE_PointerTons2__JointRange:
		return soap_out_PointerTons2__JointRange(soap, tag, id, (ns2__JointRange *const*)ptr, "ns2:JointRange");
	case SOAP_TYPE_PointerTons2__Records:
		return soap_out_PointerTons2__Records(soap, tag, id, (ns2__Records *const*)ptr, "ns2:Records");
	case SOAP_TYPE_PointerTons2__Data:
		return soap_out_PointerTons2__Data(soap, tag, id, (ns2__Data *const*)ptr, "ns2:Data");
	case SOAP_TYPE_PointerTons2__VALApplications:
		return soap_out_PointerTons2__VALApplications(soap, tag, id, (ns2__VALApplications *const*)ptr, "ns2:VALApplications");
	case SOAP_TYPE_PointerTons3__Include:
		return soap_out_PointerTons3__Include(soap, tag, id, (ns3__Include *const*)ptr, "ns3:Include");
	case SOAP_TYPE_PointerTons7__SoapDhParametersArray:
		return soap_out_PointerTons7__SoapDhParametersArray(soap, tag, id, (ns7__SoapDhParametersArray *const*)ptr, "ns7:SoapDhParametersArray");
	case SOAP_TYPE_PointerTons7__SoapPhysicalIoUnlockResponses:
		return soap_out_PointerTons7__SoapPhysicalIoUnlockResponses(soap, tag, id, (ns7__SoapPhysicalIoUnlockResponses *const*)ptr, "ns7:SoapPhysicalIoUnlockResponses");
	case SOAP_TYPE_PointerTons7__SoapPhysicalIoResponses:
		return soap_out_PointerTons7__SoapPhysicalIoResponses(soap, tag, id, (ns7__SoapPhysicalIoResponses *const*)ptr, "ns7:SoapPhysicalIoResponses");
	case SOAP_TYPE_PointerTons7__SoapPhysicalIoValues:
		return soap_out_PointerTons7__SoapPhysicalIoValues(soap, tag, id, (ns7__SoapPhysicalIoValues *const*)ptr, "ns7:SoapPhysicalIoValues");
	case SOAP_TYPE_PointerTons7__SoapPhysicalIosStates:
		return soap_out_PointerTons7__SoapPhysicalIosStates(soap, tag, id, (ns7__SoapPhysicalIosStates *const*)ptr, "ns7:SoapPhysicalIosStates");
	case SOAP_TYPE_PointerTons7__SoapPhysicalIoLinks:
		return soap_out_PointerTons7__SoapPhysicalIoLinks(soap, tag, id, (ns7__SoapPhysicalIoLinks *const*)ptr, "ns7:SoapPhysicalIoLinks");
	case SOAP_TYPE_PointerTons7__SoapWatches:
		return soap_out_PointerTons7__SoapWatches(soap, tag, id, (ns7__SoapWatches *const*)ptr, "ns7:SoapWatches");
	case SOAP_TYPE_PointerTons7__MimeData:
		return soap_out_PointerTons7__MimeData(soap, tag, id, (ns7__MimeData *const*)ptr, "ns7:MimeData");
	case SOAP_TYPE_PointerTons7__SoapCallStack:
		return soap_out_PointerTons7__SoapCallStack(soap, tag, id, (ns7__SoapCallStack *const*)ptr, "ns7:SoapCallStack");
	case SOAP_TYPE_PointerTons7__SoapTasks:
		return soap_out_PointerTons7__SoapTasks(soap, tag, id, (ns7__SoapTasks *const*)ptr, "ns7:SoapTasks");
	case SOAP_TYPE_PointerTons7__BreakpointsResponses:
		return soap_out_PointerTons7__BreakpointsResponses(soap, tag, id, (ns7__BreakpointsResponses *const*)ptr, "ns7:BreakpointsResponses");
	case SOAP_TYPE_PointerTons7__SoapBreakpoints:
		return soap_out_PointerTons7__SoapBreakpoints(soap, tag, id, (ns7__SoapBreakpoints *const*)ptr, "ns7:SoapBreakpoints");
	case SOAP_TYPE_PointerTons7__SoapPhysicalIoAttrib:
		return soap_out_PointerTons7__SoapPhysicalIoAttrib(soap, tag, id, (ns7__SoapPhysicalIoAttrib *const*)ptr, "ns7:SoapPhysicalIoAttrib");
	case SOAP_TYPE_PointerTons7__SoapPhysicalAioAttrib:
		return soap_out_PointerTons7__SoapPhysicalAioAttrib(soap, tag, id, (ns7__SoapPhysicalAioAttrib *const*)ptr, "ns7:SoapPhysicalAioAttrib");
	case SOAP_TYPE_PointerTons7__SoapPhysicalDioAttrib:
		return soap_out_PointerTons7__SoapPhysicalDioAttrib(soap, tag, id, (ns7__SoapPhysicalDioAttrib *const*)ptr, "ns7:SoapPhysicalDioAttrib");
	case SOAP_TYPE_PointerTons7__SoapInstruction:
		return soap_out_PointerTons7__SoapInstruction(soap, tag, id, (ns7__SoapInstruction *const*)ptr, "ns7:SoapInstruction");
	case SOAP_TYPE_PointerTons7__SoapProgramLine:
		return soap_out_PointerTons7__SoapProgramLine(soap, tag, id, (ns7__SoapProgramLine *const*)ptr, "ns7:SoapProgramLine");
	case SOAP_TYPE_PointerTons7__SoapDhParameters:
		return soap_out_PointerTons7__SoapDhParameters(soap, tag, id, (ns7__SoapDhParameters *const*)ptr, "ns7:SoapDhParameters");
	case SOAP_TYPE_PointerTons7__SoapPhysicalIoUnlockResponse:
		return soap_out_PointerTons7__SoapPhysicalIoUnlockResponse(soap, tag, id, (ns7__SoapPhysicalIoUnlockResponse *const*)ptr, "ns7:SoapPhysicalIoUnlockResponse");
	case SOAP_TYPE_PointerTons7__SoapPhysicalIoResponse:
		return soap_out_PointerTons7__SoapPhysicalIoResponse(soap, tag, id, (ns7__SoapPhysicalIoResponse *const*)ptr, "ns7:SoapPhysicalIoResponse");
	case SOAP_TYPE_PointerTons7__SoapPhysicalIoState:
		return soap_out_PointerTons7__SoapPhysicalIoState(soap, tag, id, (ns7__SoapPhysicalIoState *const*)ptr, "ns7:SoapPhysicalIoState");
	case SOAP_TYPE_PointerTons7__SoapData:
		return soap_out_PointerTons7__SoapData(soap, tag, id, (ns7__SoapData *const*)ptr, "ns7:SoapData");
	case SOAP_TYPE_PointerTons7__SoapStackFrameAbstract:
		return soap_out_PointerTons7__SoapStackFrameAbstract(soap, tag, id, (ns7__SoapStackFrameAbstract *const*)ptr, "ns7:SoapStackFrameAbstract");
	case SOAP_TYPE_PointerTons7__SoapTask:
		return soap_out_PointerTons7__SoapTask(soap, tag, id, (ns7__SoapTask *const*)ptr, "ns7:SoapTask");
	case SOAP_TYPE_PointerTons7__BreakpointsResponse:
		return soap_out_PointerTons7__BreakpointsResponse(soap, tag, id, (ns7__BreakpointsResponse *const*)ptr, "ns7:BreakpointsResponse");
	case SOAP_TYPE_PointerTons7__SoapBreakpoint:
		return soap_out_PointerTons7__SoapBreakpoint(soap, tag, id, (ns7__SoapBreakpoint *const*)ptr, "ns7:SoapBreakpoint");
	case SOAP_TYPE_PointerTons2__VALApplication:
		return soap_out_PointerTons2__VALApplication(soap, tag, id, (ns2__VALApplication *const*)ptr, "ns2:VALApplication");
	case SOAP_TYPE_PointerTons1__CartesianPos:
		return soap_out_PointerTons1__CartesianPos(soap, tag, id, (ns1__CartesianPos *const*)ptr, "ns1:CartesianPos");
	case SOAP_TYPE_PointerTons1__JointPos:
		return soap_out_PointerTons1__JointPos(soap, tag, id, (ns1__JointPos *const*)ptr, "ns1:JointPos");
	case SOAP_TYPE_PointerTons1__Robots:
		return soap_out_PointerTons1__Robots(soap, tag, id, (ns1__Robots *const*)ptr, "ns1:Robots");
	case SOAP_TYPE_PointerTons1__Parameters:
		return soap_out_PointerTons1__Parameters(soap, tag, id, (ns1__Parameters *const*)ptr, "ns1:Parameters");
	case SOAP_TYPE_PointerTons1__Versions:
		return soap_out_PointerTons1__Versions(soap, tag, id, (ns1__Versions *const*)ptr, "ns1:Versions");
	case SOAP_TYPE_PointerTons1__SoapServerVersion:
		return soap_out_PointerTons1__SoapServerVersion(soap, tag, id, (ns1__SoapServerVersion *const*)ptr, "ns1:SoapServerVersion");
	case SOAP_TYPE_PointerTons1__Robot:
		return soap_out_PointerTons1__Robot(soap, tag, id, (ns1__Robot *const*)ptr, "ns1:Robot");
	case SOAP_TYPE_PointerTons1__Version:
		return soap_out_PointerTons1__Version(soap, tag, id, (ns1__Version *const*)ptr, "ns1:Version");
	case SOAP_TYPE_PointerTons1__Parameter:
		return soap_out_PointerTons1__Parameter(soap, tag, id, (ns1__Parameter *const*)ptr, "ns1:Parameter");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_out_PointerTounsignedByte(soap, tag, id, (unsigned char *const*)ptr, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_ns4__hexBinary:
		((ns4__hexBinary *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__base64Binary:
		((ns4__base64Binary *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__getJointRangeResponse:
		((_ns2__getJointRangeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__getJointRange:
		((_ns2__getJointRange *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__getRecordResponse:
		((_ns2__getRecordResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__getRecord:
		((_ns2__getRecord *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__getRecordsResponse:
		((_ns2__getRecordsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__getRecords:
		((_ns2__getRecords *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__getApplicationDatasResponse:
		((_ns2__getApplicationDatasResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__getApplicationDatas:
		((_ns2__getApplicationDatas *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__getApplicationsResponse:
		((_ns2__getApplicationsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__getApplications:
		((_ns2__getApplications *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__JointRange:
		((ns2__JointRange *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__Records:
		((ns2__Records *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__Data:
		((ns2__Data *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__VALApplications:
		((ns2__VALApplications *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__VALApplication:
		((ns2__VALApplication *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__Include:
		((ns3__Include *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__getProjectResponse:
		((_ns7__getProjectResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__getProject:
		((_ns7__getProject *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__SoapRobotDhParameters:
		((_ns7__SoapRobotDhParameters *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__getRobotDhParameters:
		((_ns7__getRobotDhParameters *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__getAllPhysicalIosResponse:
		((_ns7__getAllPhysicalIosResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__getAllPhysicalIos:
		((_ns7__getAllPhysicalIos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__unlockAllIos:
		((_ns7__unlockAllIos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__SoapAllPhysicalIoResponse:
		((_ns7__SoapAllPhysicalIoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__lockAllIos:
		((_ns7__lockAllIos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__unlockIosResponse:
		((_ns7__unlockIosResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__unlockIos:
		((_ns7__unlockIos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__lockIosResponse:
		((_ns7__lockIosResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__lockIos:
		((_ns7__lockIos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__writeIosResponse:
		((_ns7__writeIosResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__writeIos:
		((_ns7__writeIos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__readIosResponse:
		((_ns7__readIosResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__readIos:
		((_ns7__readIos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__replaceLineResponse:
		((_ns7__replaceLineResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__replaceLine:
		((_ns7__replaceLine *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__setCurrentInstructionResponse:
		((_ns7__setCurrentInstructionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__setCurrentInstruction:
		((_ns7__setCurrentInstruction *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__setProjectAsModifiedResponse:
		((_ns7__setProjectAsModifiedResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__setProjectAsModified:
		((_ns7__setProjectAsModified *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__execVal3Response:
		((_ns7__execVal3Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__execVal3:
		((_ns7__execVal3 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__getWatchResponse:
		((_ns7__getWatchResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__getWatches:
		((_ns7__getWatches *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__getStackFrameResponse:
		((_ns7__getStackFrameResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__getStackFrame:
		((_ns7__getStackFrame *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__getCallStackResponse:
		((_ns7__getCallStackResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__getCallStack:
		((_ns7__getCallStack *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__unsubscribeResponse:
		((_ns7__unsubscribeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__unsubscribeToControllerEvents:
		((_ns7__unsubscribeToControllerEvents *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__subscribeResponse:
		((_ns7__subscribeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__subscribeToControllerEvents:
		((_ns7__subscribeToControllerEvents *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__taskStepResponse:
		((_ns7__taskStepResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__taskStep:
		((_ns7__taskStep *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__taskKillResponse:
		((_ns7__taskKillResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__taskKill:
		((_ns7__taskKill *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__taskResumeResponse:
		((_ns7__taskResumeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__taskResume:
		((_ns7__taskResume *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__taskSuspendResponse:
		((_ns7__taskSuspendResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__taskSuspend:
		((_ns7__taskSuspend *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__getTasksResponse:
		((_ns7__getTasksResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__getTasks:
		((_ns7__getTasks *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__clearAllBreakpointsResponse:
		((_ns7__clearAllBreakpointsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__clearAllBreakpoints:
		((_ns7__clearAllBreakpoints *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__clearBreakpointsResponse:
		((_ns7__clearBreakpointsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__clearBreakpoints:
		((_ns7__clearBreakpoints *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__getBreakpointsResponse:
		((_ns7__getBreakpointsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__getBreakpoints:
		((_ns7__getBreakpoints *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__setBreakpointsResponse:
		((_ns7__setBreakpointsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__setBreakpoints:
		((_ns7__setBreakpoints *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__SoapDhParametersArray:
		((ns7__SoapDhParametersArray *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__SoapDhParameters:
		((ns7__SoapDhParameters *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__SoapPhysicalIoUnlockResponses:
		((ns7__SoapPhysicalIoUnlockResponses *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__SoapPhysicalIoUnlockResponse:
		((ns7__SoapPhysicalIoUnlockResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__SoapPhysicalIoResponses:
		((ns7__SoapPhysicalIoResponses *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__SoapPhysicalIoResponse:
		((ns7__SoapPhysicalIoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__SoapPhysicalIosStates:
		((ns7__SoapPhysicalIosStates *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__SoapPhysicalIoValues:
		((ns7__SoapPhysicalIoValues *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__SoapPhysicalIoState:
		((ns7__SoapPhysicalIoState *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__SoapPhysicalIoAttrib:
		((ns7__SoapPhysicalIoAttrib *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__SoapPhysicalAioAttrib:
		((ns7__SoapPhysicalAioAttrib *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__SoapPhysicalDioAttrib:
		((ns7__SoapPhysicalDioAttrib *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__SoapPhysicalIoLinks:
		((ns7__SoapPhysicalIoLinks *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__SoapWatches:
		((ns7__SoapWatches *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__SoapData:
		((ns7__SoapData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__SoapCallStack:
		((ns7__SoapCallStack *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__SoapStackFrameAbstract:
		((ns7__SoapStackFrameAbstract *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__SoapInstruction:
		((ns7__SoapInstruction *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__SoapTasks:
		((ns7__SoapTasks *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__SoapTask:
		((ns7__SoapTask *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__MimeData:
		((ns7__MimeData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__BreakpointsResponses:
		((ns7__BreakpointsResponses *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__BreakpointsResponse:
		((ns7__BreakpointsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__SoapBreakpoints:
		((ns7__SoapBreakpoints *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__SoapBreakpoint:
		((ns7__SoapBreakpoint *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__SoapProgramLine:
		((ns7__SoapProgramLine *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__Records:
		((ns7__Records *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__VALApplications:
		((ns7__VALApplications *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__Robots:
		((ns7__Robots *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__Versions:
		((ns7__Versions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__Parameters:
		((ns7__Parameters *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__JointPos:
		((ns7__JointPos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__SoapDhParametersArray:
		((ns5__SoapDhParametersArray *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__SoapPhysicalIoUnlockResponses:
		((ns5__SoapPhysicalIoUnlockResponses *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__SoapPhysicalIoResponses:
		((ns5__SoapPhysicalIoResponses *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__SoapPhysicalIosStates:
		((ns5__SoapPhysicalIosStates *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__SoapPhysicalIoValues:
		((ns5__SoapPhysicalIoValues *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__SoapPhysicalIoLinks:
		((ns5__SoapPhysicalIoLinks *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__SoapWatches:
		((ns5__SoapWatches *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__SoapCallStack:
		((ns5__SoapCallStack *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__SoapTasks:
		((ns5__SoapTasks *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__BreakpointsResponses:
		((ns5__BreakpointsResponses *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__SoapBreakpoints:
		((ns5__SoapBreakpoints *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__Records:
		((ns5__Records *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__VALApplications:
		((ns5__VALApplications *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__Robots:
		((ns5__Robots *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__Versions:
		((ns5__Versions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__Parameters:
		((ns5__Parameters *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__JointPos:
		((ns5__JointPos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__setRobotPosResponse:
		((_ns1__setRobotPosResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__setRobotJointPos:
		((_ns1__setRobotJointPos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getRobotJntCartPosResponse:
		((_ns1__getRobotJntCartPosResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getRobotJntCartPos:
		((_ns1__getRobotJntCartPos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getRobotJointPosResponse:
		((_ns1__getRobotJointPosResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getRobotJointPos:
		((_ns1__getRobotJointPos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getRobotsResponse:
		((_ns1__getRobotsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getRobots:
		((_ns1__getRobots *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__logoutResponse:
		((_ns1__logoutResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__logout:
		((_ns1__logout *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__loginResponse:
		((_ns1__loginResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__login:
		((_ns1__login *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getCS8CompatibilityResponse:
		((_ns1__getCS8CompatibilityResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getCS8Compatibility:
		((_ns1__getCS8Compatibility *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getControllerParametersResponse:
		((_ns1__getControllerParametersResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getControllerParameters:
		((_ns1__getControllerParameters *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getCS8VersionsResponse:
		((_ns1__getCS8VersionsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getCS8Versions:
		((_ns1__getCS8Versions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__pingResponse:
		((_ns1__pingResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ping:
		((_ns1__ping *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__findServerResponse:
		((_ns1__findServerResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__findServer:
		((_ns1__findServer *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getSoapServerVersionResponse:
		((_ns1__getSoapServerVersionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getSoapServerVersion:
		((_ns1__getSoapServerVersion *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Robots:
		((ns1__Robots *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SoapServerVersion:
		((ns1__SoapServerVersion *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Versions:
		((ns1__Versions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Parameters:
		((ns1__Parameters *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Parameter:
		((ns1__Parameter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Version:
		((ns1__Version *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Robot:
		((ns1__Robot *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CartesianPos:
		((ns1__CartesianPos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__JointPos:
		((ns1__JointPos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ServerException:
		((ns1__ServerException *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__hexBinary:
		((xsd__hexBinary *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__base64Binary:
		((xsd__base64Binary *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__anyURI:
		soap_serialize_xsd__anyURI(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE___ns7__getProject:
		soap_serialize___ns7__getProject(soap, (const struct __ns7__getProject *)ptr);
		break;
	case SOAP_TYPE___ns7__getRobotDhParameters:
		soap_serialize___ns7__getRobotDhParameters(soap, (const struct __ns7__getRobotDhParameters *)ptr);
		break;
	case SOAP_TYPE___ns7__getAllPhysicalIos:
		soap_serialize___ns7__getAllPhysicalIos(soap, (const struct __ns7__getAllPhysicalIos *)ptr);
		break;
	case SOAP_TYPE___ns7__unlockAllIos:
		soap_serialize___ns7__unlockAllIos(soap, (const struct __ns7__unlockAllIos *)ptr);
		break;
	case SOAP_TYPE___ns7__lockAllIos:
		soap_serialize___ns7__lockAllIos(soap, (const struct __ns7__lockAllIos *)ptr);
		break;
	case SOAP_TYPE___ns7__unlockIos:
		soap_serialize___ns7__unlockIos(soap, (const struct __ns7__unlockIos *)ptr);
		break;
	case SOAP_TYPE___ns7__lockIos:
		soap_serialize___ns7__lockIos(soap, (const struct __ns7__lockIos *)ptr);
		break;
	case SOAP_TYPE___ns7__writeIos:
		soap_serialize___ns7__writeIos(soap, (const struct __ns7__writeIos *)ptr);
		break;
	case SOAP_TYPE___ns7__readIos:
		soap_serialize___ns7__readIos(soap, (const struct __ns7__readIos *)ptr);
		break;
	case SOAP_TYPE___ns7__replaceLine:
		soap_serialize___ns7__replaceLine(soap, (const struct __ns7__replaceLine *)ptr);
		break;
	case SOAP_TYPE___ns7__setCurrentInstruction:
		soap_serialize___ns7__setCurrentInstruction(soap, (const struct __ns7__setCurrentInstruction *)ptr);
		break;
	case SOAP_TYPE___ns7__setProjectAsModified:
		soap_serialize___ns7__setProjectAsModified(soap, (const struct __ns7__setProjectAsModified *)ptr);
		break;
	case SOAP_TYPE___ns7__execVal3:
		soap_serialize___ns7__execVal3(soap, (const struct __ns7__execVal3 *)ptr);
		break;
	case SOAP_TYPE___ns7__getWatches:
		soap_serialize___ns7__getWatches(soap, (const struct __ns7__getWatches *)ptr);
		break;
	case SOAP_TYPE___ns7__getStackFrame:
		soap_serialize___ns7__getStackFrame(soap, (const struct __ns7__getStackFrame *)ptr);
		break;
	case SOAP_TYPE___ns7__getCallStack:
		soap_serialize___ns7__getCallStack(soap, (const struct __ns7__getCallStack *)ptr);
		break;
	case SOAP_TYPE___ns7__unsubscribeToControllerEvents:
		soap_serialize___ns7__unsubscribeToControllerEvents(soap, (const struct __ns7__unsubscribeToControllerEvents *)ptr);
		break;
	case SOAP_TYPE___ns7__subscribeToControllerEvents:
		soap_serialize___ns7__subscribeToControllerEvents(soap, (const struct __ns7__subscribeToControllerEvents *)ptr);
		break;
	case SOAP_TYPE___ns7__taskStep:
		soap_serialize___ns7__taskStep(soap, (const struct __ns7__taskStep *)ptr);
		break;
	case SOAP_TYPE___ns7__taskKill:
		soap_serialize___ns7__taskKill(soap, (const struct __ns7__taskKill *)ptr);
		break;
	case SOAP_TYPE___ns7__taskResume:
		soap_serialize___ns7__taskResume(soap, (const struct __ns7__taskResume *)ptr);
		break;
	case SOAP_TYPE___ns7__taskSuspend:
		soap_serialize___ns7__taskSuspend(soap, (const struct __ns7__taskSuspend *)ptr);
		break;
	case SOAP_TYPE___ns7__getTasks:
		soap_serialize___ns7__getTasks(soap, (const struct __ns7__getTasks *)ptr);
		break;
	case SOAP_TYPE___ns7__clearAllBreakpoints:
		soap_serialize___ns7__clearAllBreakpoints(soap, (const struct __ns7__clearAllBreakpoints *)ptr);
		break;
	case SOAP_TYPE___ns7__clearBreakpoints:
		soap_serialize___ns7__clearBreakpoints(soap, (const struct __ns7__clearBreakpoints *)ptr);
		break;
	case SOAP_TYPE___ns7__getBreakpoints:
		soap_serialize___ns7__getBreakpoints(soap, (const struct __ns7__getBreakpoints *)ptr);
		break;
	case SOAP_TYPE___ns7__setBreakpoints:
		soap_serialize___ns7__setBreakpoints(soap, (const struct __ns7__setBreakpoints *)ptr);
		break;
	case SOAP_TYPE___ns1__setRobotJointPos:
		soap_serialize___ns1__setRobotJointPos(soap, (const struct __ns1__setRobotJointPos *)ptr);
		break;
	case SOAP_TYPE___ns1__getRobotJntCartPos:
		soap_serialize___ns1__getRobotJntCartPos(soap, (const struct __ns1__getRobotJntCartPos *)ptr);
		break;
	case SOAP_TYPE___ns1__getRobotJointPos:
		soap_serialize___ns1__getRobotJointPos(soap, (const struct __ns1__getRobotJointPos *)ptr);
		break;
	case SOAP_TYPE___ns1__getRobots:
		soap_serialize___ns1__getRobots(soap, (const struct __ns1__getRobots *)ptr);
		break;
	case SOAP_TYPE___ns1__logout:
		soap_serialize___ns1__logout(soap, (const struct __ns1__logout *)ptr);
		break;
	case SOAP_TYPE___ns1__login:
		soap_serialize___ns1__login(soap, (const struct __ns1__login *)ptr);
		break;
	case SOAP_TYPE___ns1__getCS8Compatibility:
		soap_serialize___ns1__getCS8Compatibility(soap, (const struct __ns1__getCS8Compatibility *)ptr);
		break;
	case SOAP_TYPE___ns1__getControllerParameters:
		soap_serialize___ns1__getControllerParameters(soap, (const struct __ns1__getControllerParameters *)ptr);
		break;
	case SOAP_TYPE___ns1__getCS8Versions:
		soap_serialize___ns1__getCS8Versions(soap, (const struct __ns1__getCS8Versions *)ptr);
		break;
	case SOAP_TYPE___ns1__ping:
		soap_serialize___ns1__ping(soap, (const struct __ns1__ping *)ptr);
		break;
	case SOAP_TYPE___ns1__findServer:
		soap_serialize___ns1__findServer(soap, (const struct __ns1__findServer *)ptr);
		break;
	case SOAP_TYPE___ns1__getSoapServerVersion:
		soap_serialize___ns1__getSoapServerVersion(soap, (const struct __ns1__getSoapServerVersion *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__getProjectResponse:
		soap_serialize_PointerTo_ns7__getProjectResponse(soap, (_ns7__getProjectResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__getProject:
		soap_serialize_PointerTo_ns7__getProject(soap, (_ns7__getProject *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__SoapRobotDhParameters:
		soap_serialize_PointerTo_ns7__SoapRobotDhParameters(soap, (_ns7__SoapRobotDhParameters *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__getRobotDhParameters:
		soap_serialize_PointerTo_ns7__getRobotDhParameters(soap, (_ns7__getRobotDhParameters *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__getAllPhysicalIosResponse:
		soap_serialize_PointerTo_ns7__getAllPhysicalIosResponse(soap, (_ns7__getAllPhysicalIosResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__getAllPhysicalIos:
		soap_serialize_PointerTo_ns7__getAllPhysicalIos(soap, (_ns7__getAllPhysicalIos *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__unlockAllIos:
		soap_serialize_PointerTo_ns7__unlockAllIos(soap, (_ns7__unlockAllIos *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__SoapAllPhysicalIoResponse:
		soap_serialize_PointerTo_ns7__SoapAllPhysicalIoResponse(soap, (_ns7__SoapAllPhysicalIoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__lockAllIos:
		soap_serialize_PointerTo_ns7__lockAllIos(soap, (_ns7__lockAllIos *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__unlockIosResponse:
		soap_serialize_PointerTo_ns7__unlockIosResponse(soap, (_ns7__unlockIosResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__unlockIos:
		soap_serialize_PointerTo_ns7__unlockIos(soap, (_ns7__unlockIos *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__lockIosResponse:
		soap_serialize_PointerTo_ns7__lockIosResponse(soap, (_ns7__lockIosResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__lockIos:
		soap_serialize_PointerTo_ns7__lockIos(soap, (_ns7__lockIos *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__writeIosResponse:
		soap_serialize_PointerTo_ns7__writeIosResponse(soap, (_ns7__writeIosResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__writeIos:
		soap_serialize_PointerTo_ns7__writeIos(soap, (_ns7__writeIos *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__readIosResponse:
		soap_serialize_PointerTo_ns7__readIosResponse(soap, (_ns7__readIosResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__readIos:
		soap_serialize_PointerTo_ns7__readIos(soap, (_ns7__readIos *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__replaceLineResponse:
		soap_serialize_PointerTo_ns7__replaceLineResponse(soap, (_ns7__replaceLineResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__replaceLine:
		soap_serialize_PointerTo_ns7__replaceLine(soap, (_ns7__replaceLine *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__setCurrentInstructionResponse:
		soap_serialize_PointerTo_ns7__setCurrentInstructionResponse(soap, (_ns7__setCurrentInstructionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__setCurrentInstruction:
		soap_serialize_PointerTo_ns7__setCurrentInstruction(soap, (_ns7__setCurrentInstruction *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__setProjectAsModifiedResponse:
		soap_serialize_PointerTo_ns7__setProjectAsModifiedResponse(soap, (_ns7__setProjectAsModifiedResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__setProjectAsModified:
		soap_serialize_PointerTo_ns7__setProjectAsModified(soap, (_ns7__setProjectAsModified *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__execVal3Response:
		soap_serialize_PointerTo_ns7__execVal3Response(soap, (_ns7__execVal3Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__execVal3:
		soap_serialize_PointerTo_ns7__execVal3(soap, (_ns7__execVal3 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__getWatchResponse:
		soap_serialize_PointerTo_ns7__getWatchResponse(soap, (_ns7__getWatchResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__getWatches:
		soap_serialize_PointerTo_ns7__getWatches(soap, (_ns7__getWatches *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__getStackFrameResponse:
		soap_serialize_PointerTo_ns7__getStackFrameResponse(soap, (_ns7__getStackFrameResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__getStackFrame:
		soap_serialize_PointerTo_ns7__getStackFrame(soap, (_ns7__getStackFrame *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__getCallStackResponse:
		soap_serialize_PointerTo_ns7__getCallStackResponse(soap, (_ns7__getCallStackResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__getCallStack:
		soap_serialize_PointerTo_ns7__getCallStack(soap, (_ns7__getCallStack *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__unsubscribeResponse:
		soap_serialize_PointerTo_ns7__unsubscribeResponse(soap, (_ns7__unsubscribeResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__unsubscribeToControllerEvents:
		soap_serialize_PointerTo_ns7__unsubscribeToControllerEvents(soap, (_ns7__unsubscribeToControllerEvents *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__subscribeResponse:
		soap_serialize_PointerTo_ns7__subscribeResponse(soap, (_ns7__subscribeResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__subscribeToControllerEvents:
		soap_serialize_PointerTo_ns7__subscribeToControllerEvents(soap, (_ns7__subscribeToControllerEvents *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__taskStepResponse:
		soap_serialize_PointerTo_ns7__taskStepResponse(soap, (_ns7__taskStepResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__taskStep:
		soap_serialize_PointerTo_ns7__taskStep(soap, (_ns7__taskStep *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__taskKillResponse:
		soap_serialize_PointerTo_ns7__taskKillResponse(soap, (_ns7__taskKillResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__taskKill:
		soap_serialize_PointerTo_ns7__taskKill(soap, (_ns7__taskKill *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__taskResumeResponse:
		soap_serialize_PointerTo_ns7__taskResumeResponse(soap, (_ns7__taskResumeResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__taskResume:
		soap_serialize_PointerTo_ns7__taskResume(soap, (_ns7__taskResume *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__taskSuspendResponse:
		soap_serialize_PointerTo_ns7__taskSuspendResponse(soap, (_ns7__taskSuspendResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__taskSuspend:
		soap_serialize_PointerTo_ns7__taskSuspend(soap, (_ns7__taskSuspend *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__getTasksResponse:
		soap_serialize_PointerTo_ns7__getTasksResponse(soap, (_ns7__getTasksResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__getTasks:
		soap_serialize_PointerTo_ns7__getTasks(soap, (_ns7__getTasks *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__clearAllBreakpointsResponse:
		soap_serialize_PointerTo_ns7__clearAllBreakpointsResponse(soap, (_ns7__clearAllBreakpointsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__clearAllBreakpoints:
		soap_serialize_PointerTo_ns7__clearAllBreakpoints(soap, (_ns7__clearAllBreakpoints *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__clearBreakpointsResponse:
		soap_serialize_PointerTo_ns7__clearBreakpointsResponse(soap, (_ns7__clearBreakpointsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__clearBreakpoints:
		soap_serialize_PointerTo_ns7__clearBreakpoints(soap, (_ns7__clearBreakpoints *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__getBreakpointsResponse:
		soap_serialize_PointerTo_ns7__getBreakpointsResponse(soap, (_ns7__getBreakpointsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__getBreakpoints:
		soap_serialize_PointerTo_ns7__getBreakpoints(soap, (_ns7__getBreakpoints *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__setBreakpointsResponse:
		soap_serialize_PointerTo_ns7__setBreakpointsResponse(soap, (_ns7__setBreakpointsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__setBreakpoints:
		soap_serialize_PointerTo_ns7__setBreakpoints(soap, (_ns7__setBreakpoints *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setRobotPosResponse:
		soap_serialize_PointerTo_ns1__setRobotPosResponse(soap, (_ns1__setRobotPosResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setRobotJointPos:
		soap_serialize_PointerTo_ns1__setRobotJointPos(soap, (_ns1__setRobotJointPos *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getRobotJntCartPosResponse:
		soap_serialize_PointerTo_ns1__getRobotJntCartPosResponse(soap, (_ns1__getRobotJntCartPosResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getRobotJntCartPos:
		soap_serialize_PointerTo_ns1__getRobotJntCartPos(soap, (_ns1__getRobotJntCartPos *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getRobotJointPosResponse:
		soap_serialize_PointerTo_ns1__getRobotJointPosResponse(soap, (_ns1__getRobotJointPosResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getRobotJointPos:
		soap_serialize_PointerTo_ns1__getRobotJointPos(soap, (_ns1__getRobotJointPos *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getRobotsResponse:
		soap_serialize_PointerTo_ns1__getRobotsResponse(soap, (_ns1__getRobotsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getRobots:
		soap_serialize_PointerTo_ns1__getRobots(soap, (_ns1__getRobots *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__logoutResponse:
		soap_serialize_PointerTo_ns1__logoutResponse(soap, (_ns1__logoutResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__logout:
		soap_serialize_PointerTo_ns1__logout(soap, (_ns1__logout *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__loginResponse:
		soap_serialize_PointerTo_ns1__loginResponse(soap, (_ns1__loginResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__login:
		soap_serialize_PointerTo_ns1__login(soap, (_ns1__login *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getCS8CompatibilityResponse:
		soap_serialize_PointerTo_ns1__getCS8CompatibilityResponse(soap, (_ns1__getCS8CompatibilityResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getCS8Compatibility:
		soap_serialize_PointerTo_ns1__getCS8Compatibility(soap, (_ns1__getCS8Compatibility *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getControllerParametersResponse:
		soap_serialize_PointerTo_ns1__getControllerParametersResponse(soap, (_ns1__getControllerParametersResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getControllerParameters:
		soap_serialize_PointerTo_ns1__getControllerParameters(soap, (_ns1__getControllerParameters *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getCS8VersionsResponse:
		soap_serialize_PointerTo_ns1__getCS8VersionsResponse(soap, (_ns1__getCS8VersionsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getCS8Versions:
		soap_serialize_PointerTo_ns1__getCS8Versions(soap, (_ns1__getCS8Versions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__pingResponse:
		soap_serialize_PointerTo_ns1__pingResponse(soap, (_ns1__pingResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ping:
		soap_serialize_PointerTo_ns1__ping(soap, (_ns1__ping *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__findServerResponse:
		soap_serialize_PointerTo_ns1__findServerResponse(soap, (_ns1__findServerResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__findServer:
		soap_serialize_PointerTo_ns1__findServer(soap, (_ns1__findServer *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getSoapServerVersionResponse:
		soap_serialize_PointerTo_ns1__getSoapServerVersionResponse(soap, (_ns1__getSoapServerVersionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getSoapServerVersion:
		soap_serialize_PointerTo_ns1__getSoapServerVersion(soap, (_ns1__getSoapServerVersion *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ServerException:
		soap_serialize_PointerTons1__ServerException(soap, (ns1__ServerException *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SessionId:
		soap_serialize_PointerTons1__SessionId(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__JointRange:
		soap_serialize_PointerTons2__JointRange(soap, (ns2__JointRange *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Records:
		soap_serialize_PointerTons2__Records(soap, (ns2__Records *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Data:
		soap_serialize_PointerTons2__Data(soap, (ns2__Data *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__VALApplications:
		soap_serialize_PointerTons2__VALApplications(soap, (ns2__VALApplications *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__Include:
		soap_serialize_PointerTons3__Include(soap, (ns3__Include *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons7__SoapDhParametersArray:
		soap_serialize_PointerTons7__SoapDhParametersArray(soap, (ns7__SoapDhParametersArray *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons7__SoapPhysicalIoUnlockResponses:
		soap_serialize_PointerTons7__SoapPhysicalIoUnlockResponses(soap, (ns7__SoapPhysicalIoUnlockResponses *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons7__SoapPhysicalIoResponses:
		soap_serialize_PointerTons7__SoapPhysicalIoResponses(soap, (ns7__SoapPhysicalIoResponses *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons7__SoapPhysicalIoValues:
		soap_serialize_PointerTons7__SoapPhysicalIoValues(soap, (ns7__SoapPhysicalIoValues *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons7__SoapPhysicalIosStates:
		soap_serialize_PointerTons7__SoapPhysicalIosStates(soap, (ns7__SoapPhysicalIosStates *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons7__SoapPhysicalIoLinks:
		soap_serialize_PointerTons7__SoapPhysicalIoLinks(soap, (ns7__SoapPhysicalIoLinks *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons7__SoapWatches:
		soap_serialize_PointerTons7__SoapWatches(soap, (ns7__SoapWatches *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons7__MimeData:
		soap_serialize_PointerTons7__MimeData(soap, (ns7__MimeData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons7__SoapCallStack:
		soap_serialize_PointerTons7__SoapCallStack(soap, (ns7__SoapCallStack *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons7__SoapTasks:
		soap_serialize_PointerTons7__SoapTasks(soap, (ns7__SoapTasks *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons7__BreakpointsResponses:
		soap_serialize_PointerTons7__BreakpointsResponses(soap, (ns7__BreakpointsResponses *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons7__SoapBreakpoints:
		soap_serialize_PointerTons7__SoapBreakpoints(soap, (ns7__SoapBreakpoints *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons7__SoapPhysicalIoAttrib:
		soap_serialize_PointerTons7__SoapPhysicalIoAttrib(soap, (ns7__SoapPhysicalIoAttrib *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons7__SoapPhysicalAioAttrib:
		soap_serialize_PointerTons7__SoapPhysicalAioAttrib(soap, (ns7__SoapPhysicalAioAttrib *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons7__SoapPhysicalDioAttrib:
		soap_serialize_PointerTons7__SoapPhysicalDioAttrib(soap, (ns7__SoapPhysicalDioAttrib *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons7__SoapInstruction:
		soap_serialize_PointerTons7__SoapInstruction(soap, (ns7__SoapInstruction *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons7__SoapProgramLine:
		soap_serialize_PointerTons7__SoapProgramLine(soap, (ns7__SoapProgramLine *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons7__SoapDhParameters:
		soap_serialize_PointerTons7__SoapDhParameters(soap, (ns7__SoapDhParameters *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons7__SoapPhysicalIoUnlockResponse:
		soap_serialize_PointerTons7__SoapPhysicalIoUnlockResponse(soap, (ns7__SoapPhysicalIoUnlockResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons7__SoapPhysicalIoResponse:
		soap_serialize_PointerTons7__SoapPhysicalIoResponse(soap, (ns7__SoapPhysicalIoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons7__SoapPhysicalIoState:
		soap_serialize_PointerTons7__SoapPhysicalIoState(soap, (ns7__SoapPhysicalIoState *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons7__SoapData:
		soap_serialize_PointerTons7__SoapData(soap, (ns7__SoapData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons7__SoapStackFrameAbstract:
		soap_serialize_PointerTons7__SoapStackFrameAbstract(soap, (ns7__SoapStackFrameAbstract *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons7__SoapTask:
		soap_serialize_PointerTons7__SoapTask(soap, (ns7__SoapTask *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons7__BreakpointsResponse:
		soap_serialize_PointerTons7__BreakpointsResponse(soap, (ns7__BreakpointsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons7__SoapBreakpoint:
		soap_serialize_PointerTons7__SoapBreakpoint(soap, (ns7__SoapBreakpoint *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__VALApplication:
		soap_serialize_PointerTons2__VALApplication(soap, (ns2__VALApplication *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CartesianPos:
		soap_serialize_PointerTons1__CartesianPos(soap, (ns1__CartesianPos *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__JointPos:
		soap_serialize_PointerTons1__JointPos(soap, (ns1__JointPos *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Robots:
		soap_serialize_PointerTons1__Robots(soap, (ns1__Robots *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Parameters:
		soap_serialize_PointerTons1__Parameters(soap, (ns1__Parameters *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Versions:
		soap_serialize_PointerTons1__Versions(soap, (ns1__Versions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SoapServerVersion:
		soap_serialize_PointerTons1__SoapServerVersion(soap, (ns1__SoapServerVersion *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Robot:
		soap_serialize_PointerTons1__Robot(soap, (ns1__Robot *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Version:
		soap_serialize_PointerTons1__Version(soap, (ns1__Version *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Parameter:
		soap_serialize_PointerTons1__Parameter(soap, (ns1__Parameter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTounsignedByte:
		soap_serialize_PointerTounsignedByte(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#ifdef __cplusplus
}
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_dupelement(struct soap *soap, const void *ptr, int type)
{(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	return NULL;
}
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_delelement(const void *ptr, int type)
{(void)ptr; (void)type; /* appease -Wall -Werror */
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__base64Binary:
		return (void*)soap_instantiate_xsd__base64Binary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__hexBinary:
		return (void*)soap_instantiate_xsd__hexBinary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ServerException:
		return (void*)soap_instantiate_ns1__ServerException(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__JointPos:
		return (void*)soap_instantiate_ns1__JointPos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CartesianPos:
		return (void*)soap_instantiate_ns1__CartesianPos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Robot:
		return (void*)soap_instantiate_ns1__Robot(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Version:
		return (void*)soap_instantiate_ns1__Version(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Parameter:
		return (void*)soap_instantiate_ns1__Parameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Parameters:
		return (void*)soap_instantiate_ns1__Parameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Versions:
		return (void*)soap_instantiate_ns1__Versions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SoapServerVersion:
		return (void*)soap_instantiate_ns1__SoapServerVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Robots:
		return (void*)soap_instantiate_ns1__Robots(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getSoapServerVersion:
		return (void*)soap_instantiate__ns1__getSoapServerVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getSoapServerVersionResponse:
		return (void*)soap_instantiate__ns1__getSoapServerVersionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__findServer:
		return (void*)soap_instantiate__ns1__findServer(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__findServerResponse:
		return (void*)soap_instantiate__ns1__findServerResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ping:
		return (void*)soap_instantiate__ns1__ping(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__pingResponse:
		return (void*)soap_instantiate__ns1__pingResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getCS8Versions:
		return (void*)soap_instantiate__ns1__getCS8Versions(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getCS8VersionsResponse:
		return (void*)soap_instantiate__ns1__getCS8VersionsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getControllerParameters:
		return (void*)soap_instantiate__ns1__getControllerParameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getControllerParametersResponse:
		return (void*)soap_instantiate__ns1__getControllerParametersResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getCS8Compatibility:
		return (void*)soap_instantiate__ns1__getCS8Compatibility(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getCS8CompatibilityResponse:
		return (void*)soap_instantiate__ns1__getCS8CompatibilityResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__login:
		return (void*)soap_instantiate__ns1__login(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__loginResponse:
		return (void*)soap_instantiate__ns1__loginResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__logout:
		return (void*)soap_instantiate__ns1__logout(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__logoutResponse:
		return (void*)soap_instantiate__ns1__logoutResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getRobots:
		return (void*)soap_instantiate__ns1__getRobots(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getRobotsResponse:
		return (void*)soap_instantiate__ns1__getRobotsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getRobotJointPos:
		return (void*)soap_instantiate__ns1__getRobotJointPos(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getRobotJointPosResponse:
		return (void*)soap_instantiate__ns1__getRobotJointPosResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getRobotJntCartPos:
		return (void*)soap_instantiate__ns1__getRobotJntCartPos(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getRobotJntCartPosResponse:
		return (void*)soap_instantiate__ns1__getRobotJntCartPosResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__setRobotJointPos:
		return (void*)soap_instantiate__ns1__setRobotJointPos(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__setRobotPosResponse:
		return (void*)soap_instantiate__ns1__setRobotPosResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__JointPos:
		return (void*)soap_instantiate_ns5__JointPos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__Parameters:
		return (void*)soap_instantiate_ns5__Parameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__Versions:
		return (void*)soap_instantiate_ns5__Versions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__Robots:
		return (void*)soap_instantiate_ns5__Robots(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__VALApplications:
		return (void*)soap_instantiate_ns5__VALApplications(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__Records:
		return (void*)soap_instantiate_ns5__Records(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__SoapBreakpoints:
		return (void*)soap_instantiate_ns5__SoapBreakpoints(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__BreakpointsResponses:
		return (void*)soap_instantiate_ns5__BreakpointsResponses(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__SoapTasks:
		return (void*)soap_instantiate_ns5__SoapTasks(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__SoapCallStack:
		return (void*)soap_instantiate_ns5__SoapCallStack(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__SoapWatches:
		return (void*)soap_instantiate_ns5__SoapWatches(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__SoapPhysicalIoLinks:
		return (void*)soap_instantiate_ns5__SoapPhysicalIoLinks(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__SoapPhysicalIoValues:
		return (void*)soap_instantiate_ns5__SoapPhysicalIoValues(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__SoapPhysicalIosStates:
		return (void*)soap_instantiate_ns5__SoapPhysicalIosStates(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__SoapPhysicalIoResponses:
		return (void*)soap_instantiate_ns5__SoapPhysicalIoResponses(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__SoapPhysicalIoUnlockResponses:
		return (void*)soap_instantiate_ns5__SoapPhysicalIoUnlockResponses(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__SoapDhParametersArray:
		return (void*)soap_instantiate_ns5__SoapDhParametersArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__JointPos:
		return (void*)soap_instantiate_ns7__JointPos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__Parameters:
		return (void*)soap_instantiate_ns7__Parameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__Versions:
		return (void*)soap_instantiate_ns7__Versions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__Robots:
		return (void*)soap_instantiate_ns7__Robots(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__VALApplications:
		return (void*)soap_instantiate_ns7__VALApplications(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__Records:
		return (void*)soap_instantiate_ns7__Records(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__SoapProgramLine:
		return (void*)soap_instantiate_ns7__SoapProgramLine(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__SoapBreakpoint:
		return (void*)soap_instantiate_ns7__SoapBreakpoint(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__SoapBreakpoints:
		return (void*)soap_instantiate_ns7__SoapBreakpoints(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__BreakpointsResponse:
		return (void*)soap_instantiate_ns7__BreakpointsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__BreakpointsResponses:
		return (void*)soap_instantiate_ns7__BreakpointsResponses(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__MimeData:
		return (void*)soap_instantiate_ns7__MimeData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__SoapTask:
		return (void*)soap_instantiate_ns7__SoapTask(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__SoapTasks:
		return (void*)soap_instantiate_ns7__SoapTasks(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__SoapInstruction:
		return (void*)soap_instantiate_ns7__SoapInstruction(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__SoapStackFrameAbstract:
		return (void*)soap_instantiate_ns7__SoapStackFrameAbstract(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__SoapCallStack:
		return (void*)soap_instantiate_ns7__SoapCallStack(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__SoapData:
		return (void*)soap_instantiate_ns7__SoapData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__SoapWatches:
		return (void*)soap_instantiate_ns7__SoapWatches(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__SoapPhysicalIoLinks:
		return (void*)soap_instantiate_ns7__SoapPhysicalIoLinks(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__SoapPhysicalDioAttrib:
		return (void*)soap_instantiate_ns7__SoapPhysicalDioAttrib(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__SoapPhysicalAioAttrib:
		return (void*)soap_instantiate_ns7__SoapPhysicalAioAttrib(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__SoapPhysicalIoAttrib:
		return (void*)soap_instantiate_ns7__SoapPhysicalIoAttrib(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__SoapPhysicalIoState:
		return (void*)soap_instantiate_ns7__SoapPhysicalIoState(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__SoapPhysicalIoValues:
		return (void*)soap_instantiate_ns7__SoapPhysicalIoValues(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__SoapPhysicalIosStates:
		return (void*)soap_instantiate_ns7__SoapPhysicalIosStates(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__SoapPhysicalIoResponse:
		return (void*)soap_instantiate_ns7__SoapPhysicalIoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__SoapPhysicalIoResponses:
		return (void*)soap_instantiate_ns7__SoapPhysicalIoResponses(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__SoapPhysicalIoUnlockResponse:
		return (void*)soap_instantiate_ns7__SoapPhysicalIoUnlockResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__SoapPhysicalIoUnlockResponses:
		return (void*)soap_instantiate_ns7__SoapPhysicalIoUnlockResponses(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__SoapDhParameters:
		return (void*)soap_instantiate_ns7__SoapDhParameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__SoapDhParametersArray:
		return (void*)soap_instantiate_ns7__SoapDhParametersArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__setBreakpoints:
		return (void*)soap_instantiate__ns7__setBreakpoints(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__setBreakpointsResponse:
		return (void*)soap_instantiate__ns7__setBreakpointsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__getBreakpoints:
		return (void*)soap_instantiate__ns7__getBreakpoints(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__getBreakpointsResponse:
		return (void*)soap_instantiate__ns7__getBreakpointsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__clearBreakpoints:
		return (void*)soap_instantiate__ns7__clearBreakpoints(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__clearBreakpointsResponse:
		return (void*)soap_instantiate__ns7__clearBreakpointsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__clearAllBreakpoints:
		return (void*)soap_instantiate__ns7__clearAllBreakpoints(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__clearAllBreakpointsResponse:
		return (void*)soap_instantiate__ns7__clearAllBreakpointsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__getTasks:
		return (void*)soap_instantiate__ns7__getTasks(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__getTasksResponse:
		return (void*)soap_instantiate__ns7__getTasksResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__taskSuspend:
		return (void*)soap_instantiate__ns7__taskSuspend(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__taskSuspendResponse:
		return (void*)soap_instantiate__ns7__taskSuspendResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__taskResume:
		return (void*)soap_instantiate__ns7__taskResume(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__taskResumeResponse:
		return (void*)soap_instantiate__ns7__taskResumeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__taskKill:
		return (void*)soap_instantiate__ns7__taskKill(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__taskKillResponse:
		return (void*)soap_instantiate__ns7__taskKillResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__taskStep:
		return (void*)soap_instantiate__ns7__taskStep(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__taskStepResponse:
		return (void*)soap_instantiate__ns7__taskStepResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__subscribeToControllerEvents:
		return (void*)soap_instantiate__ns7__subscribeToControllerEvents(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__subscribeResponse:
		return (void*)soap_instantiate__ns7__subscribeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__unsubscribeToControllerEvents:
		return (void*)soap_instantiate__ns7__unsubscribeToControllerEvents(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__unsubscribeResponse:
		return (void*)soap_instantiate__ns7__unsubscribeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__getCallStack:
		return (void*)soap_instantiate__ns7__getCallStack(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__getCallStackResponse:
		return (void*)soap_instantiate__ns7__getCallStackResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__getStackFrame:
		return (void*)soap_instantiate__ns7__getStackFrame(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__getStackFrameResponse:
		return (void*)soap_instantiate__ns7__getStackFrameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__getWatches:
		return (void*)soap_instantiate__ns7__getWatches(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__getWatchResponse:
		return (void*)soap_instantiate__ns7__getWatchResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__execVal3:
		return (void*)soap_instantiate__ns7__execVal3(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__execVal3Response:
		return (void*)soap_instantiate__ns7__execVal3Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__setProjectAsModified:
		return (void*)soap_instantiate__ns7__setProjectAsModified(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__setProjectAsModifiedResponse:
		return (void*)soap_instantiate__ns7__setProjectAsModifiedResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__setCurrentInstruction:
		return (void*)soap_instantiate__ns7__setCurrentInstruction(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__setCurrentInstructionResponse:
		return (void*)soap_instantiate__ns7__setCurrentInstructionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__replaceLine:
		return (void*)soap_instantiate__ns7__replaceLine(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__replaceLineResponse:
		return (void*)soap_instantiate__ns7__replaceLineResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__readIos:
		return (void*)soap_instantiate__ns7__readIos(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__readIosResponse:
		return (void*)soap_instantiate__ns7__readIosResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__writeIos:
		return (void*)soap_instantiate__ns7__writeIos(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__writeIosResponse:
		return (void*)soap_instantiate__ns7__writeIosResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__lockIos:
		return (void*)soap_instantiate__ns7__lockIos(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__lockIosResponse:
		return (void*)soap_instantiate__ns7__lockIosResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__unlockIos:
		return (void*)soap_instantiate__ns7__unlockIos(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__unlockIosResponse:
		return (void*)soap_instantiate__ns7__unlockIosResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__lockAllIos:
		return (void*)soap_instantiate__ns7__lockAllIos(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__SoapAllPhysicalIoResponse:
		return (void*)soap_instantiate__ns7__SoapAllPhysicalIoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__unlockAllIos:
		return (void*)soap_instantiate__ns7__unlockAllIos(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__getAllPhysicalIos:
		return (void*)soap_instantiate__ns7__getAllPhysicalIos(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__getAllPhysicalIosResponse:
		return (void*)soap_instantiate__ns7__getAllPhysicalIosResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__getRobotDhParameters:
		return (void*)soap_instantiate__ns7__getRobotDhParameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__SoapRobotDhParameters:
		return (void*)soap_instantiate__ns7__SoapRobotDhParameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__getProject:
		return (void*)soap_instantiate__ns7__getProject(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__getProjectResponse:
		return (void*)soap_instantiate__ns7__getProjectResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__Include:
		return (void*)soap_instantiate_ns3__Include(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__VALApplication:
		return (void*)soap_instantiate_ns2__VALApplication(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__VALApplications:
		return (void*)soap_instantiate_ns2__VALApplications(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__Data:
		return (void*)soap_instantiate_ns2__Data(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__Records:
		return (void*)soap_instantiate_ns2__Records(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__JointRange:
		return (void*)soap_instantiate_ns2__JointRange(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__getApplications:
		return (void*)soap_instantiate__ns2__getApplications(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__getApplicationsResponse:
		return (void*)soap_instantiate__ns2__getApplicationsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__getApplicationDatas:
		return (void*)soap_instantiate__ns2__getApplicationDatas(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__getApplicationDatasResponse:
		return (void*)soap_instantiate__ns2__getApplicationDatasResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__getRecords:
		return (void*)soap_instantiate__ns2__getRecords(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__getRecordsResponse:
		return (void*)soap_instantiate__ns2__getRecordsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__getRecord:
		return (void*)soap_instantiate__ns2__getRecord(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__getRecordResponse:
		return (void*)soap_instantiate__ns2__getRecordResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__getJointRange:
		return (void*)soap_instantiate__ns2__getJointRange(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__getJointRangeResponse:
		return (void*)soap_instantiate__ns2__getJointRangeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__base64Binary:
		return (void*)soap_instantiate_ns4__base64Binary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__hexBinary:
		return (void*)soap_instantiate_ns4__hexBinary(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE___ns1__getSoapServerVersion:
		return (void*)soap_instantiate___ns1__getSoapServerVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__findServer:
		return (void*)soap_instantiate___ns1__findServer(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ping:
		return (void*)soap_instantiate___ns1__ping(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getCS8Versions:
		return (void*)soap_instantiate___ns1__getCS8Versions(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getControllerParameters:
		return (void*)soap_instantiate___ns1__getControllerParameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getCS8Compatibility:
		return (void*)soap_instantiate___ns1__getCS8Compatibility(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__login:
		return (void*)soap_instantiate___ns1__login(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__logout:
		return (void*)soap_instantiate___ns1__logout(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getRobots:
		return (void*)soap_instantiate___ns1__getRobots(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getRobotJointPos:
		return (void*)soap_instantiate___ns1__getRobotJointPos(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getRobotJntCartPos:
		return (void*)soap_instantiate___ns1__getRobotJntCartPos(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__setRobotJointPos:
		return (void*)soap_instantiate___ns1__setRobotJointPos(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__setBreakpoints:
		return (void*)soap_instantiate___ns7__setBreakpoints(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__getBreakpoints:
		return (void*)soap_instantiate___ns7__getBreakpoints(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__clearBreakpoints:
		return (void*)soap_instantiate___ns7__clearBreakpoints(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__clearAllBreakpoints:
		return (void*)soap_instantiate___ns7__clearAllBreakpoints(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__getTasks:
		return (void*)soap_instantiate___ns7__getTasks(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__taskSuspend:
		return (void*)soap_instantiate___ns7__taskSuspend(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__taskResume:
		return (void*)soap_instantiate___ns7__taskResume(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__taskKill:
		return (void*)soap_instantiate___ns7__taskKill(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__taskStep:
		return (void*)soap_instantiate___ns7__taskStep(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__subscribeToControllerEvents:
		return (void*)soap_instantiate___ns7__subscribeToControllerEvents(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__unsubscribeToControllerEvents:
		return (void*)soap_instantiate___ns7__unsubscribeToControllerEvents(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__getCallStack:
		return (void*)soap_instantiate___ns7__getCallStack(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__getStackFrame:
		return (void*)soap_instantiate___ns7__getStackFrame(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__getWatches:
		return (void*)soap_instantiate___ns7__getWatches(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__execVal3:
		return (void*)soap_instantiate___ns7__execVal3(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__setProjectAsModified:
		return (void*)soap_instantiate___ns7__setProjectAsModified(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__setCurrentInstruction:
		return (void*)soap_instantiate___ns7__setCurrentInstruction(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__replaceLine:
		return (void*)soap_instantiate___ns7__replaceLine(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__readIos:
		return (void*)soap_instantiate___ns7__readIos(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__writeIos:
		return (void*)soap_instantiate___ns7__writeIos(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__lockIos:
		return (void*)soap_instantiate___ns7__lockIos(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__unlockIos:
		return (void*)soap_instantiate___ns7__unlockIos(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__lockAllIos:
		return (void*)soap_instantiate___ns7__lockAllIos(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__unlockAllIos:
		return (void*)soap_instantiate___ns7__unlockAllIos(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__getAllPhysicalIos:
		return (void*)soap_instantiate___ns7__getAllPhysicalIos(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__getRobotDhParameters:
		return (void*)soap_instantiate___ns7__getRobotDhParameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__getProject:
		return (void*)soap_instantiate___ns7__getProject(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_xsd__anyURI:
		return (void*)soap_instantiate_xsd__anyURI(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		return (void*)soap_instantiate_std__vectorTemplateOf_XML(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapDhParameters:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons7__SoapDhParameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapPhysicalIoUnlockResponse:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons7__SoapPhysicalIoUnlockResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapPhysicalIoResponse:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons7__SoapPhysicalIoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapPhysicalIoState:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons7__SoapPhysicalIoState(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapData:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons7__SoapData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapStackFrameAbstract:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons7__SoapStackFrameAbstract(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapTask:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons7__SoapTask(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__BreakpointsResponse:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons7__BreakpointsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapBreakpoint:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons7__SoapBreakpoint(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		return (void*)soap_instantiate_std__vectorTemplateOfstd__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__VALApplication:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__VALApplication(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Robot:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__Robot(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Version:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__Version(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Parameter:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__Parameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfdouble:
		return (void*)soap_instantiate_std__vectorTemplateOfdouble(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE_xsd__base64Binary:
		if (p->size < 0)
			SOAP_DELETE(static_cast<xsd__base64Binary*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<xsd__base64Binary*>(p->ptr));
		break;
	case SOAP_TYPE_xsd__hexBinary:
		if (p->size < 0)
			SOAP_DELETE(static_cast<xsd__hexBinary*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<xsd__hexBinary*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__ServerException:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__ServerException*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__ServerException*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__JointPos:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__JointPos*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__JointPos*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__CartesianPos:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__CartesianPos*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__CartesianPos*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__Robot:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__Robot*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__Robot*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__Version:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__Version*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__Version*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__Parameter:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__Parameter*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__Parameter*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__Parameters:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__Parameters*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__Parameters*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__Versions:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__Versions*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__Versions*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__SoapServerVersion:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__SoapServerVersion*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__SoapServerVersion*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__Robots:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__Robots*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__Robots*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__getSoapServerVersion:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__getSoapServerVersion*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__getSoapServerVersion*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__getSoapServerVersionResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__getSoapServerVersionResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__getSoapServerVersionResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__findServer:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__findServer*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__findServer*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__findServerResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__findServerResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__findServerResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__ping:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__ping*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__ping*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__pingResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__pingResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__pingResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__getCS8Versions:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__getCS8Versions*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__getCS8Versions*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__getCS8VersionsResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__getCS8VersionsResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__getCS8VersionsResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__getControllerParameters:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__getControllerParameters*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__getControllerParameters*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__getControllerParametersResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__getControllerParametersResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__getControllerParametersResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__getCS8Compatibility:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__getCS8Compatibility*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__getCS8Compatibility*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__getCS8CompatibilityResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__getCS8CompatibilityResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__getCS8CompatibilityResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__login:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__login*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__login*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__loginResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__loginResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__loginResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__logout:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__logout*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__logout*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__logoutResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__logoutResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__logoutResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__getRobots:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__getRobots*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__getRobots*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__getRobotsResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__getRobotsResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__getRobotsResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__getRobotJointPos:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__getRobotJointPos*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__getRobotJointPos*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__getRobotJointPosResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__getRobotJointPosResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__getRobotJointPosResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__getRobotJntCartPos:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__getRobotJntCartPos*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__getRobotJntCartPos*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__getRobotJntCartPosResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__getRobotJntCartPosResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__getRobotJntCartPosResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__setRobotJointPos:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__setRobotJointPos*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__setRobotJointPos*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__setRobotPosResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__setRobotPosResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__setRobotPosResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__JointPos:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__JointPos*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__JointPos*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__Parameters:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__Parameters*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__Parameters*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__Versions:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__Versions*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__Versions*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__Robots:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__Robots*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__Robots*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__VALApplications:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__VALApplications*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__VALApplications*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__Records:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__Records*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__Records*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__SoapBreakpoints:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__SoapBreakpoints*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__SoapBreakpoints*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__BreakpointsResponses:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__BreakpointsResponses*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__BreakpointsResponses*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__SoapTasks:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__SoapTasks*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__SoapTasks*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__SoapCallStack:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__SoapCallStack*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__SoapCallStack*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__SoapWatches:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__SoapWatches*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__SoapWatches*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__SoapPhysicalIoLinks:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__SoapPhysicalIoLinks*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__SoapPhysicalIoLinks*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__SoapPhysicalIoValues:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__SoapPhysicalIoValues*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__SoapPhysicalIoValues*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__SoapPhysicalIosStates:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__SoapPhysicalIosStates*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__SoapPhysicalIosStates*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__SoapPhysicalIoResponses:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__SoapPhysicalIoResponses*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__SoapPhysicalIoResponses*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__SoapPhysicalIoUnlockResponses:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__SoapPhysicalIoUnlockResponses*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__SoapPhysicalIoUnlockResponses*>(p->ptr));
		break;
	case SOAP_TYPE_ns5__SoapDhParametersArray:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns5__SoapDhParametersArray*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns5__SoapDhParametersArray*>(p->ptr));
		break;
	case SOAP_TYPE_ns7__JointPos:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns7__JointPos*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns7__JointPos*>(p->ptr));
		break;
	case SOAP_TYPE_ns7__Parameters:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns7__Parameters*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns7__Parameters*>(p->ptr));
		break;
	case SOAP_TYPE_ns7__Versions:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns7__Versions*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns7__Versions*>(p->ptr));
		break;
	case SOAP_TYPE_ns7__Robots:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns7__Robots*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns7__Robots*>(p->ptr));
		break;
	case SOAP_TYPE_ns7__VALApplications:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns7__VALApplications*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns7__VALApplications*>(p->ptr));
		break;
	case SOAP_TYPE_ns7__Records:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns7__Records*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns7__Records*>(p->ptr));
		break;
	case SOAP_TYPE_ns7__SoapProgramLine:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns7__SoapProgramLine*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns7__SoapProgramLine*>(p->ptr));
		break;
	case SOAP_TYPE_ns7__SoapBreakpoint:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns7__SoapBreakpoint*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns7__SoapBreakpoint*>(p->ptr));
		break;
	case SOAP_TYPE_ns7__SoapBreakpoints:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns7__SoapBreakpoints*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns7__SoapBreakpoints*>(p->ptr));
		break;
	case SOAP_TYPE_ns7__BreakpointsResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns7__BreakpointsResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns7__BreakpointsResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns7__BreakpointsResponses:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns7__BreakpointsResponses*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns7__BreakpointsResponses*>(p->ptr));
		break;
	case SOAP_TYPE_ns7__MimeData:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns7__MimeData*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns7__MimeData*>(p->ptr));
		break;
	case SOAP_TYPE_ns7__SoapTask:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns7__SoapTask*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns7__SoapTask*>(p->ptr));
		break;
	case SOAP_TYPE_ns7__SoapTasks:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns7__SoapTasks*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns7__SoapTasks*>(p->ptr));
		break;
	case SOAP_TYPE_ns7__SoapInstruction:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns7__SoapInstruction*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns7__SoapInstruction*>(p->ptr));
		break;
	case SOAP_TYPE_ns7__SoapStackFrameAbstract:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns7__SoapStackFrameAbstract*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns7__SoapStackFrameAbstract*>(p->ptr));
		break;
	case SOAP_TYPE_ns7__SoapCallStack:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns7__SoapCallStack*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns7__SoapCallStack*>(p->ptr));
		break;
	case SOAP_TYPE_ns7__SoapData:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns7__SoapData*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns7__SoapData*>(p->ptr));
		break;
	case SOAP_TYPE_ns7__SoapWatches:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns7__SoapWatches*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns7__SoapWatches*>(p->ptr));
		break;
	case SOAP_TYPE_ns7__SoapPhysicalIoLinks:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns7__SoapPhysicalIoLinks*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns7__SoapPhysicalIoLinks*>(p->ptr));
		break;
	case SOAP_TYPE_ns7__SoapPhysicalDioAttrib:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns7__SoapPhysicalDioAttrib*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns7__SoapPhysicalDioAttrib*>(p->ptr));
		break;
	case SOAP_TYPE_ns7__SoapPhysicalAioAttrib:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns7__SoapPhysicalAioAttrib*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns7__SoapPhysicalAioAttrib*>(p->ptr));
		break;
	case SOAP_TYPE_ns7__SoapPhysicalIoAttrib:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns7__SoapPhysicalIoAttrib*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns7__SoapPhysicalIoAttrib*>(p->ptr));
		break;
	case SOAP_TYPE_ns7__SoapPhysicalIoState:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns7__SoapPhysicalIoState*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns7__SoapPhysicalIoState*>(p->ptr));
		break;
	case SOAP_TYPE_ns7__SoapPhysicalIoValues:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns7__SoapPhysicalIoValues*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns7__SoapPhysicalIoValues*>(p->ptr));
		break;
	case SOAP_TYPE_ns7__SoapPhysicalIosStates:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns7__SoapPhysicalIosStates*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns7__SoapPhysicalIosStates*>(p->ptr));
		break;
	case SOAP_TYPE_ns7__SoapPhysicalIoResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns7__SoapPhysicalIoResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns7__SoapPhysicalIoResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns7__SoapPhysicalIoResponses:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns7__SoapPhysicalIoResponses*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns7__SoapPhysicalIoResponses*>(p->ptr));
		break;
	case SOAP_TYPE_ns7__SoapPhysicalIoUnlockResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns7__SoapPhysicalIoUnlockResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns7__SoapPhysicalIoUnlockResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns7__SoapPhysicalIoUnlockResponses:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns7__SoapPhysicalIoUnlockResponses*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns7__SoapPhysicalIoUnlockResponses*>(p->ptr));
		break;
	case SOAP_TYPE_ns7__SoapDhParameters:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns7__SoapDhParameters*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns7__SoapDhParameters*>(p->ptr));
		break;
	case SOAP_TYPE_ns7__SoapDhParametersArray:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns7__SoapDhParametersArray*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns7__SoapDhParametersArray*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__setBreakpoints:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__setBreakpoints*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__setBreakpoints*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__setBreakpointsResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__setBreakpointsResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__setBreakpointsResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__getBreakpoints:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__getBreakpoints*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__getBreakpoints*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__getBreakpointsResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__getBreakpointsResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__getBreakpointsResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__clearBreakpoints:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__clearBreakpoints*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__clearBreakpoints*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__clearBreakpointsResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__clearBreakpointsResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__clearBreakpointsResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__clearAllBreakpoints:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__clearAllBreakpoints*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__clearAllBreakpoints*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__clearAllBreakpointsResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__clearAllBreakpointsResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__clearAllBreakpointsResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__getTasks:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__getTasks*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__getTasks*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__getTasksResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__getTasksResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__getTasksResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__taskSuspend:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__taskSuspend*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__taskSuspend*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__taskSuspendResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__taskSuspendResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__taskSuspendResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__taskResume:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__taskResume*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__taskResume*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__taskResumeResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__taskResumeResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__taskResumeResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__taskKill:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__taskKill*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__taskKill*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__taskKillResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__taskKillResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__taskKillResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__taskStep:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__taskStep*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__taskStep*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__taskStepResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__taskStepResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__taskStepResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__subscribeToControllerEvents:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__subscribeToControllerEvents*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__subscribeToControllerEvents*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__subscribeResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__subscribeResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__subscribeResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__unsubscribeToControllerEvents:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__unsubscribeToControllerEvents*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__unsubscribeToControllerEvents*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__unsubscribeResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__unsubscribeResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__unsubscribeResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__getCallStack:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__getCallStack*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__getCallStack*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__getCallStackResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__getCallStackResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__getCallStackResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__getStackFrame:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__getStackFrame*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__getStackFrame*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__getStackFrameResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__getStackFrameResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__getStackFrameResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__getWatches:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__getWatches*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__getWatches*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__getWatchResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__getWatchResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__getWatchResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__execVal3:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__execVal3*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__execVal3*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__execVal3Response:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__execVal3Response*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__execVal3Response*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__setProjectAsModified:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__setProjectAsModified*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__setProjectAsModified*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__setProjectAsModifiedResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__setProjectAsModifiedResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__setProjectAsModifiedResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__setCurrentInstruction:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__setCurrentInstruction*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__setCurrentInstruction*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__setCurrentInstructionResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__setCurrentInstructionResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__setCurrentInstructionResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__replaceLine:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__replaceLine*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__replaceLine*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__replaceLineResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__replaceLineResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__replaceLineResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__readIos:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__readIos*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__readIos*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__readIosResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__readIosResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__readIosResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__writeIos:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__writeIos*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__writeIos*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__writeIosResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__writeIosResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__writeIosResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__lockIos:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__lockIos*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__lockIos*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__lockIosResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__lockIosResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__lockIosResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__unlockIos:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__unlockIos*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__unlockIos*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__unlockIosResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__unlockIosResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__unlockIosResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__lockAllIos:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__lockAllIos*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__lockAllIos*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__SoapAllPhysicalIoResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__SoapAllPhysicalIoResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__SoapAllPhysicalIoResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__unlockAllIos:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__unlockAllIos*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__unlockAllIos*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__getAllPhysicalIos:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__getAllPhysicalIos*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__getAllPhysicalIos*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__getAllPhysicalIosResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__getAllPhysicalIosResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__getAllPhysicalIosResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__getRobotDhParameters:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__getRobotDhParameters*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__getRobotDhParameters*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__SoapRobotDhParameters:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__SoapRobotDhParameters*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__SoapRobotDhParameters*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__getProject:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__getProject*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__getProject*>(p->ptr));
		break;
	case SOAP_TYPE__ns7__getProjectResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns7__getProjectResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns7__getProjectResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns3__Include:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns3__Include*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns3__Include*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__VALApplication:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__VALApplication*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__VALApplication*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__VALApplications:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__VALApplications*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__VALApplications*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__Data:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__Data*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__Data*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__Records:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__Records*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__Records*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__JointRange:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__JointRange*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__JointRange*>(p->ptr));
		break;
	case SOAP_TYPE__ns2__getApplications:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns2__getApplications*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns2__getApplications*>(p->ptr));
		break;
	case SOAP_TYPE__ns2__getApplicationsResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns2__getApplicationsResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns2__getApplicationsResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns2__getApplicationDatas:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns2__getApplicationDatas*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns2__getApplicationDatas*>(p->ptr));
		break;
	case SOAP_TYPE__ns2__getApplicationDatasResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns2__getApplicationDatasResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns2__getApplicationDatasResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns2__getRecords:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns2__getRecords*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns2__getRecords*>(p->ptr));
		break;
	case SOAP_TYPE__ns2__getRecordsResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns2__getRecordsResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns2__getRecordsResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns2__getRecord:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns2__getRecord*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns2__getRecord*>(p->ptr));
		break;
	case SOAP_TYPE__ns2__getRecordResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns2__getRecordResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns2__getRecordResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns2__getJointRange:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns2__getJointRange*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns2__getJointRange*>(p->ptr));
		break;
	case SOAP_TYPE__ns2__getJointRangeResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns2__getJointRangeResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns2__getJointRangeResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns4__base64Binary:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns4__base64Binary*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns4__base64Binary*>(p->ptr));
		break;
	case SOAP_TYPE_ns4__hexBinary:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns4__hexBinary*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns4__hexBinary*>(p->ptr));
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Header*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Header*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Detail*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Detail*>(p->ptr));
		break;
#endif
	case SOAP_TYPE___ns1__getSoapServerVersion:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getSoapServerVersion*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getSoapServerVersion*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__findServer:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__findServer*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__findServer*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__ping:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__ping*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__ping*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getCS8Versions:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getCS8Versions*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getCS8Versions*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getControllerParameters:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getControllerParameters*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getControllerParameters*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getCS8Compatibility:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getCS8Compatibility*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getCS8Compatibility*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__login:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__login*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__login*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__logout:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__logout*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__logout*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getRobots:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getRobots*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getRobots*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getRobotJointPos:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getRobotJointPos*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getRobotJointPos*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getRobotJntCartPos:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getRobotJntCartPos*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getRobotJntCartPos*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__setRobotJointPos:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__setRobotJointPos*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__setRobotJointPos*>(p->ptr));
		break;
	case SOAP_TYPE___ns7__setBreakpoints:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns7__setBreakpoints*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns7__setBreakpoints*>(p->ptr));
		break;
	case SOAP_TYPE___ns7__getBreakpoints:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns7__getBreakpoints*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns7__getBreakpoints*>(p->ptr));
		break;
	case SOAP_TYPE___ns7__clearBreakpoints:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns7__clearBreakpoints*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns7__clearBreakpoints*>(p->ptr));
		break;
	case SOAP_TYPE___ns7__clearAllBreakpoints:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns7__clearAllBreakpoints*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns7__clearAllBreakpoints*>(p->ptr));
		break;
	case SOAP_TYPE___ns7__getTasks:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns7__getTasks*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns7__getTasks*>(p->ptr));
		break;
	case SOAP_TYPE___ns7__taskSuspend:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns7__taskSuspend*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns7__taskSuspend*>(p->ptr));
		break;
	case SOAP_TYPE___ns7__taskResume:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns7__taskResume*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns7__taskResume*>(p->ptr));
		break;
	case SOAP_TYPE___ns7__taskKill:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns7__taskKill*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns7__taskKill*>(p->ptr));
		break;
	case SOAP_TYPE___ns7__taskStep:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns7__taskStep*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns7__taskStep*>(p->ptr));
		break;
	case SOAP_TYPE___ns7__subscribeToControllerEvents:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns7__subscribeToControllerEvents*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns7__subscribeToControllerEvents*>(p->ptr));
		break;
	case SOAP_TYPE___ns7__unsubscribeToControllerEvents:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns7__unsubscribeToControllerEvents*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns7__unsubscribeToControllerEvents*>(p->ptr));
		break;
	case SOAP_TYPE___ns7__getCallStack:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns7__getCallStack*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns7__getCallStack*>(p->ptr));
		break;
	case SOAP_TYPE___ns7__getStackFrame:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns7__getStackFrame*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns7__getStackFrame*>(p->ptr));
		break;
	case SOAP_TYPE___ns7__getWatches:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns7__getWatches*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns7__getWatches*>(p->ptr));
		break;
	case SOAP_TYPE___ns7__execVal3:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns7__execVal3*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns7__execVal3*>(p->ptr));
		break;
	case SOAP_TYPE___ns7__setProjectAsModified:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns7__setProjectAsModified*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns7__setProjectAsModified*>(p->ptr));
		break;
	case SOAP_TYPE___ns7__setCurrentInstruction:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns7__setCurrentInstruction*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns7__setCurrentInstruction*>(p->ptr));
		break;
	case SOAP_TYPE___ns7__replaceLine:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns7__replaceLine*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns7__replaceLine*>(p->ptr));
		break;
	case SOAP_TYPE___ns7__readIos:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns7__readIos*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns7__readIos*>(p->ptr));
		break;
	case SOAP_TYPE___ns7__writeIos:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns7__writeIos*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns7__writeIos*>(p->ptr));
		break;
	case SOAP_TYPE___ns7__lockIos:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns7__lockIos*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns7__lockIos*>(p->ptr));
		break;
	case SOAP_TYPE___ns7__unlockIos:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns7__unlockIos*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns7__unlockIos*>(p->ptr));
		break;
	case SOAP_TYPE___ns7__lockAllIos:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns7__lockAllIos*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns7__lockAllIos*>(p->ptr));
		break;
	case SOAP_TYPE___ns7__unlockAllIos:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns7__unlockAllIos*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns7__unlockAllIos*>(p->ptr));
		break;
	case SOAP_TYPE___ns7__getAllPhysicalIos:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns7__getAllPhysicalIos*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns7__getAllPhysicalIos*>(p->ptr));
		break;
	case SOAP_TYPE___ns7__getRobotDhParameters:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns7__getRobotDhParameters*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns7__getRobotDhParameters*>(p->ptr));
		break;
	case SOAP_TYPE___ns7__getProject:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns7__getProject*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns7__getProject*>(p->ptr));
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Code*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Code*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Reason*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Reason*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Fault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Fault*>(p->ptr));
		break;
#endif
	case SOAP_TYPE_xsd__anyURI:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<char *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<char *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapDhParameters:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns7__SoapDhParameters *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns7__SoapDhParameters *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapPhysicalIoUnlockResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns7__SoapPhysicalIoUnlockResponse *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns7__SoapPhysicalIoUnlockResponse *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapPhysicalIoResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns7__SoapPhysicalIoResponse *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns7__SoapPhysicalIoResponse *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapPhysicalIoState:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns7__SoapPhysicalIoState *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns7__SoapPhysicalIoState *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapData:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns7__SoapData *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns7__SoapData *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapStackFrameAbstract:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns7__SoapStackFrameAbstract *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns7__SoapStackFrameAbstract *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapTask:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns7__SoapTask *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns7__SoapTask *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__BreakpointsResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns7__BreakpointsResponse *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns7__BreakpointsResponse *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapBreakpoint:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns7__SoapBreakpoint *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns7__SoapBreakpoint *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<std::string> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<std::string> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__VALApplication:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns2__VALApplication *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns2__VALApplication *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Robot:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns1__Robot *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns1__Robot *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Version:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns1__Version *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns1__Version *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Parameter:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns1__Parameter *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns1__Parameter *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfdouble:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<double> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<double> *>(p->ptr));
		break;
	default:
		return SOAP_ERR;
	}
	return SOAP_OK;
}

#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_fbase(int t, int b)
{	(void)t; (void)b; /* appease -Wall -Werror */
	return 0;
}
#ifdef WIN32
#pragma warning(pop)
#endif

#ifndef WITH_NOIDREF
#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_finsert(struct soap *soap, int t, int tt, void *p, size_t index, const void *q, void **x)
{
	(void)soap; (void)t; (void)p; (void)index; (void)q; (void)x; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		if (t == SOAP_TYPE__XML)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<char *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<char *> *)p)[index] = *(char **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapDhParameters:
		if (t == SOAP_TYPE_ns7__SoapDhParameters || soap_fbase(t, SOAP_TYPE_ns7__SoapDhParameters))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns7__SoapDhParameters *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns7__SoapDhParameters *> *)p)[index] = *(ns7__SoapDhParameters **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapPhysicalIoUnlockResponse:
		if (t == SOAP_TYPE_ns7__SoapPhysicalIoUnlockResponse || soap_fbase(t, SOAP_TYPE_ns7__SoapPhysicalIoUnlockResponse))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns7__SoapPhysicalIoUnlockResponse *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns7__SoapPhysicalIoUnlockResponse *> *)p)[index] = *(ns7__SoapPhysicalIoUnlockResponse **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapPhysicalIoResponse:
		if (t == SOAP_TYPE_ns7__SoapPhysicalIoResponse || soap_fbase(t, SOAP_TYPE_ns7__SoapPhysicalIoResponse))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns7__SoapPhysicalIoResponse *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns7__SoapPhysicalIoResponse *> *)p)[index] = *(ns7__SoapPhysicalIoResponse **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapPhysicalIoState:
		if (t == SOAP_TYPE_ns7__SoapPhysicalIoState || soap_fbase(t, SOAP_TYPE_ns7__SoapPhysicalIoState))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns7__SoapPhysicalIoState *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns7__SoapPhysicalIoState *> *)p)[index] = *(ns7__SoapPhysicalIoState **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapData:
		if (t == SOAP_TYPE_ns7__SoapData || soap_fbase(t, SOAP_TYPE_ns7__SoapData))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns7__SoapData *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns7__SoapData *> *)p)[index] = *(ns7__SoapData **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapStackFrameAbstract:
		if (t == SOAP_TYPE_ns7__SoapStackFrameAbstract || soap_fbase(t, SOAP_TYPE_ns7__SoapStackFrameAbstract))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns7__SoapStackFrameAbstract *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns7__SoapStackFrameAbstract *> *)p)[index] = *(ns7__SoapStackFrameAbstract **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapTask:
		if (t == SOAP_TYPE_ns7__SoapTask || soap_fbase(t, SOAP_TYPE_ns7__SoapTask))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns7__SoapTask *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns7__SoapTask *> *)p)[index] = *(ns7__SoapTask **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__BreakpointsResponse:
		if (t == SOAP_TYPE_ns7__BreakpointsResponse || soap_fbase(t, SOAP_TYPE_ns7__BreakpointsResponse))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns7__BreakpointsResponse *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns7__BreakpointsResponse *> *)p)[index] = *(ns7__BreakpointsResponse **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapBreakpoint:
		if (t == SOAP_TYPE_ns7__SoapBreakpoint || soap_fbase(t, SOAP_TYPE_ns7__SoapBreakpoint))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns7__SoapBreakpoint *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns7__SoapBreakpoint *> *)p)[index] = *(ns7__SoapBreakpoint **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		if (t == SOAP_TYPE_std__string)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<std::string>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<std::string> *)p)[index] = *(std::string *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__VALApplication:
		if (t == SOAP_TYPE_ns2__VALApplication || soap_fbase(t, SOAP_TYPE_ns2__VALApplication))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns2__VALApplication *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns2__VALApplication *> *)p)[index] = *(ns2__VALApplication **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Robot:
		if (t == SOAP_TYPE_ns1__Robot || soap_fbase(t, SOAP_TYPE_ns1__Robot))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__Robot *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__Robot *> *)p)[index] = *(ns1__Robot **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Version:
		if (t == SOAP_TYPE_ns1__Version || soap_fbase(t, SOAP_TYPE_ns1__Version))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__Version *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__Version *> *)p)[index] = *(ns1__Version **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Parameter:
		if (t == SOAP_TYPE_ns1__Parameter || soap_fbase(t, SOAP_TYPE_ns1__Parameter))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__Parameter *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__Parameter *> *)p)[index] = *(ns1__Parameter **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfdouble:
		if (t == SOAP_TYPE_double)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<double>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<double> *)p)[index] = *(double *)q;
		}
		break;
	case SOAP_TYPE_std__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__base64Binary:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__base64Binary type=%d location=%p object=%p\n", t, p, q));
		*(xsd__base64Binary*)p = *(xsd__base64Binary*)q;
		break;
	case SOAP_TYPE_xsd__hexBinary:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__hexBinary type=%d location=%p object=%p\n", t, p, q));
		*(xsd__hexBinary*)p = *(xsd__hexBinary*)q;
		break;
	case SOAP_TYPE_ns1__ServerException:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ServerException type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ServerException*)p = *(ns1__ServerException*)q;
		break;
	case SOAP_TYPE_ns1__JointPos:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__JointPos type=%d location=%p object=%p\n", t, p, q));
		*(ns1__JointPos*)p = *(ns1__JointPos*)q;
		break;
	case SOAP_TYPE_ns1__CartesianPos:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__CartesianPos type=%d location=%p object=%p\n", t, p, q));
		*(ns1__CartesianPos*)p = *(ns1__CartesianPos*)q;
		break;
	case SOAP_TYPE_ns1__Robot:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__Robot type=%d location=%p object=%p\n", t, p, q));
		*(ns1__Robot*)p = *(ns1__Robot*)q;
		break;
	case SOAP_TYPE_ns1__Version:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__Version type=%d location=%p object=%p\n", t, p, q));
		*(ns1__Version*)p = *(ns1__Version*)q;
		break;
	case SOAP_TYPE_ns1__Parameter:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__Parameter type=%d location=%p object=%p\n", t, p, q));
		*(ns1__Parameter*)p = *(ns1__Parameter*)q;
		break;
	case SOAP_TYPE_ns1__Parameters:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__Parameters type=%d location=%p object=%p\n", t, p, q));
		*(ns1__Parameters*)p = *(ns1__Parameters*)q;
		break;
	case SOAP_TYPE_ns1__Versions:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__Versions type=%d location=%p object=%p\n", t, p, q));
		*(ns1__Versions*)p = *(ns1__Versions*)q;
		break;
	case SOAP_TYPE_ns1__SoapServerVersion:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__SoapServerVersion type=%d location=%p object=%p\n", t, p, q));
		*(ns1__SoapServerVersion*)p = *(ns1__SoapServerVersion*)q;
		break;
	case SOAP_TYPE_ns1__Robots:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__Robots type=%d location=%p object=%p\n", t, p, q));
		*(ns1__Robots*)p = *(ns1__Robots*)q;
		break;
	case SOAP_TYPE__ns1__getSoapServerVersion:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__getSoapServerVersion type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__getSoapServerVersion*)p = *(_ns1__getSoapServerVersion*)q;
		break;
	case SOAP_TYPE__ns1__getSoapServerVersionResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__getSoapServerVersionResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__getSoapServerVersionResponse*)p = *(_ns1__getSoapServerVersionResponse*)q;
		break;
	case SOAP_TYPE__ns1__findServer:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__findServer type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__findServer*)p = *(_ns1__findServer*)q;
		break;
	case SOAP_TYPE__ns1__findServerResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__findServerResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__findServerResponse*)p = *(_ns1__findServerResponse*)q;
		break;
	case SOAP_TYPE__ns1__ping:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ping type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ping*)p = *(_ns1__ping*)q;
		break;
	case SOAP_TYPE__ns1__pingResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__pingResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__pingResponse*)p = *(_ns1__pingResponse*)q;
		break;
	case SOAP_TYPE__ns1__getCS8Versions:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__getCS8Versions type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__getCS8Versions*)p = *(_ns1__getCS8Versions*)q;
		break;
	case SOAP_TYPE__ns1__getCS8VersionsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__getCS8VersionsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__getCS8VersionsResponse*)p = *(_ns1__getCS8VersionsResponse*)q;
		break;
	case SOAP_TYPE__ns1__getControllerParameters:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__getControllerParameters type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__getControllerParameters*)p = *(_ns1__getControllerParameters*)q;
		break;
	case SOAP_TYPE__ns1__getControllerParametersResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__getControllerParametersResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__getControllerParametersResponse*)p = *(_ns1__getControllerParametersResponse*)q;
		break;
	case SOAP_TYPE__ns1__getCS8Compatibility:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__getCS8Compatibility type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__getCS8Compatibility*)p = *(_ns1__getCS8Compatibility*)q;
		break;
	case SOAP_TYPE__ns1__getCS8CompatibilityResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__getCS8CompatibilityResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__getCS8CompatibilityResponse*)p = *(_ns1__getCS8CompatibilityResponse*)q;
		break;
	case SOAP_TYPE__ns1__login:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__login type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__login*)p = *(_ns1__login*)q;
		break;
	case SOAP_TYPE__ns1__loginResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__loginResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__loginResponse*)p = *(_ns1__loginResponse*)q;
		break;
	case SOAP_TYPE__ns1__logout:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__logout type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__logout*)p = *(_ns1__logout*)q;
		break;
	case SOAP_TYPE__ns1__logoutResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__logoutResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__logoutResponse*)p = *(_ns1__logoutResponse*)q;
		break;
	case SOAP_TYPE__ns1__getRobots:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__getRobots type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__getRobots*)p = *(_ns1__getRobots*)q;
		break;
	case SOAP_TYPE__ns1__getRobotsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__getRobotsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__getRobotsResponse*)p = *(_ns1__getRobotsResponse*)q;
		break;
	case SOAP_TYPE__ns1__getRobotJointPos:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__getRobotJointPos type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__getRobotJointPos*)p = *(_ns1__getRobotJointPos*)q;
		break;
	case SOAP_TYPE__ns1__getRobotJointPosResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__getRobotJointPosResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__getRobotJointPosResponse*)p = *(_ns1__getRobotJointPosResponse*)q;
		break;
	case SOAP_TYPE__ns1__getRobotJntCartPos:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__getRobotJntCartPos type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__getRobotJntCartPos*)p = *(_ns1__getRobotJntCartPos*)q;
		break;
	case SOAP_TYPE__ns1__getRobotJntCartPosResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__getRobotJntCartPosResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__getRobotJntCartPosResponse*)p = *(_ns1__getRobotJntCartPosResponse*)q;
		break;
	case SOAP_TYPE__ns1__setRobotJointPos:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__setRobotJointPos type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__setRobotJointPos*)p = *(_ns1__setRobotJointPos*)q;
		break;
	case SOAP_TYPE__ns1__setRobotPosResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__setRobotPosResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__setRobotPosResponse*)p = *(_ns1__setRobotPosResponse*)q;
		break;
	case SOAP_TYPE_ns5__JointPos:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__JointPos type=%d location=%p object=%p\n", t, p, q));
		*(ns5__JointPos*)p = *(ns5__JointPos*)q;
		break;
	case SOAP_TYPE_ns5__Parameters:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__Parameters type=%d location=%p object=%p\n", t, p, q));
		*(ns5__Parameters*)p = *(ns5__Parameters*)q;
		break;
	case SOAP_TYPE_ns5__Versions:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__Versions type=%d location=%p object=%p\n", t, p, q));
		*(ns5__Versions*)p = *(ns5__Versions*)q;
		break;
	case SOAP_TYPE_ns5__Robots:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__Robots type=%d location=%p object=%p\n", t, p, q));
		*(ns5__Robots*)p = *(ns5__Robots*)q;
		break;
	case SOAP_TYPE_ns5__VALApplications:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__VALApplications type=%d location=%p object=%p\n", t, p, q));
		*(ns5__VALApplications*)p = *(ns5__VALApplications*)q;
		break;
	case SOAP_TYPE_ns5__Records:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__Records type=%d location=%p object=%p\n", t, p, q));
		*(ns5__Records*)p = *(ns5__Records*)q;
		break;
	case SOAP_TYPE_ns5__SoapBreakpoints:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__SoapBreakpoints type=%d location=%p object=%p\n", t, p, q));
		*(ns5__SoapBreakpoints*)p = *(ns5__SoapBreakpoints*)q;
		break;
	case SOAP_TYPE_ns5__BreakpointsResponses:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__BreakpointsResponses type=%d location=%p object=%p\n", t, p, q));
		*(ns5__BreakpointsResponses*)p = *(ns5__BreakpointsResponses*)q;
		break;
	case SOAP_TYPE_ns5__SoapTasks:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__SoapTasks type=%d location=%p object=%p\n", t, p, q));
		*(ns5__SoapTasks*)p = *(ns5__SoapTasks*)q;
		break;
	case SOAP_TYPE_ns5__SoapCallStack:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__SoapCallStack type=%d location=%p object=%p\n", t, p, q));
		*(ns5__SoapCallStack*)p = *(ns5__SoapCallStack*)q;
		break;
	case SOAP_TYPE_ns5__SoapWatches:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__SoapWatches type=%d location=%p object=%p\n", t, p, q));
		*(ns5__SoapWatches*)p = *(ns5__SoapWatches*)q;
		break;
	case SOAP_TYPE_ns5__SoapPhysicalIoLinks:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__SoapPhysicalIoLinks type=%d location=%p object=%p\n", t, p, q));
		*(ns5__SoapPhysicalIoLinks*)p = *(ns5__SoapPhysicalIoLinks*)q;
		break;
	case SOAP_TYPE_ns5__SoapPhysicalIoValues:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__SoapPhysicalIoValues type=%d location=%p object=%p\n", t, p, q));
		*(ns5__SoapPhysicalIoValues*)p = *(ns5__SoapPhysicalIoValues*)q;
		break;
	case SOAP_TYPE_ns5__SoapPhysicalIosStates:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__SoapPhysicalIosStates type=%d location=%p object=%p\n", t, p, q));
		*(ns5__SoapPhysicalIosStates*)p = *(ns5__SoapPhysicalIosStates*)q;
		break;
	case SOAP_TYPE_ns5__SoapPhysicalIoResponses:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__SoapPhysicalIoResponses type=%d location=%p object=%p\n", t, p, q));
		*(ns5__SoapPhysicalIoResponses*)p = *(ns5__SoapPhysicalIoResponses*)q;
		break;
	case SOAP_TYPE_ns5__SoapPhysicalIoUnlockResponses:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__SoapPhysicalIoUnlockResponses type=%d location=%p object=%p\n", t, p, q));
		*(ns5__SoapPhysicalIoUnlockResponses*)p = *(ns5__SoapPhysicalIoUnlockResponses*)q;
		break;
	case SOAP_TYPE_ns5__SoapDhParametersArray:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns5__SoapDhParametersArray type=%d location=%p object=%p\n", t, p, q));
		*(ns5__SoapDhParametersArray*)p = *(ns5__SoapDhParametersArray*)q;
		break;
	case SOAP_TYPE_ns7__JointPos:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns7__JointPos type=%d location=%p object=%p\n", t, p, q));
		*(ns7__JointPos*)p = *(ns7__JointPos*)q;
		break;
	case SOAP_TYPE_ns7__Parameters:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns7__Parameters type=%d location=%p object=%p\n", t, p, q));
		*(ns7__Parameters*)p = *(ns7__Parameters*)q;
		break;
	case SOAP_TYPE_ns7__Versions:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns7__Versions type=%d location=%p object=%p\n", t, p, q));
		*(ns7__Versions*)p = *(ns7__Versions*)q;
		break;
	case SOAP_TYPE_ns7__Robots:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns7__Robots type=%d location=%p object=%p\n", t, p, q));
		*(ns7__Robots*)p = *(ns7__Robots*)q;
		break;
	case SOAP_TYPE_ns7__VALApplications:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns7__VALApplications type=%d location=%p object=%p\n", t, p, q));
		*(ns7__VALApplications*)p = *(ns7__VALApplications*)q;
		break;
	case SOAP_TYPE_ns7__Records:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns7__Records type=%d location=%p object=%p\n", t, p, q));
		*(ns7__Records*)p = *(ns7__Records*)q;
		break;
	case SOAP_TYPE_ns7__SoapProgramLine:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns7__SoapProgramLine type=%d location=%p object=%p\n", t, p, q));
		*(ns7__SoapProgramLine*)p = *(ns7__SoapProgramLine*)q;
		break;
	case SOAP_TYPE_ns7__SoapBreakpoint:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns7__SoapBreakpoint type=%d location=%p object=%p\n", t, p, q));
		*(ns7__SoapBreakpoint*)p = *(ns7__SoapBreakpoint*)q;
		break;
	case SOAP_TYPE_ns7__SoapBreakpoints:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns7__SoapBreakpoints type=%d location=%p object=%p\n", t, p, q));
		*(ns7__SoapBreakpoints*)p = *(ns7__SoapBreakpoints*)q;
		break;
	case SOAP_TYPE_ns7__BreakpointsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns7__BreakpointsResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns7__BreakpointsResponse*)p = *(ns7__BreakpointsResponse*)q;
		break;
	case SOAP_TYPE_ns7__BreakpointsResponses:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns7__BreakpointsResponses type=%d location=%p object=%p\n", t, p, q));
		*(ns7__BreakpointsResponses*)p = *(ns7__BreakpointsResponses*)q;
		break;
	case SOAP_TYPE_ns7__MimeData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns7__MimeData type=%d location=%p object=%p\n", t, p, q));
		*(ns7__MimeData*)p = *(ns7__MimeData*)q;
		break;
	case SOAP_TYPE_ns7__SoapTask:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns7__SoapTask type=%d location=%p object=%p\n", t, p, q));
		*(ns7__SoapTask*)p = *(ns7__SoapTask*)q;
		break;
	case SOAP_TYPE_ns7__SoapTasks:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns7__SoapTasks type=%d location=%p object=%p\n", t, p, q));
		*(ns7__SoapTasks*)p = *(ns7__SoapTasks*)q;
		break;
	case SOAP_TYPE_ns7__SoapInstruction:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns7__SoapInstruction type=%d location=%p object=%p\n", t, p, q));
		*(ns7__SoapInstruction*)p = *(ns7__SoapInstruction*)q;
		break;
	case SOAP_TYPE_ns7__SoapStackFrameAbstract:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns7__SoapStackFrameAbstract type=%d location=%p object=%p\n", t, p, q));
		*(ns7__SoapStackFrameAbstract*)p = *(ns7__SoapStackFrameAbstract*)q;
		break;
	case SOAP_TYPE_ns7__SoapCallStack:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns7__SoapCallStack type=%d location=%p object=%p\n", t, p, q));
		*(ns7__SoapCallStack*)p = *(ns7__SoapCallStack*)q;
		break;
	case SOAP_TYPE_ns7__SoapData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns7__SoapData type=%d location=%p object=%p\n", t, p, q));
		*(ns7__SoapData*)p = *(ns7__SoapData*)q;
		break;
	case SOAP_TYPE_ns7__SoapWatches:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns7__SoapWatches type=%d location=%p object=%p\n", t, p, q));
		*(ns7__SoapWatches*)p = *(ns7__SoapWatches*)q;
		break;
	case SOAP_TYPE_ns7__SoapPhysicalIoLinks:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns7__SoapPhysicalIoLinks type=%d location=%p object=%p\n", t, p, q));
		*(ns7__SoapPhysicalIoLinks*)p = *(ns7__SoapPhysicalIoLinks*)q;
		break;
	case SOAP_TYPE_ns7__SoapPhysicalDioAttrib:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns7__SoapPhysicalDioAttrib type=%d location=%p object=%p\n", t, p, q));
		*(ns7__SoapPhysicalDioAttrib*)p = *(ns7__SoapPhysicalDioAttrib*)q;
		break;
	case SOAP_TYPE_ns7__SoapPhysicalAioAttrib:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns7__SoapPhysicalAioAttrib type=%d location=%p object=%p\n", t, p, q));
		*(ns7__SoapPhysicalAioAttrib*)p = *(ns7__SoapPhysicalAioAttrib*)q;
		break;
	case SOAP_TYPE__ns7__union_SoapPhysicalIoAttrib:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy union _ns7__union_SoapPhysicalIoAttrib type=%d location=%p object=%p\n", t, p, q));
		*(union _ns7__union_SoapPhysicalIoAttrib*)p = *(union _ns7__union_SoapPhysicalIoAttrib*)q;
		break;
	case SOAP_TYPE_ns7__SoapPhysicalIoAttrib:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns7__SoapPhysicalIoAttrib type=%d location=%p object=%p\n", t, p, q));
		*(ns7__SoapPhysicalIoAttrib*)p = *(ns7__SoapPhysicalIoAttrib*)q;
		break;
	case SOAP_TYPE_ns7__SoapPhysicalIoState:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns7__SoapPhysicalIoState type=%d location=%p object=%p\n", t, p, q));
		*(ns7__SoapPhysicalIoState*)p = *(ns7__SoapPhysicalIoState*)q;
		break;
	case SOAP_TYPE_ns7__SoapPhysicalIoValues:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns7__SoapPhysicalIoValues type=%d location=%p object=%p\n", t, p, q));
		*(ns7__SoapPhysicalIoValues*)p = *(ns7__SoapPhysicalIoValues*)q;
		break;
	case SOAP_TYPE_ns7__SoapPhysicalIosStates:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns7__SoapPhysicalIosStates type=%d location=%p object=%p\n", t, p, q));
		*(ns7__SoapPhysicalIosStates*)p = *(ns7__SoapPhysicalIosStates*)q;
		break;
	case SOAP_TYPE_ns7__SoapPhysicalIoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns7__SoapPhysicalIoResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns7__SoapPhysicalIoResponse*)p = *(ns7__SoapPhysicalIoResponse*)q;
		break;
	case SOAP_TYPE_ns7__SoapPhysicalIoResponses:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns7__SoapPhysicalIoResponses type=%d location=%p object=%p\n", t, p, q));
		*(ns7__SoapPhysicalIoResponses*)p = *(ns7__SoapPhysicalIoResponses*)q;
		break;
	case SOAP_TYPE_ns7__SoapPhysicalIoUnlockResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns7__SoapPhysicalIoUnlockResponse type=%d location=%p object=%p\n", t, p, q));
		*(ns7__SoapPhysicalIoUnlockResponse*)p = *(ns7__SoapPhysicalIoUnlockResponse*)q;
		break;
	case SOAP_TYPE_ns7__SoapPhysicalIoUnlockResponses:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns7__SoapPhysicalIoUnlockResponses type=%d location=%p object=%p\n", t, p, q));
		*(ns7__SoapPhysicalIoUnlockResponses*)p = *(ns7__SoapPhysicalIoUnlockResponses*)q;
		break;
	case SOAP_TYPE_ns7__SoapDhParameters:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns7__SoapDhParameters type=%d location=%p object=%p\n", t, p, q));
		*(ns7__SoapDhParameters*)p = *(ns7__SoapDhParameters*)q;
		break;
	case SOAP_TYPE_ns7__SoapDhParametersArray:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns7__SoapDhParametersArray type=%d location=%p object=%p\n", t, p, q));
		*(ns7__SoapDhParametersArray*)p = *(ns7__SoapDhParametersArray*)q;
		break;
	case SOAP_TYPE__ns7__setBreakpoints:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__setBreakpoints type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__setBreakpoints*)p = *(_ns7__setBreakpoints*)q;
		break;
	case SOAP_TYPE__ns7__setBreakpointsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__setBreakpointsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__setBreakpointsResponse*)p = *(_ns7__setBreakpointsResponse*)q;
		break;
	case SOAP_TYPE__ns7__getBreakpoints:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__getBreakpoints type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__getBreakpoints*)p = *(_ns7__getBreakpoints*)q;
		break;
	case SOAP_TYPE__ns7__getBreakpointsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__getBreakpointsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__getBreakpointsResponse*)p = *(_ns7__getBreakpointsResponse*)q;
		break;
	case SOAP_TYPE__ns7__clearBreakpoints:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__clearBreakpoints type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__clearBreakpoints*)p = *(_ns7__clearBreakpoints*)q;
		break;
	case SOAP_TYPE__ns7__clearBreakpointsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__clearBreakpointsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__clearBreakpointsResponse*)p = *(_ns7__clearBreakpointsResponse*)q;
		break;
	case SOAP_TYPE__ns7__clearAllBreakpoints:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__clearAllBreakpoints type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__clearAllBreakpoints*)p = *(_ns7__clearAllBreakpoints*)q;
		break;
	case SOAP_TYPE__ns7__clearAllBreakpointsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__clearAllBreakpointsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__clearAllBreakpointsResponse*)p = *(_ns7__clearAllBreakpointsResponse*)q;
		break;
	case SOAP_TYPE__ns7__getTasks:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__getTasks type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__getTasks*)p = *(_ns7__getTasks*)q;
		break;
	case SOAP_TYPE__ns7__getTasksResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__getTasksResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__getTasksResponse*)p = *(_ns7__getTasksResponse*)q;
		break;
	case SOAP_TYPE__ns7__taskSuspend:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__taskSuspend type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__taskSuspend*)p = *(_ns7__taskSuspend*)q;
		break;
	case SOAP_TYPE__ns7__taskSuspendResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__taskSuspendResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__taskSuspendResponse*)p = *(_ns7__taskSuspendResponse*)q;
		break;
	case SOAP_TYPE__ns7__taskResume:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__taskResume type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__taskResume*)p = *(_ns7__taskResume*)q;
		break;
	case SOAP_TYPE__ns7__taskResumeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__taskResumeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__taskResumeResponse*)p = *(_ns7__taskResumeResponse*)q;
		break;
	case SOAP_TYPE__ns7__taskKill:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__taskKill type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__taskKill*)p = *(_ns7__taskKill*)q;
		break;
	case SOAP_TYPE__ns7__taskKillResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__taskKillResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__taskKillResponse*)p = *(_ns7__taskKillResponse*)q;
		break;
	case SOAP_TYPE__ns7__taskStep:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__taskStep type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__taskStep*)p = *(_ns7__taskStep*)q;
		break;
	case SOAP_TYPE__ns7__taskStepResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__taskStepResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__taskStepResponse*)p = *(_ns7__taskStepResponse*)q;
		break;
	case SOAP_TYPE__ns7__subscribeToControllerEvents:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__subscribeToControllerEvents type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__subscribeToControllerEvents*)p = *(_ns7__subscribeToControllerEvents*)q;
		break;
	case SOAP_TYPE__ns7__subscribeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__subscribeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__subscribeResponse*)p = *(_ns7__subscribeResponse*)q;
		break;
	case SOAP_TYPE__ns7__unsubscribeToControllerEvents:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__unsubscribeToControllerEvents type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__unsubscribeToControllerEvents*)p = *(_ns7__unsubscribeToControllerEvents*)q;
		break;
	case SOAP_TYPE__ns7__unsubscribeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__unsubscribeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__unsubscribeResponse*)p = *(_ns7__unsubscribeResponse*)q;
		break;
	case SOAP_TYPE__ns7__getCallStack:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__getCallStack type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__getCallStack*)p = *(_ns7__getCallStack*)q;
		break;
	case SOAP_TYPE__ns7__getCallStackResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__getCallStackResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__getCallStackResponse*)p = *(_ns7__getCallStackResponse*)q;
		break;
	case SOAP_TYPE__ns7__getStackFrame:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__getStackFrame type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__getStackFrame*)p = *(_ns7__getStackFrame*)q;
		break;
	case SOAP_TYPE__ns7__getStackFrameResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__getStackFrameResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__getStackFrameResponse*)p = *(_ns7__getStackFrameResponse*)q;
		break;
	case SOAP_TYPE__ns7__getWatches:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__getWatches type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__getWatches*)p = *(_ns7__getWatches*)q;
		break;
	case SOAP_TYPE__ns7__getWatchResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__getWatchResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__getWatchResponse*)p = *(_ns7__getWatchResponse*)q;
		break;
	case SOAP_TYPE__ns7__execVal3:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__execVal3 type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__execVal3*)p = *(_ns7__execVal3*)q;
		break;
	case SOAP_TYPE__ns7__execVal3Response:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__execVal3Response type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__execVal3Response*)p = *(_ns7__execVal3Response*)q;
		break;
	case SOAP_TYPE__ns7__setProjectAsModified:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__setProjectAsModified type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__setProjectAsModified*)p = *(_ns7__setProjectAsModified*)q;
		break;
	case SOAP_TYPE__ns7__setProjectAsModifiedResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__setProjectAsModifiedResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__setProjectAsModifiedResponse*)p = *(_ns7__setProjectAsModifiedResponse*)q;
		break;
	case SOAP_TYPE__ns7__setCurrentInstruction:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__setCurrentInstruction type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__setCurrentInstruction*)p = *(_ns7__setCurrentInstruction*)q;
		break;
	case SOAP_TYPE__ns7__setCurrentInstructionResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__setCurrentInstructionResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__setCurrentInstructionResponse*)p = *(_ns7__setCurrentInstructionResponse*)q;
		break;
	case SOAP_TYPE__ns7__replaceLine:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__replaceLine type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__replaceLine*)p = *(_ns7__replaceLine*)q;
		break;
	case SOAP_TYPE__ns7__replaceLineResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__replaceLineResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__replaceLineResponse*)p = *(_ns7__replaceLineResponse*)q;
		break;
	case SOAP_TYPE__ns7__readIos:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__readIos type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__readIos*)p = *(_ns7__readIos*)q;
		break;
	case SOAP_TYPE__ns7__readIosResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__readIosResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__readIosResponse*)p = *(_ns7__readIosResponse*)q;
		break;
	case SOAP_TYPE__ns7__writeIos:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__writeIos type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__writeIos*)p = *(_ns7__writeIos*)q;
		break;
	case SOAP_TYPE__ns7__writeIosResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__writeIosResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__writeIosResponse*)p = *(_ns7__writeIosResponse*)q;
		break;
	case SOAP_TYPE__ns7__lockIos:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__lockIos type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__lockIos*)p = *(_ns7__lockIos*)q;
		break;
	case SOAP_TYPE__ns7__lockIosResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__lockIosResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__lockIosResponse*)p = *(_ns7__lockIosResponse*)q;
		break;
	case SOAP_TYPE__ns7__unlockIos:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__unlockIos type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__unlockIos*)p = *(_ns7__unlockIos*)q;
		break;
	case SOAP_TYPE__ns7__unlockIosResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__unlockIosResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__unlockIosResponse*)p = *(_ns7__unlockIosResponse*)q;
		break;
	case SOAP_TYPE__ns7__lockAllIos:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__lockAllIos type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__lockAllIos*)p = *(_ns7__lockAllIos*)q;
		break;
	case SOAP_TYPE__ns7__SoapAllPhysicalIoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__SoapAllPhysicalIoResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__SoapAllPhysicalIoResponse*)p = *(_ns7__SoapAllPhysicalIoResponse*)q;
		break;
	case SOAP_TYPE__ns7__unlockAllIos:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__unlockAllIos type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__unlockAllIos*)p = *(_ns7__unlockAllIos*)q;
		break;
	case SOAP_TYPE__ns7__getAllPhysicalIos:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__getAllPhysicalIos type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__getAllPhysicalIos*)p = *(_ns7__getAllPhysicalIos*)q;
		break;
	case SOAP_TYPE__ns7__getAllPhysicalIosResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__getAllPhysicalIosResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__getAllPhysicalIosResponse*)p = *(_ns7__getAllPhysicalIosResponse*)q;
		break;
	case SOAP_TYPE__ns7__getRobotDhParameters:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__getRobotDhParameters type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__getRobotDhParameters*)p = *(_ns7__getRobotDhParameters*)q;
		break;
	case SOAP_TYPE__ns7__SoapRobotDhParameters:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__SoapRobotDhParameters type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__SoapRobotDhParameters*)p = *(_ns7__SoapRobotDhParameters*)q;
		break;
	case SOAP_TYPE__ns7__getProject:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__getProject type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__getProject*)p = *(_ns7__getProject*)q;
		break;
	case SOAP_TYPE__ns7__getProjectResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns7__getProjectResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns7__getProjectResponse*)p = *(_ns7__getProjectResponse*)q;
		break;
	case SOAP_TYPE_ns3__Include:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns3__Include type=%d location=%p object=%p\n", t, p, q));
		*(ns3__Include*)p = *(ns3__Include*)q;
		break;
	case SOAP_TYPE_ns2__VALApplication:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__VALApplication type=%d location=%p object=%p\n", t, p, q));
		*(ns2__VALApplication*)p = *(ns2__VALApplication*)q;
		break;
	case SOAP_TYPE_ns2__VALApplications:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__VALApplications type=%d location=%p object=%p\n", t, p, q));
		*(ns2__VALApplications*)p = *(ns2__VALApplications*)q;
		break;
	case SOAP_TYPE_ns2__Data:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__Data type=%d location=%p object=%p\n", t, p, q));
		*(ns2__Data*)p = *(ns2__Data*)q;
		break;
	case SOAP_TYPE_ns2__Records:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__Records type=%d location=%p object=%p\n", t, p, q));
		*(ns2__Records*)p = *(ns2__Records*)q;
		break;
	case SOAP_TYPE_ns2__JointRange:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__JointRange type=%d location=%p object=%p\n", t, p, q));
		*(ns2__JointRange*)p = *(ns2__JointRange*)q;
		break;
	case SOAP_TYPE__ns2__getApplications:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns2__getApplications type=%d location=%p object=%p\n", t, p, q));
		*(_ns2__getApplications*)p = *(_ns2__getApplications*)q;
		break;
	case SOAP_TYPE__ns2__getApplicationsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns2__getApplicationsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns2__getApplicationsResponse*)p = *(_ns2__getApplicationsResponse*)q;
		break;
	case SOAP_TYPE__ns2__getApplicationDatas:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns2__getApplicationDatas type=%d location=%p object=%p\n", t, p, q));
		*(_ns2__getApplicationDatas*)p = *(_ns2__getApplicationDatas*)q;
		break;
	case SOAP_TYPE__ns2__getApplicationDatasResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns2__getApplicationDatasResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns2__getApplicationDatasResponse*)p = *(_ns2__getApplicationDatasResponse*)q;
		break;
	case SOAP_TYPE__ns2__getRecords:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns2__getRecords type=%d location=%p object=%p\n", t, p, q));
		*(_ns2__getRecords*)p = *(_ns2__getRecords*)q;
		break;
	case SOAP_TYPE__ns2__getRecordsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns2__getRecordsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns2__getRecordsResponse*)p = *(_ns2__getRecordsResponse*)q;
		break;
	case SOAP_TYPE__ns2__getRecord:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns2__getRecord type=%d location=%p object=%p\n", t, p, q));
		*(_ns2__getRecord*)p = *(_ns2__getRecord*)q;
		break;
	case SOAP_TYPE__ns2__getRecordResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns2__getRecordResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns2__getRecordResponse*)p = *(_ns2__getRecordResponse*)q;
		break;
	case SOAP_TYPE__ns2__getJointRange:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns2__getJointRange type=%d location=%p object=%p\n", t, p, q));
		*(_ns2__getJointRange*)p = *(_ns2__getJointRange*)q;
		break;
	case SOAP_TYPE__ns2__getJointRangeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns2__getJointRangeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns2__getJointRangeResponse*)p = *(_ns2__getJointRangeResponse*)q;
		break;
	case SOAP_TYPE_ns4__base64Binary:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns4__base64Binary type=%d location=%p object=%p\n", t, p, q));
		*(ns4__base64Binary*)p = *(ns4__base64Binary*)q;
		break;
	case SOAP_TYPE_ns4__hexBinary:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns4__hexBinary type=%d location=%p object=%p\n", t, p, q));
		*(ns4__hexBinary*)p = *(ns4__hexBinary*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Header type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Detail type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
		break;
#endif
	case SOAP_TYPE___ns1__getSoapServerVersion:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getSoapServerVersion type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getSoapServerVersion*)p = *(struct __ns1__getSoapServerVersion*)q;
		break;
	case SOAP_TYPE___ns1__findServer:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__findServer type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__findServer*)p = *(struct __ns1__findServer*)q;
		break;
	case SOAP_TYPE___ns1__ping:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ping type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ping*)p = *(struct __ns1__ping*)q;
		break;
	case SOAP_TYPE___ns1__getCS8Versions:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getCS8Versions type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getCS8Versions*)p = *(struct __ns1__getCS8Versions*)q;
		break;
	case SOAP_TYPE___ns1__getControllerParameters:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getControllerParameters type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getControllerParameters*)p = *(struct __ns1__getControllerParameters*)q;
		break;
	case SOAP_TYPE___ns1__getCS8Compatibility:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getCS8Compatibility type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getCS8Compatibility*)p = *(struct __ns1__getCS8Compatibility*)q;
		break;
	case SOAP_TYPE___ns1__login:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__login type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__login*)p = *(struct __ns1__login*)q;
		break;
	case SOAP_TYPE___ns1__logout:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__logout type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__logout*)p = *(struct __ns1__logout*)q;
		break;
	case SOAP_TYPE___ns1__getRobots:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getRobots type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getRobots*)p = *(struct __ns1__getRobots*)q;
		break;
	case SOAP_TYPE___ns1__getRobotJointPos:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getRobotJointPos type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getRobotJointPos*)p = *(struct __ns1__getRobotJointPos*)q;
		break;
	case SOAP_TYPE___ns1__getRobotJntCartPos:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getRobotJntCartPos type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getRobotJntCartPos*)p = *(struct __ns1__getRobotJntCartPos*)q;
		break;
	case SOAP_TYPE___ns1__setRobotJointPos:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__setRobotJointPos type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__setRobotJointPos*)p = *(struct __ns1__setRobotJointPos*)q;
		break;
	case SOAP_TYPE___ns7__setBreakpoints:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns7__setBreakpoints type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns7__setBreakpoints*)p = *(struct __ns7__setBreakpoints*)q;
		break;
	case SOAP_TYPE___ns7__getBreakpoints:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns7__getBreakpoints type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns7__getBreakpoints*)p = *(struct __ns7__getBreakpoints*)q;
		break;
	case SOAP_TYPE___ns7__clearBreakpoints:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns7__clearBreakpoints type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns7__clearBreakpoints*)p = *(struct __ns7__clearBreakpoints*)q;
		break;
	case SOAP_TYPE___ns7__clearAllBreakpoints:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns7__clearAllBreakpoints type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns7__clearAllBreakpoints*)p = *(struct __ns7__clearAllBreakpoints*)q;
		break;
	case SOAP_TYPE___ns7__getTasks:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns7__getTasks type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns7__getTasks*)p = *(struct __ns7__getTasks*)q;
		break;
	case SOAP_TYPE___ns7__taskSuspend:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns7__taskSuspend type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns7__taskSuspend*)p = *(struct __ns7__taskSuspend*)q;
		break;
	case SOAP_TYPE___ns7__taskResume:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns7__taskResume type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns7__taskResume*)p = *(struct __ns7__taskResume*)q;
		break;
	case SOAP_TYPE___ns7__taskKill:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns7__taskKill type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns7__taskKill*)p = *(struct __ns7__taskKill*)q;
		break;
	case SOAP_TYPE___ns7__taskStep:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns7__taskStep type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns7__taskStep*)p = *(struct __ns7__taskStep*)q;
		break;
	case SOAP_TYPE___ns7__subscribeToControllerEvents:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns7__subscribeToControllerEvents type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns7__subscribeToControllerEvents*)p = *(struct __ns7__subscribeToControllerEvents*)q;
		break;
	case SOAP_TYPE___ns7__unsubscribeToControllerEvents:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns7__unsubscribeToControllerEvents type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns7__unsubscribeToControllerEvents*)p = *(struct __ns7__unsubscribeToControllerEvents*)q;
		break;
	case SOAP_TYPE___ns7__getCallStack:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns7__getCallStack type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns7__getCallStack*)p = *(struct __ns7__getCallStack*)q;
		break;
	case SOAP_TYPE___ns7__getStackFrame:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns7__getStackFrame type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns7__getStackFrame*)p = *(struct __ns7__getStackFrame*)q;
		break;
	case SOAP_TYPE___ns7__getWatches:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns7__getWatches type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns7__getWatches*)p = *(struct __ns7__getWatches*)q;
		break;
	case SOAP_TYPE___ns7__execVal3:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns7__execVal3 type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns7__execVal3*)p = *(struct __ns7__execVal3*)q;
		break;
	case SOAP_TYPE___ns7__setProjectAsModified:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns7__setProjectAsModified type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns7__setProjectAsModified*)p = *(struct __ns7__setProjectAsModified*)q;
		break;
	case SOAP_TYPE___ns7__setCurrentInstruction:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns7__setCurrentInstruction type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns7__setCurrentInstruction*)p = *(struct __ns7__setCurrentInstruction*)q;
		break;
	case SOAP_TYPE___ns7__replaceLine:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns7__replaceLine type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns7__replaceLine*)p = *(struct __ns7__replaceLine*)q;
		break;
	case SOAP_TYPE___ns7__readIos:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns7__readIos type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns7__readIos*)p = *(struct __ns7__readIos*)q;
		break;
	case SOAP_TYPE___ns7__writeIos:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns7__writeIos type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns7__writeIos*)p = *(struct __ns7__writeIos*)q;
		break;
	case SOAP_TYPE___ns7__lockIos:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns7__lockIos type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns7__lockIos*)p = *(struct __ns7__lockIos*)q;
		break;
	case SOAP_TYPE___ns7__unlockIos:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns7__unlockIos type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns7__unlockIos*)p = *(struct __ns7__unlockIos*)q;
		break;
	case SOAP_TYPE___ns7__lockAllIos:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns7__lockAllIos type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns7__lockAllIos*)p = *(struct __ns7__lockAllIos*)q;
		break;
	case SOAP_TYPE___ns7__unlockAllIos:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns7__unlockAllIos type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns7__unlockAllIos*)p = *(struct __ns7__unlockAllIos*)q;
		break;
	case SOAP_TYPE___ns7__getAllPhysicalIos:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns7__getAllPhysicalIos type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns7__getAllPhysicalIos*)p = *(struct __ns7__getAllPhysicalIos*)q;
		break;
	case SOAP_TYPE___ns7__getRobotDhParameters:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns7__getRobotDhParameters type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns7__getRobotDhParameters*)p = *(struct __ns7__getRobotDhParameters*)q;
		break;
	case SOAP_TYPE___ns7__getProject:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns7__getProject type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns7__getProject*)p = *(struct __ns7__getProject*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Code type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Reason type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Fault type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
		break;
#endif
	case SOAP_TYPE_xsd__anyURI:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type = %d in %d\n", t, tt));
	}
}
#ifdef WIN32
#pragma warning(pop)
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return a;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_new_byte(struct soap *soap, int n)
{
	char *a = static_cast<char *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char)));
	for (char *p = a; p && n--; ++p)
		soap_default_byte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag ? tag : "byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SessionId(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_ns1__SessionId);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_ns1__SessionId(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_ns1__SessionId);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SessionId(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SessionId(soap, tag ? tag : "ns1:SessionId", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_ns1__SessionId(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SessionId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return a;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_new_int(struct soap *soap, int n)
{
	int *a = static_cast<int *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(int)));
	for (int *p = a; p && n--; ++p)
		soap_default_int(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{
	a = soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
	return a;
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_new_double(struct soap *soap, int n)
{
	double *a = static_cast<double *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(double)));
	for (double *p = a; p && n--; ++p)
		soap_default_double(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	if (soap_out_double(soap, tag ? tag : "double", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{
	a = soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
	return a;
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_new_unsignedByte(struct soap *soap, int n)
{
	unsigned char *a = static_cast<unsigned char *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(unsigned char)));
	for (unsigned char *p = a; p && n--; ++p)
		soap_default_unsignedByte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	if (soap_out_unsignedByte(soap, tag ? tag : "unsignedByte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{
	a = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
	return a;
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_new_unsignedInt(struct soap *soap, int n)
{
	unsigned int *a = static_cast<unsigned int *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(unsigned int)));
	for (unsigned int *p = a; p && n--; ++p)
		soap_default_unsignedInt(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	if (soap_out_unsignedInt(soap, tag ? tag : "unsignedInt", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (LONG64)false, "false" },
	{ (LONG64)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
	return soap_code_str(soap_codes_bool, n != 0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2bool(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_new_bool(struct soap *soap, int n)
{
	bool *a = static_cast<bool *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(bool)));
	for (bool *p = a; p && n--; ++p)
		soap_default_bool(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	if (soap_out_bool(soap, tag ? tag : "boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns7__replaceLineReturnCode[] =
{	{ (LONG64)ns7__replaceLineReturnCode__RLI_NO_ERROR, "RLI-NO-ERROR" },
	{ (LONG64)ns7__replaceLineReturnCode__RLI_PROGRAM_IN_EDITION, "RLI-PROGRAM-IN-EDITION" },
	{ (LONG64)ns7__replaceLineReturnCode__RLI_COMPILATION_ERROR, "RLI-COMPILATION-ERROR" },
	{ (LONG64)ns7__replaceLineReturnCode__RLI_INSTRUCTION_BUSY, "RLI-INSTRUCTION-BUSY" },
	{ (LONG64)ns7__replaceLineReturnCode__RLI_INSTRUCTION_CONTROL, "RLI-INSTRUCTION-CONTROL" },
	{ (LONG64)ns7__replaceLineReturnCode__RLI_UNKNOW_RET_CODE, "RLI-UNKNOW-RET-CODE" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns7__replaceLineReturnCode2s(struct soap *soap, enum ns7__replaceLineReturnCode n)
{	const char *s = soap_code_str(soap_codes_ns7__replaceLineReturnCode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__replaceLineReturnCode(struct soap *soap, const char *tag, int id, const enum ns7__replaceLineReturnCode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__replaceLineReturnCode), type) || soap_send(soap, soap_ns7__replaceLineReturnCode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns7__replaceLineReturnCode(struct soap *soap, const char *s, enum ns7__replaceLineReturnCode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns7__replaceLineReturnCode, s);
	if (map)
		*a = (enum ns7__replaceLineReturnCode)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 5)
			return soap->error = SOAP_TYPE;
		*a = (enum ns7__replaceLineReturnCode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns7__replaceLineReturnCode * SOAP_FMAC4 soap_in_ns7__replaceLineReturnCode(struct soap *soap, const char *tag, enum ns7__replaceLineReturnCode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns7__replaceLineReturnCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__replaceLineReturnCode, sizeof(enum ns7__replaceLineReturnCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns7__replaceLineReturnCode(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns7__replaceLineReturnCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__replaceLineReturnCode, SOAP_TYPE_ns7__replaceLineReturnCode, sizeof(enum ns7__replaceLineReturnCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns7__replaceLineReturnCode * SOAP_FMAC4 soap_new_ns7__replaceLineReturnCode(struct soap *soap, int n)
{
	enum ns7__replaceLineReturnCode *a = static_cast<enum ns7__replaceLineReturnCode *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns7__replaceLineReturnCode)));
	for (enum ns7__replaceLineReturnCode *p = a; p && n--; ++p)
		soap_default_ns7__replaceLineReturnCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns7__replaceLineReturnCode(struct soap *soap, const enum ns7__replaceLineReturnCode *a, const char *tag, const char *type)
{
	if (soap_out_ns7__replaceLineReturnCode(soap, tag ? tag : "ns7:replaceLineReturnCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns7__replaceLineReturnCode * SOAP_FMAC4 soap_get_ns7__replaceLineReturnCode(struct soap *soap, enum ns7__replaceLineReturnCode *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__replaceLineReturnCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns7__execVal3ReturnCode[] =
{	{ (LONG64)ns7__execVal3ReturnCode__EXV_NO_ERROR, "EXV-NO-ERROR" },
	{ (LONG64)ns7__execVal3ReturnCode__EXV_COMPILATION_ERROR, "EXV-COMPILATION-ERROR" },
	{ (LONG64)ns7__execVal3ReturnCode__EXV_RUNTIME_ERROR, "EXV-RUNTIME-ERROR" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns7__execVal3ReturnCode2s(struct soap *soap, enum ns7__execVal3ReturnCode n)
{	const char *s = soap_code_str(soap_codes_ns7__execVal3ReturnCode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__execVal3ReturnCode(struct soap *soap, const char *tag, int id, const enum ns7__execVal3ReturnCode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__execVal3ReturnCode), type) || soap_send(soap, soap_ns7__execVal3ReturnCode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns7__execVal3ReturnCode(struct soap *soap, const char *s, enum ns7__execVal3ReturnCode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns7__execVal3ReturnCode, s);
	if (map)
		*a = (enum ns7__execVal3ReturnCode)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum ns7__execVal3ReturnCode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns7__execVal3ReturnCode * SOAP_FMAC4 soap_in_ns7__execVal3ReturnCode(struct soap *soap, const char *tag, enum ns7__execVal3ReturnCode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns7__execVal3ReturnCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__execVal3ReturnCode, sizeof(enum ns7__execVal3ReturnCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns7__execVal3ReturnCode(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns7__execVal3ReturnCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__execVal3ReturnCode, SOAP_TYPE_ns7__execVal3ReturnCode, sizeof(enum ns7__execVal3ReturnCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns7__execVal3ReturnCode * SOAP_FMAC4 soap_new_ns7__execVal3ReturnCode(struct soap *soap, int n)
{
	enum ns7__execVal3ReturnCode *a = static_cast<enum ns7__execVal3ReturnCode *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns7__execVal3ReturnCode)));
	for (enum ns7__execVal3ReturnCode *p = a; p && n--; ++p)
		soap_default_ns7__execVal3ReturnCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns7__execVal3ReturnCode(struct soap *soap, const enum ns7__execVal3ReturnCode *a, const char *tag, const char *type)
{
	if (soap_out_ns7__execVal3ReturnCode(soap, tag ? tag : "ns7:execVal3ReturnCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns7__execVal3ReturnCode * SOAP_FMAC4 soap_get_ns7__execVal3ReturnCode(struct soap *soap, enum ns7__execVal3ReturnCode *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__execVal3ReturnCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns7__SoapPhysicalIoEnumState[] =
{	{ (LONG64)ns7__SoapPhysicalIoEnumState__IO_DEFINED, "IO-DEFINED" },
	{ (LONG64)ns7__SoapPhysicalIoEnumState__IO_UNDEFINED, "IO-UNDEFINED" },
	{ (LONG64)ns7__SoapPhysicalIoEnumState__IO_INVALID_NAME, "IO-INVALID-NAME" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns7__SoapPhysicalIoEnumState2s(struct soap *soap, enum ns7__SoapPhysicalIoEnumState n)
{	const char *s = soap_code_str(soap_codes_ns7__SoapPhysicalIoEnumState, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__SoapPhysicalIoEnumState(struct soap *soap, const char *tag, int id, const enum ns7__SoapPhysicalIoEnumState *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__SoapPhysicalIoEnumState), type) || soap_send(soap, soap_ns7__SoapPhysicalIoEnumState2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns7__SoapPhysicalIoEnumState(struct soap *soap, const char *s, enum ns7__SoapPhysicalIoEnumState *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns7__SoapPhysicalIoEnumState, s);
	if (map)
		*a = (enum ns7__SoapPhysicalIoEnumState)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum ns7__SoapPhysicalIoEnumState)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns7__SoapPhysicalIoEnumState * SOAP_FMAC4 soap_in_ns7__SoapPhysicalIoEnumState(struct soap *soap, const char *tag, enum ns7__SoapPhysicalIoEnumState *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns7__SoapPhysicalIoEnumState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__SoapPhysicalIoEnumState, sizeof(enum ns7__SoapPhysicalIoEnumState), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns7__SoapPhysicalIoEnumState(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns7__SoapPhysicalIoEnumState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__SoapPhysicalIoEnumState, SOAP_TYPE_ns7__SoapPhysicalIoEnumState, sizeof(enum ns7__SoapPhysicalIoEnumState), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns7__SoapPhysicalIoEnumState * SOAP_FMAC4 soap_new_ns7__SoapPhysicalIoEnumState(struct soap *soap, int n)
{
	enum ns7__SoapPhysicalIoEnumState *a = static_cast<enum ns7__SoapPhysicalIoEnumState *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns7__SoapPhysicalIoEnumState)));
	for (enum ns7__SoapPhysicalIoEnumState *p = a; p && n--; ++p)
		soap_default_ns7__SoapPhysicalIoEnumState(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns7__SoapPhysicalIoEnumState(struct soap *soap, const enum ns7__SoapPhysicalIoEnumState *a, const char *tag, const char *type)
{
	if (soap_out_ns7__SoapPhysicalIoEnumState(soap, tag ? tag : "ns7:SoapPhysicalIoEnumState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns7__SoapPhysicalIoEnumState * SOAP_FMAC4 soap_get_ns7__SoapPhysicalIoEnumState(struct soap *soap, enum ns7__SoapPhysicalIoEnumState *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__SoapPhysicalIoEnumState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns7__SoapTaskStep[] =
{	{ (LONG64)ns7__SoapTaskStep__TASKSTEP_INTO, "TASKSTEP-INTO" },
	{ (LONG64)ns7__SoapTaskStep__TASKSTEP_OVER, "TASKSTEP-OVER" },
	{ (LONG64)ns7__SoapTaskStep__TASKSTEP_OUT, "TASKSTEP-OUT" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns7__SoapTaskStep2s(struct soap *soap, enum ns7__SoapTaskStep n)
{	const char *s = soap_code_str(soap_codes_ns7__SoapTaskStep, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__SoapTaskStep(struct soap *soap, const char *tag, int id, const enum ns7__SoapTaskStep *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__SoapTaskStep), type) || soap_send(soap, soap_ns7__SoapTaskStep2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns7__SoapTaskStep(struct soap *soap, const char *s, enum ns7__SoapTaskStep *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns7__SoapTaskStep, s);
	if (map)
		*a = (enum ns7__SoapTaskStep)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum ns7__SoapTaskStep)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns7__SoapTaskStep * SOAP_FMAC4 soap_in_ns7__SoapTaskStep(struct soap *soap, const char *tag, enum ns7__SoapTaskStep *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns7__SoapTaskStep *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__SoapTaskStep, sizeof(enum ns7__SoapTaskStep), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns7__SoapTaskStep(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns7__SoapTaskStep *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__SoapTaskStep, SOAP_TYPE_ns7__SoapTaskStep, sizeof(enum ns7__SoapTaskStep), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns7__SoapTaskStep * SOAP_FMAC4 soap_new_ns7__SoapTaskStep(struct soap *soap, int n)
{
	enum ns7__SoapTaskStep *a = static_cast<enum ns7__SoapTaskStep *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns7__SoapTaskStep)));
	for (enum ns7__SoapTaskStep *p = a; p && n--; ++p)
		soap_default_ns7__SoapTaskStep(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns7__SoapTaskStep(struct soap *soap, const enum ns7__SoapTaskStep *a, const char *tag, const char *type)
{
	if (soap_out_ns7__SoapTaskStep(soap, tag ? tag : "ns7:SoapTaskStep", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns7__SoapTaskStep * SOAP_FMAC4 soap_get_ns7__SoapTaskStep(struct soap *soap, enum ns7__SoapTaskStep *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__SoapTaskStep(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns7__SoapTaskState[] =
{	{ (LONG64)ns7__SoapTaskState__TASKSTATE_IDLE, "TASKSTATE-IDLE" },
	{ (LONG64)ns7__SoapTaskState__TASKSTATE_TRANSITION, "TASKSTATE-TRANSITION" },
	{ (LONG64)ns7__SoapTaskState__TASKSTATE_RUNNING, "TASKSTATE-RUNNING" },
	{ (LONG64)ns7__SoapTaskState__TASKSTATE_STEPPING, "TASKSTATE-STEPPING" },
	{ (LONG64)ns7__SoapTaskState__TASKSTATE_STOPPED, "TASKSTATE-STOPPED" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns7__SoapTaskState2s(struct soap *soap, enum ns7__SoapTaskState n)
{	const char *s = soap_code_str(soap_codes_ns7__SoapTaskState, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__SoapTaskState(struct soap *soap, const char *tag, int id, const enum ns7__SoapTaskState *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__SoapTaskState), type) || soap_send(soap, soap_ns7__SoapTaskState2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns7__SoapTaskState(struct soap *soap, const char *s, enum ns7__SoapTaskState *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns7__SoapTaskState, s);
	if (map)
		*a = (enum ns7__SoapTaskState)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 4)
			return soap->error = SOAP_TYPE;
		*a = (enum ns7__SoapTaskState)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns7__SoapTaskState * SOAP_FMAC4 soap_in_ns7__SoapTaskState(struct soap *soap, const char *tag, enum ns7__SoapTaskState *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns7__SoapTaskState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__SoapTaskState, sizeof(enum ns7__SoapTaskState), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns7__SoapTaskState(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns7__SoapTaskState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__SoapTaskState, SOAP_TYPE_ns7__SoapTaskState, sizeof(enum ns7__SoapTaskState), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns7__SoapTaskState * SOAP_FMAC4 soap_new_ns7__SoapTaskState(struct soap *soap, int n)
{
	enum ns7__SoapTaskState *a = static_cast<enum ns7__SoapTaskState *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns7__SoapTaskState)));
	for (enum ns7__SoapTaskState *p = a; p && n--; ++p)
		soap_default_ns7__SoapTaskState(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns7__SoapTaskState(struct soap *soap, const enum ns7__SoapTaskState *a, const char *tag, const char *type)
{
	if (soap_out_ns7__SoapTaskState(soap, tag ? tag : "ns7:SoapTaskState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns7__SoapTaskState * SOAP_FMAC4 soap_get_ns7__SoapTaskState(struct soap *soap, enum ns7__SoapTaskState *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__SoapTaskState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__DiameterAxis3[] =
{	{ (LONG64)ns1__DiameterAxis3__DIAMETERAXIS3_INVALID, "DIAMETERAXIS3-INVALID" },
	{ (LONG64)ns1__DiameterAxis3__DIAMETERAXIS3_D20, "DIAMETERAXIS3-D20" },
	{ (LONG64)ns1__DiameterAxis3__DIAMETERAXIS3_D25, "DIAMETERAXIS3-D25" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__DiameterAxis32s(struct soap *soap, enum ns1__DiameterAxis3 n)
{	const char *s = soap_code_str(soap_codes_ns1__DiameterAxis3, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DiameterAxis3(struct soap *soap, const char *tag, int id, const enum ns1__DiameterAxis3 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DiameterAxis3), type) || soap_send(soap, soap_ns1__DiameterAxis32s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__DiameterAxis3(struct soap *soap, const char *s, enum ns1__DiameterAxis3 *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__DiameterAxis3, s);
	if (map)
		*a = (enum ns1__DiameterAxis3)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__DiameterAxis3)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__DiameterAxis3 * SOAP_FMAC4 soap_in_ns1__DiameterAxis3(struct soap *soap, const char *tag, enum ns1__DiameterAxis3 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__DiameterAxis3 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DiameterAxis3, sizeof(enum ns1__DiameterAxis3), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__DiameterAxis3(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__DiameterAxis3 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DiameterAxis3, SOAP_TYPE_ns1__DiameterAxis3, sizeof(enum ns1__DiameterAxis3), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__DiameterAxis3 * SOAP_FMAC4 soap_new_ns1__DiameterAxis3(struct soap *soap, int n)
{
	enum ns1__DiameterAxis3 *a = static_cast<enum ns1__DiameterAxis3 *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__DiameterAxis3)));
	for (enum ns1__DiameterAxis3 *p = a; p && n--; ++p)
		soap_default_ns1__DiameterAxis3(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DiameterAxis3(struct soap *soap, const enum ns1__DiameterAxis3 *a, const char *tag, const char *type)
{
	if (soap_out_ns1__DiameterAxis3(soap, tag ? tag : "ns1:DiameterAxis3", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__DiameterAxis3 * SOAP_FMAC4 soap_get_ns1__DiameterAxis3(struct soap *soap, enum ns1__DiameterAxis3 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DiameterAxis3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__LengthAxis3[] =
{	{ (LONG64)ns1__LengthAxis3__LENGTHAXIS3_INVALID, "LENGTHAXIS3-INVALID" },
	{ (LONG64)ns1__LengthAxis3__LENGTHAXIS3_L100, "LENGTHAXIS3-L100" },
	{ (LONG64)ns1__LengthAxis3__LENGTHAXIS3_L200, "LENGTHAXIS3-L200" },
	{ (LONG64)ns1__LengthAxis3__LENGTHAXIS3_L400, "LENGTHAXIS3-L400" },
	{ (LONG64)ns1__LengthAxis3__LENGTHAXIS3_L600, "LENGTHAXIS3-L600" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__LengthAxis32s(struct soap *soap, enum ns1__LengthAxis3 n)
{	const char *s = soap_code_str(soap_codes_ns1__LengthAxis3, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__LengthAxis3(struct soap *soap, const char *tag, int id, const enum ns1__LengthAxis3 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__LengthAxis3), type) || soap_send(soap, soap_ns1__LengthAxis32s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__LengthAxis3(struct soap *soap, const char *s, enum ns1__LengthAxis3 *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__LengthAxis3, s);
	if (map)
		*a = (enum ns1__LengthAxis3)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 4)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__LengthAxis3)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__LengthAxis3 * SOAP_FMAC4 soap_in_ns1__LengthAxis3(struct soap *soap, const char *tag, enum ns1__LengthAxis3 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__LengthAxis3 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__LengthAxis3, sizeof(enum ns1__LengthAxis3), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__LengthAxis3(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__LengthAxis3 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__LengthAxis3, SOAP_TYPE_ns1__LengthAxis3, sizeof(enum ns1__LengthAxis3), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__LengthAxis3 * SOAP_FMAC4 soap_new_ns1__LengthAxis3(struct soap *soap, int n)
{
	enum ns1__LengthAxis3 *a = static_cast<enum ns1__LengthAxis3 *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__LengthAxis3)));
	for (enum ns1__LengthAxis3 *p = a; p && n--; ++p)
		soap_default_ns1__LengthAxis3(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__LengthAxis3(struct soap *soap, const enum ns1__LengthAxis3 *a, const char *tag, const char *type)
{
	if (soap_out_ns1__LengthAxis3(soap, tag ? tag : "ns1:LengthAxis3", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__LengthAxis3 * SOAP_FMAC4 soap_get_ns1__LengthAxis3(struct soap *soap, enum ns1__LengthAxis3 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__LengthAxis3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__MountType[] =
{	{ (LONG64)ns1__MountType__MOUNTTYPE_INVALID, "MOUNTTYPE-INVALID" },
	{ (LONG64)ns1__MountType__MOUNTTYPE_FLOOR, "MOUNTTYPE-FLOOR" },
	{ (LONG64)ns1__MountType__MOUNTTYPE_CEILING, "MOUNTTYPE-CEILING" },
	{ (LONG64)ns1__MountType__MOUNTTYPE_WALL, "MOUNTTYPE-WALL" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__MountType2s(struct soap *soap, enum ns1__MountType n)
{	const char *s = soap_code_str(soap_codes_ns1__MountType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MountType(struct soap *soap, const char *tag, int id, const enum ns1__MountType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MountType), type) || soap_send(soap, soap_ns1__MountType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__MountType(struct soap *soap, const char *s, enum ns1__MountType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__MountType, s);
	if (map)
		*a = (enum ns1__MountType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__MountType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__MountType * SOAP_FMAC4 soap_in_ns1__MountType(struct soap *soap, const char *tag, enum ns1__MountType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__MountType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MountType, sizeof(enum ns1__MountType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__MountType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__MountType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MountType, SOAP_TYPE_ns1__MountType, sizeof(enum ns1__MountType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__MountType * SOAP_FMAC4 soap_new_ns1__MountType(struct soap *soap, int n)
{
	enum ns1__MountType *a = static_cast<enum ns1__MountType *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__MountType)));
	for (enum ns1__MountType *p = a; p && n--; ++p)
		soap_default_ns1__MountType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__MountType(struct soap *soap, const enum ns1__MountType *a, const char *tag, const char *type)
{
	if (soap_out_ns1__MountType(soap, tag ? tag : "ns1:MountType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__MountType * SOAP_FMAC4 soap_get_ns1__MountType(struct soap *soap, enum ns1__MountType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MountType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__Kinematic[] =
{	{ (LONG64)ns1__Kinematic__KINEMATIC_INVALID, "KINEMATIC-INVALID" },
	{ (LONG64)ns1__Kinematic__KINEMATIC_ANTHROPOMORPH6, "KINEMATIC-ANTHROPOMORPH6" },
	{ (LONG64)ns1__Kinematic__KINEMATIC_ANTHROPOMORPH5, "KINEMATIC-ANTHROPOMORPH5" },
	{ (LONG64)ns1__Kinematic__KINEMATIC_SCARA, "KINEMATIC-SCARA" },
	{ (LONG64)ns1__Kinematic__KINEMATIC_EISENMANN, "KINEMATIC-EISENMANN" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__Kinematic2s(struct soap *soap, enum ns1__Kinematic n)
{	const char *s = soap_code_str(soap_codes_ns1__Kinematic, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Kinematic(struct soap *soap, const char *tag, int id, const enum ns1__Kinematic *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Kinematic), type) || soap_send(soap, soap_ns1__Kinematic2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__Kinematic(struct soap *soap, const char *s, enum ns1__Kinematic *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__Kinematic, s);
	if (map)
		*a = (enum ns1__Kinematic)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 4)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__Kinematic)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__Kinematic * SOAP_FMAC4 soap_in_ns1__Kinematic(struct soap *soap, const char *tag, enum ns1__Kinematic *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__Kinematic *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Kinematic, sizeof(enum ns1__Kinematic), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__Kinematic(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__Kinematic *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Kinematic, SOAP_TYPE_ns1__Kinematic, sizeof(enum ns1__Kinematic), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__Kinematic * SOAP_FMAC4 soap_new_ns1__Kinematic(struct soap *soap, int n)
{
	enum ns1__Kinematic *a = static_cast<enum ns1__Kinematic *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__Kinematic)));
	for (enum ns1__Kinematic *p = a; p && n--; ++p)
		soap_default_ns1__Kinematic(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Kinematic(struct soap *soap, const enum ns1__Kinematic *a, const char *tag, const char *type)
{
	if (soap_out_ns1__Kinematic(soap, tag ? tag : "ns1:Kinematic", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__Kinematic * SOAP_FMAC4 soap_get_ns1__Kinematic(struct soap *soap, enum ns1__Kinematic *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Kinematic(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__ServerExceptionCode[] =
{	{ (LONG64)ns1__ServerExceptionCode__UNKNOWN_CODE, "UNKNOWN-CODE" },
	{ (LONG64)ns1__ServerExceptionCode__INVALID_SESSION_ID_CODE, "INVALID-SESSION-ID-CODE" },
	{ (LONG64)ns1__ServerExceptionCode__INVALID_ROBOT_ID_CODE, "INVALID-ROBOT-ID-CODE" },
	{ (LONG64)ns1__ServerExceptionCode__READ_ACCESS_ERROR_CODE, "READ-ACCESS-ERROR-CODE" },
	{ (LONG64)ns1__ServerExceptionCode__WRITE_ACCESS_ERROR_CODE, "WRITE-ACCESS-ERROR-CODE" },
	{ (LONG64)ns1__ServerExceptionCode__SET_POS_NOT_SIMUL_CODE, "SET-POS-NOT-SIMUL-CODE" },
	{ (LONG64)ns1__ServerExceptionCode__SET_POS_POWER_ON_CODE, "SET-POS-POWER-ON-CODE" },
	{ (LONG64)ns1__ServerExceptionCode__FILE_NOT_FOUND_CODE, "FILE-NOT-FOUND-CODE" },
	{ (LONG64)ns1__ServerExceptionCode__INVALID_CONFIG_CODE, "INVALID-CONFIG-CODE" },
	{ (LONG64)ns1__ServerExceptionCode__INVALID_NUMBER_OF_AXIS_CODE, "INVALID-NUMBER-OF-AXIS-CODE" },
	{ (LONG64)ns1__ServerExceptionCode__INVALID_MOT_DESC_CODE, "INVALID-MOT-DESC-CODE" },
	{ (LONG64)ns1__ServerExceptionCode__CLIENT_ALREADY_CONNECTED, "CLIENT-ALREADY-CONNECTED" },
	{ (LONG64)ns1__ServerExceptionCode__CLIENT_COMMUNICATION_ERROR, "CLIENT-COMMUNICATION-ERROR" },
	{ (LONG64)ns1__ServerExceptionCode__APPLICATION_NOT_FOUND, "APPLICATION-NOT-FOUND" },
	{ (LONG64)ns1__ServerExceptionCode__PROGRAM_NOT_FOUND, "PROGRAM-NOT-FOUND" },
	{ (LONG64)ns1__ServerExceptionCode__TASK_NOT_FOUND, "TASK-NOT-FOUND" },
	{ (LONG64)ns1__ServerExceptionCode__STACK_FRAME_NOT_FOUND, "STACK-FRAME-NOT-FOUND" },
	{ (LONG64)ns1__ServerExceptionCode__TASK_ALREADY_LOCKED, "TASK-ALREADY-LOCKED" },
	{ (LONG64)ns1__ServerExceptionCode__INVALID_SOAP_HANDLER, "INVALID-SOAP-HANDLER" },
	{ (LONG64)ns1__ServerExceptionCode__INVALID_SOAP_HEADER, "INVALID-SOAP-HEADER" },
	{ (LONG64)ns1__ServerExceptionCode__PROGRAM_LINE_NOT_FOUND, "PROGRAM-LINE-NOT-FOUND" },
	{ (LONG64)ns1__ServerExceptionCode__MISMATCHED_CODE, "MISMATCHED-CODE" },
	{ (LONG64)ns1__ServerExceptionCode__IOWRITE_ACCESS_ERROR_CODE, "IOWRITE-ACCESS-ERROR-CODE" },
	{ (LONG64)ns1__ServerExceptionCode__IOWRITE_ACCESS_ERROR_WORKING_MODE, "IOWRITE-ACCESS-ERROR-WORKING-MODE" },
	{ (LONG64)ns1__ServerExceptionCode__IOWRITE_ACCESS_ERROR_VALIDATION, "IOWRITE-ACCESS-ERROR-VALIDATION" },
	{ (LONG64)ns1__ServerExceptionCode__SCHEDULING_MODE_ERROR, "SCHEDULING-MODE-ERROR" },
	{ (LONG64)ns1__ServerExceptionCode__INVALID_PARAMETERS, "INVALID-PARAMETERS" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__ServerExceptionCode2s(struct soap *soap, enum ns1__ServerExceptionCode n)
{	const char *s = soap_code_str(soap_codes_ns1__ServerExceptionCode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ServerExceptionCode(struct soap *soap, const char *tag, int id, const enum ns1__ServerExceptionCode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ServerExceptionCode), type) || soap_send(soap, soap_ns1__ServerExceptionCode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__ServerExceptionCode(struct soap *soap, const char *s, enum ns1__ServerExceptionCode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__ServerExceptionCode, s);
	if (map)
		*a = (enum ns1__ServerExceptionCode)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 26)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__ServerExceptionCode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__ServerExceptionCode * SOAP_FMAC4 soap_in_ns1__ServerExceptionCode(struct soap *soap, const char *tag, enum ns1__ServerExceptionCode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__ServerExceptionCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ServerExceptionCode, sizeof(enum ns1__ServerExceptionCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns1__ServerExceptionCode(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns1__ServerExceptionCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ServerExceptionCode, SOAP_TYPE_ns1__ServerExceptionCode, sizeof(enum ns1__ServerExceptionCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__ServerExceptionCode * SOAP_FMAC4 soap_new_ns1__ServerExceptionCode(struct soap *soap, int n)
{
	enum ns1__ServerExceptionCode *a = static_cast<enum ns1__ServerExceptionCode *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__ServerExceptionCode)));
	for (enum ns1__ServerExceptionCode *p = a; p && n--; ++p)
		soap_default_ns1__ServerExceptionCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ServerExceptionCode(struct soap *soap, const enum ns1__ServerExceptionCode *a, const char *tag, const char *type)
{
	if (soap_out_ns1__ServerExceptionCode(soap, tag ? tag : "ns1:ServerExceptionCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__ServerExceptionCode * SOAP_FMAC4 soap_get_ns1__ServerExceptionCode(struct soap *soap, enum ns1__ServerExceptionCode *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ServerExceptionCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns4__hexBinary::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns4__hexBinary::__item.xsd__hexBinary::soap_default(soap);
	this->ns4__hexBinary::contentType = NULL;
	/* transient soap skipped */
}

void ns4__hexBinary::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns4__hexBinary::__item.soap_serialize(soap);
#endif
}

int ns4__hexBinary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__hexBinary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__hexBinary(struct soap *soap, const char *tag, int id, const ns4__hexBinary *a, const char *type)
{
	if (((ns4__hexBinary*)a)->contentType)
	{	soap_set_attr(soap, "contentType", soap_std__string2s(soap, *((ns4__hexBinary*)a)->contentType), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return (a->ns4__hexBinary::__item).soap_out(soap, tag, id, "");
}

void *ns4__hexBinary::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__hexBinary(soap, tag, this, type);
}

SOAP_FMAC3 ns4__hexBinary * SOAP_FMAC4 soap_in_ns4__hexBinary(struct soap *soap, const char *tag, ns4__hexBinary *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns4__hexBinary *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__hexBinary, sizeof(ns4__hexBinary), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns4__hexBinary)
		return (ns4__hexBinary *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "contentType", 1, 0);
		if (t)
		{
			if (!(((ns4__hexBinary*)a)->contentType = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns4__hexBinary*)a)->contentType))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (!(a->ns4__hexBinary::__item).soap_in(soap, tag, "ns4:hexBinary"))
		return NULL;
	return a;
}

SOAP_FMAC1 ns4__hexBinary * SOAP_FMAC2 soap_instantiate_ns4__hexBinary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__hexBinary(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns4__hexBinary *p;
	size_t k = sizeof(ns4__hexBinary);
	if (n < 0)
	{	p = SOAP_NEW(ns4__hexBinary);
		if (p)
			((ns4__hexBinary*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns4__hexBinary, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns4__hexBinary*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns4__hexBinary location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns4__hexBinary, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns4__hexBinary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns4__hexBinary(soap, tag ? tag : "ns4:hexBinary", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__hexBinary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__hexBinary(soap, this, tag, type);
}

SOAP_FMAC3 ns4__hexBinary * SOAP_FMAC4 soap_get_ns4__hexBinary(struct soap *soap, ns4__hexBinary *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__hexBinary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns4__base64Binary::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns4__base64Binary::__item.xsd__base64Binary::soap_default(soap);
	this->ns4__base64Binary::contentType = NULL;
	/* transient soap skipped */
}

void ns4__base64Binary::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns4__base64Binary::__item.soap_serialize(soap);
#endif
}

int ns4__base64Binary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__base64Binary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__base64Binary(struct soap *soap, const char *tag, int id, const ns4__base64Binary *a, const char *type)
{
	if (((ns4__base64Binary*)a)->contentType)
	{	soap_set_attr(soap, "contentType", soap_std__string2s(soap, *((ns4__base64Binary*)a)->contentType), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return (a->ns4__base64Binary::__item).soap_out(soap, tag, id, "");
}

void *ns4__base64Binary::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__base64Binary(soap, tag, this, type);
}

SOAP_FMAC3 ns4__base64Binary * SOAP_FMAC4 soap_in_ns4__base64Binary(struct soap *soap, const char *tag, ns4__base64Binary *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns4__base64Binary *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__base64Binary, sizeof(ns4__base64Binary), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns4__base64Binary)
		return (ns4__base64Binary *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "contentType", 1, 0);
		if (t)
		{
			if (!(((ns4__base64Binary*)a)->contentType = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns4__base64Binary*)a)->contentType))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (!(a->ns4__base64Binary::__item).soap_in(soap, tag, "ns4:base64Binary"))
		return NULL;
	return a;
}

SOAP_FMAC1 ns4__base64Binary * SOAP_FMAC2 soap_instantiate_ns4__base64Binary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__base64Binary(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns4__base64Binary *p;
	size_t k = sizeof(ns4__base64Binary);
	if (n < 0)
	{	p = SOAP_NEW(ns4__base64Binary);
		if (p)
			((ns4__base64Binary*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns4__base64Binary, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns4__base64Binary*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns4__base64Binary location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns4__base64Binary, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns4__base64Binary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns4__base64Binary(soap, tag ? tag : "ns4:base64Binary", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__base64Binary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__base64Binary(soap, this, tag, type);
}

SOAP_FMAC3 ns4__base64Binary * SOAP_FMAC4 soap_get_ns4__base64Binary(struct soap *soap, ns4__base64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns2__getJointRangeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns2__getJointRangeResponse::range = NULL;
	/* transient soap skipped */
}

void _ns2__getJointRangeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__JointRange(soap, &this->_ns2__getJointRangeResponse::range);
#endif
}

int _ns2__getJointRangeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__getJointRangeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__getJointRangeResponse(struct soap *soap, const char *tag, int id, const _ns2__getJointRangeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__getJointRangeResponse), type))
		return soap->error;
	if (!a->_ns2__getJointRangeResponse::range)
	{	if (soap_element_empty(soap, "range"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons2__JointRange(soap, "range", -1, &a->_ns2__getJointRangeResponse::range, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns2__getJointRangeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns2__getJointRangeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__getJointRangeResponse * SOAP_FMAC4 soap_in__ns2__getJointRangeResponse(struct soap *soap, const char *tag, _ns2__getJointRangeResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__getJointRangeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__getJointRangeResponse, sizeof(_ns2__getJointRangeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns2__getJointRangeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns2__getJointRangeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_range1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_range1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__JointRange(soap, "range", &a->_ns2__getJointRangeResponse::range, "ns2:JointRange"))
				{	soap_flag_range1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns2__getJointRangeResponse::range))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns2__getJointRangeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__getJointRangeResponse, SOAP_TYPE__ns2__getJointRangeResponse, sizeof(_ns2__getJointRangeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns2__getJointRangeResponse * SOAP_FMAC2 soap_instantiate__ns2__getJointRangeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__getJointRangeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns2__getJointRangeResponse *p;
	size_t k = sizeof(_ns2__getJointRangeResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns2__getJointRangeResponse);
		if (p)
			((_ns2__getJointRangeResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns2__getJointRangeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns2__getJointRangeResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns2__getJointRangeResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns2__getJointRangeResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns2__getJointRangeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns2__getJointRangeResponse(soap, tag ? tag : "ns2:getJointRangeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__getJointRangeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__getJointRangeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__getJointRangeResponse * SOAP_FMAC4 soap_get__ns2__getJointRangeResponse(struct soap *soap, _ns2__getJointRangeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__getJointRangeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns2__getJointRange::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns2__getJointRange::robot);
	/* transient soap skipped */
}

void _ns2__getJointRange::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns2__getJointRange::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__getJointRange(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__getJointRange(struct soap *soap, const char *tag, int id, const _ns2__getJointRange *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__getJointRange), type))
		return soap->error;
	if (soap_out_int(soap, "robot", -1, &a->_ns2__getJointRange::robot, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns2__getJointRange::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns2__getJointRange(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__getJointRange * SOAP_FMAC4 soap_in__ns2__getJointRange(struct soap *soap, const char *tag, _ns2__getJointRange *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__getJointRange *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__getJointRange, sizeof(_ns2__getJointRange), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns2__getJointRange)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns2__getJointRange *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_robot1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_robot1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "robot", &a->_ns2__getJointRange::robot, "xsd:int"))
				{	soap_flag_robot1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_robot1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns2__getJointRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__getJointRange, SOAP_TYPE__ns2__getJointRange, sizeof(_ns2__getJointRange), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns2__getJointRange * SOAP_FMAC2 soap_instantiate__ns2__getJointRange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__getJointRange(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns2__getJointRange *p;
	size_t k = sizeof(_ns2__getJointRange);
	if (n < 0)
	{	p = SOAP_NEW(_ns2__getJointRange);
		if (p)
			((_ns2__getJointRange*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns2__getJointRange, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns2__getJointRange*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns2__getJointRange location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns2__getJointRange, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns2__getJointRange::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns2__getJointRange(soap, tag ? tag : "ns2:getJointRange", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__getJointRange::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__getJointRange(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__getJointRange * SOAP_FMAC4 soap_get__ns2__getJointRange(struct soap *soap, _ns2__getJointRange *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__getJointRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns2__getRecordResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns2__getRecordResponse::data = NULL;
	/* transient soap skipped */
}

void _ns2__getRecordResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__Data(soap, &this->_ns2__getRecordResponse::data);
#endif
}

int _ns2__getRecordResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__getRecordResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__getRecordResponse(struct soap *soap, const char *tag, int id, const _ns2__getRecordResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__getRecordResponse), type))
		return soap->error;
	if (!a->_ns2__getRecordResponse::data)
	{	if (soap_element_empty(soap, "data"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons2__Data(soap, "data", -1, &a->_ns2__getRecordResponse::data, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns2__getRecordResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns2__getRecordResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__getRecordResponse * SOAP_FMAC4 soap_in__ns2__getRecordResponse(struct soap *soap, const char *tag, _ns2__getRecordResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__getRecordResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__getRecordResponse, sizeof(_ns2__getRecordResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns2__getRecordResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns2__getRecordResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_data1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_data1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__Data(soap, "data", &a->_ns2__getRecordResponse::data, "ns2:Data"))
				{	soap_flag_data1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns2__getRecordResponse::data))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns2__getRecordResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__getRecordResponse, SOAP_TYPE__ns2__getRecordResponse, sizeof(_ns2__getRecordResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns2__getRecordResponse * SOAP_FMAC2 soap_instantiate__ns2__getRecordResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__getRecordResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns2__getRecordResponse *p;
	size_t k = sizeof(_ns2__getRecordResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns2__getRecordResponse);
		if (p)
			((_ns2__getRecordResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns2__getRecordResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns2__getRecordResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns2__getRecordResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns2__getRecordResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns2__getRecordResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns2__getRecordResponse(soap, tag ? tag : "ns2:getRecordResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__getRecordResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__getRecordResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__getRecordResponse * SOAP_FMAC4 soap_get__ns2__getRecordResponse(struct soap *soap, _ns2__getRecordResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__getRecordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns2__getRecord::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns2__getRecord::name = NULL;
	/* transient soap skipped */
}

void _ns2__getRecord::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns2__getRecord::name);
#endif
}

int _ns2__getRecord::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__getRecord(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__getRecord(struct soap *soap, const char *tag, int id, const _ns2__getRecord *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__getRecord), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "name", -1, &a->_ns2__getRecord::name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns2__getRecord::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns2__getRecord(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__getRecord * SOAP_FMAC4 soap_in__ns2__getRecord(struct soap *soap, const char *tag, _ns2__getRecord *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__getRecord *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__getRecord, sizeof(_ns2__getRecord), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns2__getRecord)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns2__getRecord *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_name1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "name", &a->_ns2__getRecord::name, "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__getRecord *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__getRecord, SOAP_TYPE__ns2__getRecord, sizeof(_ns2__getRecord), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns2__getRecord * SOAP_FMAC2 soap_instantiate__ns2__getRecord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__getRecord(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns2__getRecord *p;
	size_t k = sizeof(_ns2__getRecord);
	if (n < 0)
	{	p = SOAP_NEW(_ns2__getRecord);
		if (p)
			((_ns2__getRecord*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns2__getRecord, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns2__getRecord*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns2__getRecord location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns2__getRecord, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns2__getRecord::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns2__getRecord(soap, tag ? tag : "ns2:getRecord", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__getRecord::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__getRecord(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__getRecord * SOAP_FMAC4 soap_get__ns2__getRecord(struct soap *soap, _ns2__getRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__getRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns2__getRecordsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns2__getRecordsResponse::records = NULL;
	/* transient soap skipped */
}

void _ns2__getRecordsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__Records(soap, &this->_ns2__getRecordsResponse::records);
#endif
}

int _ns2__getRecordsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__getRecordsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__getRecordsResponse(struct soap *soap, const char *tag, int id, const _ns2__getRecordsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__getRecordsResponse), type))
		return soap->error;
	if (!a->_ns2__getRecordsResponse::records)
	{	if (soap_element_empty(soap, "records"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons2__Records(soap, "records", -1, &a->_ns2__getRecordsResponse::records, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns2__getRecordsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns2__getRecordsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__getRecordsResponse * SOAP_FMAC4 soap_in__ns2__getRecordsResponse(struct soap *soap, const char *tag, _ns2__getRecordsResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__getRecordsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__getRecordsResponse, sizeof(_ns2__getRecordsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns2__getRecordsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns2__getRecordsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_records1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_records1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__Records(soap, "records", &a->_ns2__getRecordsResponse::records, "ns2:Records"))
				{	soap_flag_records1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns2__getRecordsResponse::records))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns2__getRecordsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__getRecordsResponse, SOAP_TYPE__ns2__getRecordsResponse, sizeof(_ns2__getRecordsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns2__getRecordsResponse * SOAP_FMAC2 soap_instantiate__ns2__getRecordsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__getRecordsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns2__getRecordsResponse *p;
	size_t k = sizeof(_ns2__getRecordsResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns2__getRecordsResponse);
		if (p)
			((_ns2__getRecordsResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns2__getRecordsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns2__getRecordsResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns2__getRecordsResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns2__getRecordsResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns2__getRecordsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns2__getRecordsResponse(soap, tag ? tag : "ns2:getRecordsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__getRecordsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__getRecordsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__getRecordsResponse * SOAP_FMAC4 soap_get__ns2__getRecordsResponse(struct soap *soap, _ns2__getRecordsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__getRecordsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns2__getRecords::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns2__getRecords::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns2__getRecords::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__getRecords(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__getRecords(struct soap *soap, const char *tag, int id, const _ns2__getRecords *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__getRecords), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns2__getRecords::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns2__getRecords(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__getRecords * SOAP_FMAC4 soap_in__ns2__getRecords(struct soap *soap, const char *tag, _ns2__getRecords *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__getRecords *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__getRecords, sizeof(_ns2__getRecords), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns2__getRecords)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns2__getRecords *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__getRecords *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__getRecords, SOAP_TYPE__ns2__getRecords, sizeof(_ns2__getRecords), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns2__getRecords * SOAP_FMAC2 soap_instantiate__ns2__getRecords(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__getRecords(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns2__getRecords *p;
	size_t k = sizeof(_ns2__getRecords);
	if (n < 0)
	{	p = SOAP_NEW(_ns2__getRecords);
		if (p)
			((_ns2__getRecords*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns2__getRecords, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns2__getRecords*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns2__getRecords location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns2__getRecords, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns2__getRecords::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns2__getRecords(soap, tag ? tag : "ns2:getRecords", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__getRecords::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__getRecords(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__getRecords * SOAP_FMAC4 soap_get__ns2__getRecords(struct soap *soap, _ns2__getRecords *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__getRecords(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns2__getApplicationDatasResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns2__getApplicationDatasResponse::data = NULL;
	/* transient soap skipped */
}

void _ns2__getApplicationDatasResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__Data(soap, &this->_ns2__getApplicationDatasResponse::data);
#endif
}

int _ns2__getApplicationDatasResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__getApplicationDatasResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__getApplicationDatasResponse(struct soap *soap, const char *tag, int id, const _ns2__getApplicationDatasResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__getApplicationDatasResponse), type))
		return soap->error;
	if (!a->_ns2__getApplicationDatasResponse::data)
	{	if (soap_element_empty(soap, "data"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons2__Data(soap, "data", -1, &a->_ns2__getApplicationDatasResponse::data, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns2__getApplicationDatasResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns2__getApplicationDatasResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__getApplicationDatasResponse * SOAP_FMAC4 soap_in__ns2__getApplicationDatasResponse(struct soap *soap, const char *tag, _ns2__getApplicationDatasResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__getApplicationDatasResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__getApplicationDatasResponse, sizeof(_ns2__getApplicationDatasResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns2__getApplicationDatasResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns2__getApplicationDatasResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_data1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_data1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__Data(soap, "data", &a->_ns2__getApplicationDatasResponse::data, "ns2:Data"))
				{	soap_flag_data1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns2__getApplicationDatasResponse::data))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns2__getApplicationDatasResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__getApplicationDatasResponse, SOAP_TYPE__ns2__getApplicationDatasResponse, sizeof(_ns2__getApplicationDatasResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns2__getApplicationDatasResponse * SOAP_FMAC2 soap_instantiate__ns2__getApplicationDatasResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__getApplicationDatasResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns2__getApplicationDatasResponse *p;
	size_t k = sizeof(_ns2__getApplicationDatasResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns2__getApplicationDatasResponse);
		if (p)
			((_ns2__getApplicationDatasResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns2__getApplicationDatasResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns2__getApplicationDatasResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns2__getApplicationDatasResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns2__getApplicationDatasResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns2__getApplicationDatasResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns2__getApplicationDatasResponse(soap, tag ? tag : "ns2:getApplicationDatasResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__getApplicationDatasResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__getApplicationDatasResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__getApplicationDatasResponse * SOAP_FMAC4 soap_get__ns2__getApplicationDatasResponse(struct soap *soap, _ns2__getApplicationDatasResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__getApplicationDatasResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns2__getApplicationDatas::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns2__getApplicationDatas::name = NULL;
	/* transient soap skipped */
}

void _ns2__getApplicationDatas::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns2__getApplicationDatas::name);
#endif
}

int _ns2__getApplicationDatas::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__getApplicationDatas(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__getApplicationDatas(struct soap *soap, const char *tag, int id, const _ns2__getApplicationDatas *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__getApplicationDatas), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "name", -1, &a->_ns2__getApplicationDatas::name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns2__getApplicationDatas::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns2__getApplicationDatas(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__getApplicationDatas * SOAP_FMAC4 soap_in__ns2__getApplicationDatas(struct soap *soap, const char *tag, _ns2__getApplicationDatas *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__getApplicationDatas *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__getApplicationDatas, sizeof(_ns2__getApplicationDatas), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns2__getApplicationDatas)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns2__getApplicationDatas *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_name1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "name", &a->_ns2__getApplicationDatas::name, "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__getApplicationDatas *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__getApplicationDatas, SOAP_TYPE__ns2__getApplicationDatas, sizeof(_ns2__getApplicationDatas), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns2__getApplicationDatas * SOAP_FMAC2 soap_instantiate__ns2__getApplicationDatas(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__getApplicationDatas(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns2__getApplicationDatas *p;
	size_t k = sizeof(_ns2__getApplicationDatas);
	if (n < 0)
	{	p = SOAP_NEW(_ns2__getApplicationDatas);
		if (p)
			((_ns2__getApplicationDatas*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns2__getApplicationDatas, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns2__getApplicationDatas*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns2__getApplicationDatas location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns2__getApplicationDatas, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns2__getApplicationDatas::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns2__getApplicationDatas(soap, tag ? tag : "ns2:getApplicationDatas", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__getApplicationDatas::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__getApplicationDatas(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__getApplicationDatas * SOAP_FMAC4 soap_get__ns2__getApplicationDatas(struct soap *soap, _ns2__getApplicationDatas *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__getApplicationDatas(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns2__getApplicationsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns2__getApplicationsResponse::applications = NULL;
	/* transient soap skipped */
}

void _ns2__getApplicationsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__VALApplications(soap, &this->_ns2__getApplicationsResponse::applications);
#endif
}

int _ns2__getApplicationsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__getApplicationsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__getApplicationsResponse(struct soap *soap, const char *tag, int id, const _ns2__getApplicationsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__getApplicationsResponse), type))
		return soap->error;
	if (!a->_ns2__getApplicationsResponse::applications)
	{	if (soap_element_empty(soap, "applications"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons2__VALApplications(soap, "applications", -1, &a->_ns2__getApplicationsResponse::applications, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns2__getApplicationsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns2__getApplicationsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__getApplicationsResponse * SOAP_FMAC4 soap_in__ns2__getApplicationsResponse(struct soap *soap, const char *tag, _ns2__getApplicationsResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__getApplicationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__getApplicationsResponse, sizeof(_ns2__getApplicationsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns2__getApplicationsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns2__getApplicationsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_applications1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_applications1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__VALApplications(soap, "applications", &a->_ns2__getApplicationsResponse::applications, "ns2:VALApplications"))
				{	soap_flag_applications1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns2__getApplicationsResponse::applications))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns2__getApplicationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__getApplicationsResponse, SOAP_TYPE__ns2__getApplicationsResponse, sizeof(_ns2__getApplicationsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns2__getApplicationsResponse * SOAP_FMAC2 soap_instantiate__ns2__getApplicationsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__getApplicationsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns2__getApplicationsResponse *p;
	size_t k = sizeof(_ns2__getApplicationsResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns2__getApplicationsResponse);
		if (p)
			((_ns2__getApplicationsResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns2__getApplicationsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns2__getApplicationsResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns2__getApplicationsResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns2__getApplicationsResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns2__getApplicationsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns2__getApplicationsResponse(soap, tag ? tag : "ns2:getApplicationsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__getApplicationsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__getApplicationsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__getApplicationsResponse * SOAP_FMAC4 soap_get__ns2__getApplicationsResponse(struct soap *soap, _ns2__getApplicationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__getApplicationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns2__getApplications::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns2__getApplications::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns2__getApplications::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__getApplications(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__getApplications(struct soap *soap, const char *tag, int id, const _ns2__getApplications *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__getApplications), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns2__getApplications::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns2__getApplications(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__getApplications * SOAP_FMAC4 soap_in__ns2__getApplications(struct soap *soap, const char *tag, _ns2__getApplications *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__getApplications *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__getApplications, sizeof(_ns2__getApplications), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns2__getApplications)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns2__getApplications *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__getApplications *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__getApplications, SOAP_TYPE__ns2__getApplications, sizeof(_ns2__getApplications), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns2__getApplications * SOAP_FMAC2 soap_instantiate__ns2__getApplications(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__getApplications(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns2__getApplications *p;
	size_t k = sizeof(_ns2__getApplications);
	if (n < 0)
	{	p = SOAP_NEW(_ns2__getApplications);
		if (p)
			((_ns2__getApplications*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns2__getApplications, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns2__getApplications*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns2__getApplications location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns2__getApplications, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns2__getApplications::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns2__getApplications(soap, tag ? tag : "ns2:getApplications", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__getApplications::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__getApplications(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__getApplications * SOAP_FMAC4 soap_get__ns2__getApplications(struct soap *soap, _ns2__getApplications *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__getApplications(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__JointRange::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfdouble(soap, &this->ns2__JointRange::min_);
	soap_default_std__vectorTemplateOfdouble(soap, &this->ns2__JointRange::max_);
	/* transient soap skipped */
}

void ns2__JointRange::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfdouble(soap, &this->ns2__JointRange::min_);
	soap_serialize_std__vectorTemplateOfdouble(soap, &this->ns2__JointRange::max_);
#endif
}

int ns2__JointRange::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__JointRange(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__JointRange(struct soap *soap, const char *tag, int id, const ns2__JointRange *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__JointRange), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfdouble(soap, "min", -1, &a->ns2__JointRange::min_, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfdouble(soap, "max", -1, &a->ns2__JointRange::max_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__JointRange::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__JointRange(soap, tag, this, type);
}

SOAP_FMAC3 ns2__JointRange * SOAP_FMAC4 soap_in_ns2__JointRange(struct soap *soap, const char *tag, ns2__JointRange *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__JointRange *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__JointRange, sizeof(ns2__JointRange), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__JointRange)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__JointRange *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfdouble(soap, "min", &a->ns2__JointRange::min_, "xsd:double"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfdouble(soap, "max", &a->ns2__JointRange::max_, "xsd:double"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__JointRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__JointRange, SOAP_TYPE_ns2__JointRange, sizeof(ns2__JointRange), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__JointRange * SOAP_FMAC2 soap_instantiate_ns2__JointRange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__JointRange(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__JointRange *p;
	size_t k = sizeof(ns2__JointRange);
	if (n < 0)
	{	p = SOAP_NEW(ns2__JointRange);
		if (p)
			((ns2__JointRange*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__JointRange, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__JointRange*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__JointRange location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__JointRange, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__JointRange::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__JointRange(soap, tag ? tag : "ns2:JointRange", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__JointRange::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__JointRange(soap, this, tag, type);
}

SOAP_FMAC3 ns2__JointRange * SOAP_FMAC4 soap_get_ns2__JointRange(struct soap *soap, ns2__JointRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__JointRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__Records::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns2__Records::record);
	/* transient soap skipped */
}

void ns2__Records::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns2__Records::record);
#endif
}

int ns2__Records::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__Records(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Records(struct soap *soap, const char *tag, int id, const ns2__Records *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Records), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "record", -1, &a->ns2__Records::record, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__Records::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__Records(soap, tag, this, type);
}

SOAP_FMAC3 ns2__Records * SOAP_FMAC4 soap_in_ns2__Records(struct soap *soap, const char *tag, ns2__Records *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__Records *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Records, sizeof(ns2__Records), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__Records)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__Records *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfstd__string(soap, "record", &a->ns2__Records::record, "xsd:string"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__Records *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Records, SOAP_TYPE_ns2__Records, sizeof(ns2__Records), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__Records * SOAP_FMAC2 soap_instantiate_ns2__Records(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__Records(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__Records *p;
	size_t k = sizeof(ns2__Records);
	if (n < 0)
	{	p = SOAP_NEW(ns2__Records);
		if (p)
			((ns2__Records*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__Records, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__Records*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__Records location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__Records, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__Records::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__Records(soap, tag ? tag : "ns2:Records", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__Records::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__Records(soap, this, tag, type);
}

SOAP_FMAC3 ns2__Records * SOAP_FMAC4 soap_get_ns2__Records(struct soap *soap, ns2__Records *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Records(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__Data::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__Data::ns3__Include_ = NULL;
	this->ns2__Data::ns4__contentType = NULL;
	/* transient soap skipped */
}

void ns2__Data::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__Include(soap, &this->ns2__Data::ns3__Include_);
#endif
}

int ns2__Data::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__Data(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Data(struct soap *soap, const char *tag, int id, const ns2__Data *a, const char *type)
{
	if (((ns2__Data*)a)->ns4__contentType)
	{	soap_set_attr(soap, "ns4:contentType", soap_std__string2s(soap, *((ns2__Data*)a)->ns4__contentType), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Data), type))
		return soap->error;
	if (!a->ns2__Data::ns3__Include_)
	{	if (soap_element_empty(soap, "ns3:Include"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons3__Include(soap, "ns3:Include", -1, &a->ns2__Data::ns3__Include_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__Data::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__Data(soap, tag, this, type);
}

SOAP_FMAC3 ns2__Data * SOAP_FMAC4 soap_in_ns2__Data(struct soap *soap, const char *tag, ns2__Data *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__Data *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Data, sizeof(ns2__Data), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__Data)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__Data *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "ns4:contentType", 1, 0);
		if (t)
		{
			if (!(((ns2__Data*)a)->ns4__contentType = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns2__Data*)a)->ns4__contentType))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_ns3__Include_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__Include_1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons3__Include(soap, "ns3:Include", &a->ns2__Data::ns3__Include_, "ns3:Include"))
				{	soap_flag_ns3__Include_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns2__Data::ns3__Include_))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__Data *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Data, SOAP_TYPE_ns2__Data, sizeof(ns2__Data), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__Data * SOAP_FMAC2 soap_instantiate_ns2__Data(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__Data(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__Data *p;
	size_t k = sizeof(ns2__Data);
	if (n < 0)
	{	p = SOAP_NEW(ns2__Data);
		if (p)
			((ns2__Data*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__Data, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__Data*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__Data location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__Data, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__Data::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__Data(soap, tag ? tag : "ns2:Data", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__Data::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__Data(soap, this, tag, type);
}

SOAP_FMAC3 ns2__Data * SOAP_FMAC4 soap_get_ns2__Data(struct soap *soap, ns2__Data *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Data(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__VALApplications::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__VALApplication(soap, &this->ns2__VALApplications::application);
	/* transient soap skipped */
}

void ns2__VALApplications::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons2__VALApplication(soap, &this->ns2__VALApplications::application);
#endif
}

int ns2__VALApplications::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__VALApplications(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__VALApplications(struct soap *soap, const char *tag, int id, const ns2__VALApplications *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__VALApplications), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__VALApplication(soap, "application", -1, &a->ns2__VALApplications::application, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__VALApplications::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__VALApplications(soap, tag, this, type);
}

SOAP_FMAC3 ns2__VALApplications * SOAP_FMAC4 soap_in_ns2__VALApplications(struct soap *soap, const char *tag, ns2__VALApplications *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__VALApplications *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__VALApplications, sizeof(ns2__VALApplications), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__VALApplications)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__VALApplications *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons2__VALApplication(soap, "application", &a->ns2__VALApplications::application, "ns2:VALApplication"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__VALApplications *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__VALApplications, SOAP_TYPE_ns2__VALApplications, sizeof(ns2__VALApplications), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__VALApplications * SOAP_FMAC2 soap_instantiate_ns2__VALApplications(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__VALApplications(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__VALApplications *p;
	size_t k = sizeof(ns2__VALApplications);
	if (n < 0)
	{	p = SOAP_NEW(ns2__VALApplications);
		if (p)
			((ns2__VALApplications*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__VALApplications, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__VALApplications*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__VALApplications location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__VALApplications, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__VALApplications::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__VALApplications(soap, tag ? tag : "ns2:VALApplications", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__VALApplications::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__VALApplications(soap, this, tag, type);
}

SOAP_FMAC3 ns2__VALApplications * SOAP_FMAC4 soap_get_ns2__VALApplications(struct soap *soap, ns2__VALApplications *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__VALApplications(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__VALApplication::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__VALApplication::name = NULL;
	soap_default_bool(soap, &this->ns2__VALApplication::loaded);
	/* transient soap skipped */
}

void ns2__VALApplication::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns2__VALApplication::name);
#endif
}

int ns2__VALApplication::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__VALApplication(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__VALApplication(struct soap *soap, const char *tag, int id, const ns2__VALApplication *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__VALApplication), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "name", -1, &a->ns2__VALApplication::name, ""))
		return soap->error;
	if (soap_out_bool(soap, "loaded", -1, &a->ns2__VALApplication::loaded, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__VALApplication::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__VALApplication(soap, tag, this, type);
}

SOAP_FMAC3 ns2__VALApplication * SOAP_FMAC4 soap_in_ns2__VALApplication(struct soap *soap, const char *tag, ns2__VALApplication *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__VALApplication *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__VALApplication, sizeof(ns2__VALApplication), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__VALApplication)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__VALApplication *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_name1 = 1;
	size_t soap_flag_loaded1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "name", &a->ns2__VALApplication::name, "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			}
			if (soap_flag_loaded1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "loaded", &a->ns2__VALApplication::loaded, "xsd:boolean"))
				{	soap_flag_loaded1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_loaded1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__VALApplication *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__VALApplication, SOAP_TYPE_ns2__VALApplication, sizeof(ns2__VALApplication), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__VALApplication * SOAP_FMAC2 soap_instantiate_ns2__VALApplication(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__VALApplication(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__VALApplication *p;
	size_t k = sizeof(ns2__VALApplication);
	if (n < 0)
	{	p = SOAP_NEW(ns2__VALApplication);
		if (p)
			((ns2__VALApplication*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__VALApplication, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__VALApplication*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__VALApplication location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__VALApplication, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__VALApplication::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__VALApplication(soap, tag ? tag : "ns2:VALApplication", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__VALApplication::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__VALApplication(soap, this, tag, type);
}

SOAP_FMAC3 ns2__VALApplication * SOAP_FMAC4 soap_get_ns2__VALApplication(struct soap *soap, ns2__VALApplication *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__VALApplication(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__Include::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &this->ns3__Include::__any);
	soap_default_xsd__anyURI(soap, &this->ns3__Include::href);
	this->ns3__Include::__anyAttribute = NULL;
	/* transient soap skipped */
}

void ns3__Include::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->ns3__Include::__any);
#endif
}

int ns3__Include::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__Include(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__Include(struct soap *soap, const char *tag, int id, const ns3__Include *a, const char *type)
{
	soap_set_attr(soap, "href", soap_xsd__anyURI2s(soap, ((ns3__Include*)a)->href), 1);
	if (((ns3__Include*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((ns3__Include*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__Include), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->ns3__Include::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__Include::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__Include(soap, tag, this, type);
}

SOAP_FMAC3 ns3__Include * SOAP_FMAC4 soap_in_ns3__Include(struct soap *soap, const char *tag, ns3__Include *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__Include *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__Include, sizeof(ns3__Include), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns3__Include)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns3__Include *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "href", 4, 1), &((ns3__Include*)a)->href))
		return NULL;
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &((ns3__Include*)a)->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->ns3__Include::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__Include *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__Include, SOAP_TYPE_ns3__Include, sizeof(ns3__Include), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns3__Include * SOAP_FMAC2 soap_instantiate_ns3__Include(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__Include(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns3__Include *p;
	size_t k = sizeof(ns3__Include);
	if (n < 0)
	{	p = SOAP_NEW(ns3__Include);
		if (p)
			((ns3__Include*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns3__Include, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns3__Include*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns3__Include location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns3__Include, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns3__Include::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns3__Include(soap, tag ? tag : "ns3:Include", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__Include::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__Include(soap, this, tag, type);
}

SOAP_FMAC3 ns3__Include * SOAP_FMAC4 soap_get_ns3__Include(struct soap *soap, ns3__Include *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__Include(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__getProjectResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns7__getProjectResponse::data.xsd__base64Binary::soap_default(soap);
	/* transient soap skipped */
}

void _ns7__getProjectResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->_ns7__getProjectResponse::data.soap_serialize(soap);
#endif
}

int _ns7__getProjectResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__getProjectResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__getProjectResponse(struct soap *soap, const char *tag, int id, const _ns7__getProjectResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__getProjectResponse), type))
		return soap->error;
	if ((a->_ns7__getProjectResponse::data).soap_out(soap, "data", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__getProjectResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__getProjectResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__getProjectResponse * SOAP_FMAC4 soap_in__ns7__getProjectResponse(struct soap *soap, const char *tag, _ns7__getProjectResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__getProjectResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__getProjectResponse, sizeof(_ns7__getProjectResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__getProjectResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__getProjectResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_data1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_data1 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->_ns7__getProjectResponse::data).soap_in(soap, "data", "xsd:base64Binary"))
				{	soap_flag_data1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_data1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns7__getProjectResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__getProjectResponse, SOAP_TYPE__ns7__getProjectResponse, sizeof(_ns7__getProjectResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__getProjectResponse * SOAP_FMAC2 soap_instantiate__ns7__getProjectResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__getProjectResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__getProjectResponse *p;
	size_t k = sizeof(_ns7__getProjectResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__getProjectResponse);
		if (p)
			((_ns7__getProjectResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__getProjectResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__getProjectResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__getProjectResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__getProjectResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__getProjectResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__getProjectResponse(soap, tag ? tag : "ns7:getProjectResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__getProjectResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__getProjectResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__getProjectResponse * SOAP_FMAC4 soap_get__ns7__getProjectResponse(struct soap *soap, _ns7__getProjectResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__getProjectResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__getProject::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns7__getProject::name = NULL;
	/* transient soap skipped */
}

void _ns7__getProject::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns7__getProject::name);
#endif
}

int _ns7__getProject::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__getProject(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__getProject(struct soap *soap, const char *tag, int id, const _ns7__getProject *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__getProject), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "name", -1, &a->_ns7__getProject::name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__getProject::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__getProject(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__getProject * SOAP_FMAC4 soap_in__ns7__getProject(struct soap *soap, const char *tag, _ns7__getProject *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__getProject *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__getProject, sizeof(_ns7__getProject), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__getProject)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__getProject *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_name1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "name", &a->_ns7__getProject::name, "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns7__getProject *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__getProject, SOAP_TYPE__ns7__getProject, sizeof(_ns7__getProject), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__getProject * SOAP_FMAC2 soap_instantiate__ns7__getProject(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__getProject(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__getProject *p;
	size_t k = sizeof(_ns7__getProject);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__getProject);
		if (p)
			((_ns7__getProject*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__getProject, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__getProject*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__getProject location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__getProject, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__getProject::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__getProject(soap, tag ? tag : "ns7:getProject", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__getProject::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__getProject(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__getProject * SOAP_FMAC4 soap_get__ns7__getProject(struct soap *soap, _ns7__getProject *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__getProject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__SoapRobotDhParameters::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns7__SoapRobotDhParameters::dhParametersArray = NULL;
	soap_default_double(soap, &this->_ns7__SoapRobotDhParameters::lastDParam);
	/* transient soap skipped */
}

void _ns7__SoapRobotDhParameters::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons7__SoapDhParametersArray(soap, &this->_ns7__SoapRobotDhParameters::dhParametersArray);
#endif
}

int _ns7__SoapRobotDhParameters::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__SoapRobotDhParameters(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__SoapRobotDhParameters(struct soap *soap, const char *tag, int id, const _ns7__SoapRobotDhParameters *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__SoapRobotDhParameters), type))
		return soap->error;
	if (!a->_ns7__SoapRobotDhParameters::dhParametersArray)
	{	if (soap_element_empty(soap, "dhParametersArray"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons7__SoapDhParametersArray(soap, "dhParametersArray", -1, &a->_ns7__SoapRobotDhParameters::dhParametersArray, ""))
		return soap->error;
	if (soap_out_double(soap, "lastDParam", -1, &a->_ns7__SoapRobotDhParameters::lastDParam, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__SoapRobotDhParameters::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__SoapRobotDhParameters(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__SoapRobotDhParameters * SOAP_FMAC4 soap_in__ns7__SoapRobotDhParameters(struct soap *soap, const char *tag, _ns7__SoapRobotDhParameters *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__SoapRobotDhParameters *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__SoapRobotDhParameters, sizeof(_ns7__SoapRobotDhParameters), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__SoapRobotDhParameters)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__SoapRobotDhParameters *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_dhParametersArray1 = 1;
	size_t soap_flag_lastDParam1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dhParametersArray1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons7__SoapDhParametersArray(soap, "dhParametersArray", &a->_ns7__SoapRobotDhParameters::dhParametersArray, "ns7:SoapDhParametersArray"))
				{	soap_flag_dhParametersArray1--;
					continue;
				}
			}
			if (soap_flag_lastDParam1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "lastDParam", &a->_ns7__SoapRobotDhParameters::lastDParam, "xsd:double"))
				{	soap_flag_lastDParam1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns7__SoapRobotDhParameters::dhParametersArray || soap_flag_lastDParam1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns7__SoapRobotDhParameters *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__SoapRobotDhParameters, SOAP_TYPE__ns7__SoapRobotDhParameters, sizeof(_ns7__SoapRobotDhParameters), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__SoapRobotDhParameters * SOAP_FMAC2 soap_instantiate__ns7__SoapRobotDhParameters(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__SoapRobotDhParameters(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__SoapRobotDhParameters *p;
	size_t k = sizeof(_ns7__SoapRobotDhParameters);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__SoapRobotDhParameters);
		if (p)
			((_ns7__SoapRobotDhParameters*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__SoapRobotDhParameters, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__SoapRobotDhParameters*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__SoapRobotDhParameters location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__SoapRobotDhParameters, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__SoapRobotDhParameters::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__SoapRobotDhParameters(soap, tag ? tag : "ns7:SoapRobotDhParameters", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__SoapRobotDhParameters::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__SoapRobotDhParameters(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__SoapRobotDhParameters * SOAP_FMAC4 soap_get__ns7__SoapRobotDhParameters(struct soap *soap, _ns7__SoapRobotDhParameters *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__SoapRobotDhParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__getRobotDhParameters::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns7__getRobotDhParameters::robot);
	/* transient soap skipped */
}

void _ns7__getRobotDhParameters::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns7__getRobotDhParameters::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__getRobotDhParameters(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__getRobotDhParameters(struct soap *soap, const char *tag, int id, const _ns7__getRobotDhParameters *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__getRobotDhParameters), type))
		return soap->error;
	if (soap_out_int(soap, "robot", -1, &a->_ns7__getRobotDhParameters::robot, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__getRobotDhParameters::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__getRobotDhParameters(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__getRobotDhParameters * SOAP_FMAC4 soap_in__ns7__getRobotDhParameters(struct soap *soap, const char *tag, _ns7__getRobotDhParameters *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__getRobotDhParameters *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__getRobotDhParameters, sizeof(_ns7__getRobotDhParameters), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__getRobotDhParameters)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__getRobotDhParameters *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_robot1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_robot1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "robot", &a->_ns7__getRobotDhParameters::robot, "xsd:int"))
				{	soap_flag_robot1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_robot1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns7__getRobotDhParameters *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__getRobotDhParameters, SOAP_TYPE__ns7__getRobotDhParameters, sizeof(_ns7__getRobotDhParameters), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__getRobotDhParameters * SOAP_FMAC2 soap_instantiate__ns7__getRobotDhParameters(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__getRobotDhParameters(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__getRobotDhParameters *p;
	size_t k = sizeof(_ns7__getRobotDhParameters);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__getRobotDhParameters);
		if (p)
			((_ns7__getRobotDhParameters*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__getRobotDhParameters, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__getRobotDhParameters*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__getRobotDhParameters location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__getRobotDhParameters, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__getRobotDhParameters::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__getRobotDhParameters(soap, tag ? tag : "ns7:getRobotDhParameters", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__getRobotDhParameters::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__getRobotDhParameters(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__getRobotDhParameters * SOAP_FMAC4 soap_get__ns7__getRobotDhParameters(struct soap *soap, _ns7__getRobotDhParameters *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__getRobotDhParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__getAllPhysicalIosResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns7__getAllPhysicalIosResponse::data = NULL;
	/* transient soap skipped */
}

void _ns7__getAllPhysicalIosResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons7__MimeData(soap, &this->_ns7__getAllPhysicalIosResponse::data);
#endif
}

int _ns7__getAllPhysicalIosResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__getAllPhysicalIosResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__getAllPhysicalIosResponse(struct soap *soap, const char *tag, int id, const _ns7__getAllPhysicalIosResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__getAllPhysicalIosResponse), type))
		return soap->error;
	if (!a->_ns7__getAllPhysicalIosResponse::data)
	{	if (soap_element_empty(soap, "data"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons7__MimeData(soap, "data", -1, &a->_ns7__getAllPhysicalIosResponse::data, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__getAllPhysicalIosResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__getAllPhysicalIosResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__getAllPhysicalIosResponse * SOAP_FMAC4 soap_in__ns7__getAllPhysicalIosResponse(struct soap *soap, const char *tag, _ns7__getAllPhysicalIosResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__getAllPhysicalIosResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__getAllPhysicalIosResponse, sizeof(_ns7__getAllPhysicalIosResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__getAllPhysicalIosResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__getAllPhysicalIosResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_data1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_data1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons7__MimeData(soap, "data", &a->_ns7__getAllPhysicalIosResponse::data, "ns7:MimeData"))
				{	soap_flag_data1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns7__getAllPhysicalIosResponse::data))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns7__getAllPhysicalIosResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__getAllPhysicalIosResponse, SOAP_TYPE__ns7__getAllPhysicalIosResponse, sizeof(_ns7__getAllPhysicalIosResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__getAllPhysicalIosResponse * SOAP_FMAC2 soap_instantiate__ns7__getAllPhysicalIosResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__getAllPhysicalIosResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__getAllPhysicalIosResponse *p;
	size_t k = sizeof(_ns7__getAllPhysicalIosResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__getAllPhysicalIosResponse);
		if (p)
			((_ns7__getAllPhysicalIosResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__getAllPhysicalIosResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__getAllPhysicalIosResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__getAllPhysicalIosResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__getAllPhysicalIosResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__getAllPhysicalIosResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__getAllPhysicalIosResponse(soap, tag ? tag : "ns7:getAllPhysicalIosResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__getAllPhysicalIosResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__getAllPhysicalIosResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__getAllPhysicalIosResponse * SOAP_FMAC4 soap_get__ns7__getAllPhysicalIosResponse(struct soap *soap, _ns7__getAllPhysicalIosResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__getAllPhysicalIosResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__getAllPhysicalIos::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns7__getAllPhysicalIos::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns7__getAllPhysicalIos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__getAllPhysicalIos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__getAllPhysicalIos(struct soap *soap, const char *tag, int id, const _ns7__getAllPhysicalIos *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__getAllPhysicalIos), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__getAllPhysicalIos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__getAllPhysicalIos(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__getAllPhysicalIos * SOAP_FMAC4 soap_in__ns7__getAllPhysicalIos(struct soap *soap, const char *tag, _ns7__getAllPhysicalIos *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__getAllPhysicalIos *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__getAllPhysicalIos, sizeof(_ns7__getAllPhysicalIos), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__getAllPhysicalIos)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__getAllPhysicalIos *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns7__getAllPhysicalIos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__getAllPhysicalIos, SOAP_TYPE__ns7__getAllPhysicalIos, sizeof(_ns7__getAllPhysicalIos), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__getAllPhysicalIos * SOAP_FMAC2 soap_instantiate__ns7__getAllPhysicalIos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__getAllPhysicalIos(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__getAllPhysicalIos *p;
	size_t k = sizeof(_ns7__getAllPhysicalIos);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__getAllPhysicalIos);
		if (p)
			((_ns7__getAllPhysicalIos*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__getAllPhysicalIos, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__getAllPhysicalIos*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__getAllPhysicalIos location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__getAllPhysicalIos, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__getAllPhysicalIos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__getAllPhysicalIos(soap, tag ? tag : "ns7:getAllPhysicalIos", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__getAllPhysicalIos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__getAllPhysicalIos(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__getAllPhysicalIos * SOAP_FMAC4 soap_get__ns7__getAllPhysicalIos(struct soap *soap, _ns7__getAllPhysicalIos *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__getAllPhysicalIos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__unlockAllIos::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns7__unlockAllIos::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns7__unlockAllIos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__unlockAllIos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__unlockAllIos(struct soap *soap, const char *tag, int id, const _ns7__unlockAllIos *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__unlockAllIos), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__unlockAllIos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__unlockAllIos(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__unlockAllIos * SOAP_FMAC4 soap_in__ns7__unlockAllIos(struct soap *soap, const char *tag, _ns7__unlockAllIos *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__unlockAllIos *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__unlockAllIos, sizeof(_ns7__unlockAllIos), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__unlockAllIos)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__unlockAllIos *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns7__unlockAllIos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__unlockAllIos, SOAP_TYPE__ns7__unlockAllIos, sizeof(_ns7__unlockAllIos), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__unlockAllIos * SOAP_FMAC2 soap_instantiate__ns7__unlockAllIos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__unlockAllIos(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__unlockAllIos *p;
	size_t k = sizeof(_ns7__unlockAllIos);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__unlockAllIos);
		if (p)
			((_ns7__unlockAllIos*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__unlockAllIos, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__unlockAllIos*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__unlockAllIos location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__unlockAllIos, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__unlockAllIos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__unlockAllIos(soap, tag ? tag : "ns7:unlockAllIos", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__unlockAllIos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__unlockAllIos(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__unlockAllIos * SOAP_FMAC4 soap_get__ns7__unlockAllIos(struct soap *soap, _ns7__unlockAllIos *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__unlockAllIos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__SoapAllPhysicalIoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns7__SoapAllPhysicalIoResponse::nbSuccess);
	/* transient soap skipped */
}

void _ns7__SoapAllPhysicalIoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns7__SoapAllPhysicalIoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__SoapAllPhysicalIoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__SoapAllPhysicalIoResponse(struct soap *soap, const char *tag, int id, const _ns7__SoapAllPhysicalIoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__SoapAllPhysicalIoResponse), type))
		return soap->error;
	if (soap_out_int(soap, "nbSuccess", -1, &a->_ns7__SoapAllPhysicalIoResponse::nbSuccess, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__SoapAllPhysicalIoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__SoapAllPhysicalIoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__SoapAllPhysicalIoResponse * SOAP_FMAC4 soap_in__ns7__SoapAllPhysicalIoResponse(struct soap *soap, const char *tag, _ns7__SoapAllPhysicalIoResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__SoapAllPhysicalIoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__SoapAllPhysicalIoResponse, sizeof(_ns7__SoapAllPhysicalIoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__SoapAllPhysicalIoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__SoapAllPhysicalIoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_nbSuccess1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nbSuccess1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "nbSuccess", &a->_ns7__SoapAllPhysicalIoResponse::nbSuccess, "xsd:int"))
				{	soap_flag_nbSuccess1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_nbSuccess1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns7__SoapAllPhysicalIoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__SoapAllPhysicalIoResponse, SOAP_TYPE__ns7__SoapAllPhysicalIoResponse, sizeof(_ns7__SoapAllPhysicalIoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__SoapAllPhysicalIoResponse * SOAP_FMAC2 soap_instantiate__ns7__SoapAllPhysicalIoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__SoapAllPhysicalIoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__SoapAllPhysicalIoResponse *p;
	size_t k = sizeof(_ns7__SoapAllPhysicalIoResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__SoapAllPhysicalIoResponse);
		if (p)
			((_ns7__SoapAllPhysicalIoResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__SoapAllPhysicalIoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__SoapAllPhysicalIoResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__SoapAllPhysicalIoResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__SoapAllPhysicalIoResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__SoapAllPhysicalIoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__SoapAllPhysicalIoResponse(soap, tag ? tag : "ns7:SoapAllPhysicalIoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__SoapAllPhysicalIoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__SoapAllPhysicalIoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__SoapAllPhysicalIoResponse * SOAP_FMAC4 soap_get__ns7__SoapAllPhysicalIoResponse(struct soap *soap, _ns7__SoapAllPhysicalIoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__SoapAllPhysicalIoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__lockAllIos::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns7__lockAllIos::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns7__lockAllIos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__lockAllIos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__lockAllIos(struct soap *soap, const char *tag, int id, const _ns7__lockAllIos *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__lockAllIos), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__lockAllIos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__lockAllIos(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__lockAllIos * SOAP_FMAC4 soap_in__ns7__lockAllIos(struct soap *soap, const char *tag, _ns7__lockAllIos *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__lockAllIos *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__lockAllIos, sizeof(_ns7__lockAllIos), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__lockAllIos)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__lockAllIos *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns7__lockAllIos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__lockAllIos, SOAP_TYPE__ns7__lockAllIos, sizeof(_ns7__lockAllIos), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__lockAllIos * SOAP_FMAC2 soap_instantiate__ns7__lockAllIos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__lockAllIos(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__lockAllIos *p;
	size_t k = sizeof(_ns7__lockAllIos);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__lockAllIos);
		if (p)
			((_ns7__lockAllIos*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__lockAllIos, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__lockAllIos*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__lockAllIos location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__lockAllIos, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__lockAllIos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__lockAllIos(soap, tag ? tag : "ns7:lockAllIos", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__lockAllIos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__lockAllIos(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__lockAllIos * SOAP_FMAC4 soap_get__ns7__lockAllIos(struct soap *soap, _ns7__lockAllIos *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__lockAllIos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__unlockIosResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns7__unlockIosResponse::out = NULL;
	/* transient soap skipped */
}

void _ns7__unlockIosResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons7__SoapPhysicalIoUnlockResponses(soap, &this->_ns7__unlockIosResponse::out);
#endif
}

int _ns7__unlockIosResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__unlockIosResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__unlockIosResponse(struct soap *soap, const char *tag, int id, const _ns7__unlockIosResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__unlockIosResponse), type))
		return soap->error;
	if (!a->_ns7__unlockIosResponse::out)
	{	if (soap_element_empty(soap, "out"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons7__SoapPhysicalIoUnlockResponses(soap, "out", -1, &a->_ns7__unlockIosResponse::out, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__unlockIosResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__unlockIosResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__unlockIosResponse * SOAP_FMAC4 soap_in__ns7__unlockIosResponse(struct soap *soap, const char *tag, _ns7__unlockIosResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__unlockIosResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__unlockIosResponse, sizeof(_ns7__unlockIosResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__unlockIosResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__unlockIosResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_out1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons7__SoapPhysicalIoUnlockResponses(soap, "out", &a->_ns7__unlockIosResponse::out, "ns7:SoapPhysicalIoUnlockResponses"))
				{	soap_flag_out1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns7__unlockIosResponse::out))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns7__unlockIosResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__unlockIosResponse, SOAP_TYPE__ns7__unlockIosResponse, sizeof(_ns7__unlockIosResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__unlockIosResponse * SOAP_FMAC2 soap_instantiate__ns7__unlockIosResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__unlockIosResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__unlockIosResponse *p;
	size_t k = sizeof(_ns7__unlockIosResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__unlockIosResponse);
		if (p)
			((_ns7__unlockIosResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__unlockIosResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__unlockIosResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__unlockIosResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__unlockIosResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__unlockIosResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__unlockIosResponse(soap, tag ? tag : "ns7:unlockIosResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__unlockIosResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__unlockIosResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__unlockIosResponse * SOAP_FMAC4 soap_get__ns7__unlockIosResponse(struct soap *soap, _ns7__unlockIosResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__unlockIosResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__unlockIos::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns7__unlockIos::ios = NULL;
	soap_default_bool(soap, &this->_ns7__unlockIos::x_getDescription);
	/* transient soap skipped */
}

void _ns7__unlockIos::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons7__SoapPhysicalIoLinks(soap, &this->_ns7__unlockIos::ios);
#endif
}

int _ns7__unlockIos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__unlockIos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__unlockIos(struct soap *soap, const char *tag, int id, const _ns7__unlockIos *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__unlockIos), type))
		return soap->error;
	if (!a->_ns7__unlockIos::ios)
	{	if (soap_element_empty(soap, "ios"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons7__SoapPhysicalIoLinks(soap, "ios", -1, &a->_ns7__unlockIos::ios, ""))
		return soap->error;
	if (soap_out_bool(soap, "x-getDescription", -1, &a->_ns7__unlockIos::x_getDescription, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__unlockIos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__unlockIos(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__unlockIos * SOAP_FMAC4 soap_in__ns7__unlockIos(struct soap *soap, const char *tag, _ns7__unlockIos *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__unlockIos *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__unlockIos, sizeof(_ns7__unlockIos), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__unlockIos)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__unlockIos *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ios1 = 1;
	size_t soap_flag_x_getDescription1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ios1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons7__SoapPhysicalIoLinks(soap, "ios", &a->_ns7__unlockIos::ios, "ns7:SoapPhysicalIoLinks"))
				{	soap_flag_ios1--;
					continue;
				}
			}
			if (soap_flag_x_getDescription1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "x-getDescription", &a->_ns7__unlockIos::x_getDescription, "xsd:boolean"))
				{	soap_flag_x_getDescription1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns7__unlockIos::ios || soap_flag_x_getDescription1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns7__unlockIos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__unlockIos, SOAP_TYPE__ns7__unlockIos, sizeof(_ns7__unlockIos), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__unlockIos * SOAP_FMAC2 soap_instantiate__ns7__unlockIos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__unlockIos(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__unlockIos *p;
	size_t k = sizeof(_ns7__unlockIos);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__unlockIos);
		if (p)
			((_ns7__unlockIos*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__unlockIos, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__unlockIos*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__unlockIos location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__unlockIos, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__unlockIos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__unlockIos(soap, tag ? tag : "ns7:unlockIos", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__unlockIos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__unlockIos(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__unlockIos * SOAP_FMAC4 soap_get__ns7__unlockIos(struct soap *soap, _ns7__unlockIos *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__unlockIos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__lockIosResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns7__lockIosResponse::out = NULL;
	/* transient soap skipped */
}

void _ns7__lockIosResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons7__SoapPhysicalIoResponses(soap, &this->_ns7__lockIosResponse::out);
#endif
}

int _ns7__lockIosResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__lockIosResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__lockIosResponse(struct soap *soap, const char *tag, int id, const _ns7__lockIosResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__lockIosResponse), type))
		return soap->error;
	if (!a->_ns7__lockIosResponse::out)
	{	if (soap_element_empty(soap, "out"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons7__SoapPhysicalIoResponses(soap, "out", -1, &a->_ns7__lockIosResponse::out, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__lockIosResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__lockIosResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__lockIosResponse * SOAP_FMAC4 soap_in__ns7__lockIosResponse(struct soap *soap, const char *tag, _ns7__lockIosResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__lockIosResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__lockIosResponse, sizeof(_ns7__lockIosResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__lockIosResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__lockIosResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_out1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons7__SoapPhysicalIoResponses(soap, "out", &a->_ns7__lockIosResponse::out, "ns7:SoapPhysicalIoResponses"))
				{	soap_flag_out1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns7__lockIosResponse::out))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns7__lockIosResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__lockIosResponse, SOAP_TYPE__ns7__lockIosResponse, sizeof(_ns7__lockIosResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__lockIosResponse * SOAP_FMAC2 soap_instantiate__ns7__lockIosResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__lockIosResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__lockIosResponse *p;
	size_t k = sizeof(_ns7__lockIosResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__lockIosResponse);
		if (p)
			((_ns7__lockIosResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__lockIosResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__lockIosResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__lockIosResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__lockIosResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__lockIosResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__lockIosResponse(soap, tag ? tag : "ns7:lockIosResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__lockIosResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__lockIosResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__lockIosResponse * SOAP_FMAC4 soap_get__ns7__lockIosResponse(struct soap *soap, _ns7__lockIosResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__lockIosResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__lockIos::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns7__lockIos::ios = NULL;
	this->_ns7__lockIos::values = NULL;
	/* transient soap skipped */
}

void _ns7__lockIos::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons7__SoapPhysicalIoLinks(soap, &this->_ns7__lockIos::ios);
	soap_serialize_PointerTons7__SoapPhysicalIoValues(soap, &this->_ns7__lockIos::values);
#endif
}

int _ns7__lockIos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__lockIos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__lockIos(struct soap *soap, const char *tag, int id, const _ns7__lockIos *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__lockIos), type))
		return soap->error;
	if (!a->_ns7__lockIos::ios)
	{	if (soap_element_empty(soap, "ios"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons7__SoapPhysicalIoLinks(soap, "ios", -1, &a->_ns7__lockIos::ios, ""))
		return soap->error;
	if (!a->_ns7__lockIos::values)
	{	if (soap_element_empty(soap, "values"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons7__SoapPhysicalIoValues(soap, "values", -1, &a->_ns7__lockIos::values, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__lockIos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__lockIos(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__lockIos * SOAP_FMAC4 soap_in__ns7__lockIos(struct soap *soap, const char *tag, _ns7__lockIos *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__lockIos *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__lockIos, sizeof(_ns7__lockIos), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__lockIos)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__lockIos *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ios1 = 1;
	size_t soap_flag_values1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ios1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons7__SoapPhysicalIoLinks(soap, "ios", &a->_ns7__lockIos::ios, "ns7:SoapPhysicalIoLinks"))
				{	soap_flag_ios1--;
					continue;
				}
			}
			if (soap_flag_values1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons7__SoapPhysicalIoValues(soap, "values", &a->_ns7__lockIos::values, "ns7:SoapPhysicalIoValues"))
				{	soap_flag_values1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns7__lockIos::ios || !a->_ns7__lockIos::values))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns7__lockIos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__lockIos, SOAP_TYPE__ns7__lockIos, sizeof(_ns7__lockIos), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__lockIos * SOAP_FMAC2 soap_instantiate__ns7__lockIos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__lockIos(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__lockIos *p;
	size_t k = sizeof(_ns7__lockIos);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__lockIos);
		if (p)
			((_ns7__lockIos*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__lockIos, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__lockIos*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__lockIos location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__lockIos, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__lockIos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__lockIos(soap, tag ? tag : "ns7:lockIos", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__lockIos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__lockIos(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__lockIos * SOAP_FMAC4 soap_get__ns7__lockIos(struct soap *soap, _ns7__lockIos *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__lockIos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__writeIosResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns7__writeIosResponse::out = NULL;
	/* transient soap skipped */
}

void _ns7__writeIosResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons7__SoapPhysicalIoResponses(soap, &this->_ns7__writeIosResponse::out);
#endif
}

int _ns7__writeIosResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__writeIosResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__writeIosResponse(struct soap *soap, const char *tag, int id, const _ns7__writeIosResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__writeIosResponse), type))
		return soap->error;
	if (!a->_ns7__writeIosResponse::out)
	{	if (soap_element_empty(soap, "out"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons7__SoapPhysicalIoResponses(soap, "out", -1, &a->_ns7__writeIosResponse::out, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__writeIosResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__writeIosResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__writeIosResponse * SOAP_FMAC4 soap_in__ns7__writeIosResponse(struct soap *soap, const char *tag, _ns7__writeIosResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__writeIosResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__writeIosResponse, sizeof(_ns7__writeIosResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__writeIosResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__writeIosResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_out1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons7__SoapPhysicalIoResponses(soap, "out", &a->_ns7__writeIosResponse::out, "ns7:SoapPhysicalIoResponses"))
				{	soap_flag_out1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns7__writeIosResponse::out))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns7__writeIosResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__writeIosResponse, SOAP_TYPE__ns7__writeIosResponse, sizeof(_ns7__writeIosResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__writeIosResponse * SOAP_FMAC2 soap_instantiate__ns7__writeIosResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__writeIosResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__writeIosResponse *p;
	size_t k = sizeof(_ns7__writeIosResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__writeIosResponse);
		if (p)
			((_ns7__writeIosResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__writeIosResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__writeIosResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__writeIosResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__writeIosResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__writeIosResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__writeIosResponse(soap, tag ? tag : "ns7:writeIosResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__writeIosResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__writeIosResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__writeIosResponse * SOAP_FMAC4 soap_get__ns7__writeIosResponse(struct soap *soap, _ns7__writeIosResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__writeIosResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__writeIos::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns7__writeIos::ios = NULL;
	this->_ns7__writeIos::values = NULL;
	/* transient soap skipped */
}

void _ns7__writeIos::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons7__SoapPhysicalIoLinks(soap, &this->_ns7__writeIos::ios);
	soap_serialize_PointerTons7__SoapPhysicalIoValues(soap, &this->_ns7__writeIos::values);
#endif
}

int _ns7__writeIos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__writeIos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__writeIos(struct soap *soap, const char *tag, int id, const _ns7__writeIos *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__writeIos), type))
		return soap->error;
	if (!a->_ns7__writeIos::ios)
	{	if (soap_element_empty(soap, "ios"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons7__SoapPhysicalIoLinks(soap, "ios", -1, &a->_ns7__writeIos::ios, ""))
		return soap->error;
	if (!a->_ns7__writeIos::values)
	{	if (soap_element_empty(soap, "values"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons7__SoapPhysicalIoValues(soap, "values", -1, &a->_ns7__writeIos::values, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__writeIos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__writeIos(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__writeIos * SOAP_FMAC4 soap_in__ns7__writeIos(struct soap *soap, const char *tag, _ns7__writeIos *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__writeIos *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__writeIos, sizeof(_ns7__writeIos), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__writeIos)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__writeIos *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ios1 = 1;
	size_t soap_flag_values1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ios1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons7__SoapPhysicalIoLinks(soap, "ios", &a->_ns7__writeIos::ios, "ns7:SoapPhysicalIoLinks"))
				{	soap_flag_ios1--;
					continue;
				}
			}
			if (soap_flag_values1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons7__SoapPhysicalIoValues(soap, "values", &a->_ns7__writeIos::values, "ns7:SoapPhysicalIoValues"))
				{	soap_flag_values1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns7__writeIos::ios || !a->_ns7__writeIos::values))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns7__writeIos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__writeIos, SOAP_TYPE__ns7__writeIos, sizeof(_ns7__writeIos), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__writeIos * SOAP_FMAC2 soap_instantiate__ns7__writeIos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__writeIos(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__writeIos *p;
	size_t k = sizeof(_ns7__writeIos);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__writeIos);
		if (p)
			((_ns7__writeIos*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__writeIos, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__writeIos*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__writeIos location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__writeIos, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__writeIos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__writeIos(soap, tag ? tag : "ns7:writeIos", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__writeIos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__writeIos(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__writeIos * SOAP_FMAC4 soap_get__ns7__writeIos(struct soap *soap, _ns7__writeIos *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__writeIos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__readIosResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns7__readIosResponse::state = NULL;
	/* transient soap skipped */
}

void _ns7__readIosResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons7__SoapPhysicalIosStates(soap, &this->_ns7__readIosResponse::state);
#endif
}

int _ns7__readIosResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__readIosResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__readIosResponse(struct soap *soap, const char *tag, int id, const _ns7__readIosResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__readIosResponse), type))
		return soap->error;
	if (!a->_ns7__readIosResponse::state)
	{	if (soap_element_empty(soap, "state"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons7__SoapPhysicalIosStates(soap, "state", -1, &a->_ns7__readIosResponse::state, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__readIosResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__readIosResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__readIosResponse * SOAP_FMAC4 soap_in__ns7__readIosResponse(struct soap *soap, const char *tag, _ns7__readIosResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__readIosResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__readIosResponse, sizeof(_ns7__readIosResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__readIosResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__readIosResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_state1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_state1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons7__SoapPhysicalIosStates(soap, "state", &a->_ns7__readIosResponse::state, "ns7:SoapPhysicalIosStates"))
				{	soap_flag_state1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns7__readIosResponse::state))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns7__readIosResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__readIosResponse, SOAP_TYPE__ns7__readIosResponse, sizeof(_ns7__readIosResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__readIosResponse * SOAP_FMAC2 soap_instantiate__ns7__readIosResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__readIosResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__readIosResponse *p;
	size_t k = sizeof(_ns7__readIosResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__readIosResponse);
		if (p)
			((_ns7__readIosResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__readIosResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__readIosResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__readIosResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__readIosResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__readIosResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__readIosResponse(soap, tag ? tag : "ns7:readIosResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__readIosResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__readIosResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__readIosResponse * SOAP_FMAC4 soap_get__ns7__readIosResponse(struct soap *soap, _ns7__readIosResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__readIosResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__readIos::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns7__readIos::ios = NULL;
	soap_default_bool(soap, &this->_ns7__readIos::x_getDescription);
	/* transient soap skipped */
}

void _ns7__readIos::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons7__SoapPhysicalIoLinks(soap, &this->_ns7__readIos::ios);
#endif
}

int _ns7__readIos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__readIos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__readIos(struct soap *soap, const char *tag, int id, const _ns7__readIos *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__readIos), type))
		return soap->error;
	if (!a->_ns7__readIos::ios)
	{	if (soap_element_empty(soap, "ios"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons7__SoapPhysicalIoLinks(soap, "ios", -1, &a->_ns7__readIos::ios, ""))
		return soap->error;
	if (soap_out_bool(soap, "x-getDescription", -1, &a->_ns7__readIos::x_getDescription, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__readIos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__readIos(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__readIos * SOAP_FMAC4 soap_in__ns7__readIos(struct soap *soap, const char *tag, _ns7__readIos *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__readIos *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__readIos, sizeof(_ns7__readIos), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__readIos)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__readIos *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ios1 = 1;
	size_t soap_flag_x_getDescription1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ios1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons7__SoapPhysicalIoLinks(soap, "ios", &a->_ns7__readIos::ios, "ns7:SoapPhysicalIoLinks"))
				{	soap_flag_ios1--;
					continue;
				}
			}
			if (soap_flag_x_getDescription1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "x-getDescription", &a->_ns7__readIos::x_getDescription, "xsd:boolean"))
				{	soap_flag_x_getDescription1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns7__readIos::ios || soap_flag_x_getDescription1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns7__readIos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__readIos, SOAP_TYPE__ns7__readIos, sizeof(_ns7__readIos), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__readIos * SOAP_FMAC2 soap_instantiate__ns7__readIos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__readIos(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__readIos *p;
	size_t k = sizeof(_ns7__readIos);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__readIos);
		if (p)
			((_ns7__readIos*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__readIos, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__readIos*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__readIos location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__readIos, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__readIos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__readIos(soap, tag ? tag : "ns7:readIos", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__readIos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__readIos(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__readIos * SOAP_FMAC4 soap_get__ns7__readIos(struct soap *soap, _ns7__readIos *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__readIos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__replaceLineResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns7__replaceLineReturnCode(soap, &this->_ns7__replaceLineResponse::retCode);
	this->_ns7__replaceLineResponse::strOut = NULL;
	/* transient soap skipped */
}

void _ns7__replaceLineResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns7__replaceLineResponse::strOut);
#endif
}

int _ns7__replaceLineResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__replaceLineResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__replaceLineResponse(struct soap *soap, const char *tag, int id, const _ns7__replaceLineResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__replaceLineResponse), type))
		return soap->error;
	if (soap_out_ns7__replaceLineReturnCode(soap, "retCode", -1, &a->_ns7__replaceLineResponse::retCode, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "strOut", -1, &a->_ns7__replaceLineResponse::strOut, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__replaceLineResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__replaceLineResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__replaceLineResponse * SOAP_FMAC4 soap_in__ns7__replaceLineResponse(struct soap *soap, const char *tag, _ns7__replaceLineResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__replaceLineResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__replaceLineResponse, sizeof(_ns7__replaceLineResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__replaceLineResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__replaceLineResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_retCode1 = 1;
	size_t soap_flag_strOut1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_retCode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns7__replaceLineReturnCode(soap, "retCode", &a->_ns7__replaceLineResponse::retCode, "ns7:replaceLineReturnCode"))
				{	soap_flag_retCode1--;
					continue;
				}
			}
			if (soap_flag_strOut1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "strOut", &a->_ns7__replaceLineResponse::strOut, "xsd:string"))
				{	soap_flag_strOut1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_retCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns7__replaceLineResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__replaceLineResponse, SOAP_TYPE__ns7__replaceLineResponse, sizeof(_ns7__replaceLineResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__replaceLineResponse * SOAP_FMAC2 soap_instantiate__ns7__replaceLineResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__replaceLineResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__replaceLineResponse *p;
	size_t k = sizeof(_ns7__replaceLineResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__replaceLineResponse);
		if (p)
			((_ns7__replaceLineResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__replaceLineResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__replaceLineResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__replaceLineResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__replaceLineResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__replaceLineResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__replaceLineResponse(soap, tag ? tag : "ns7:replaceLineResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__replaceLineResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__replaceLineResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__replaceLineResponse * SOAP_FMAC4 soap_get__ns7__replaceLineResponse(struct soap *soap, _ns7__replaceLineResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__replaceLineResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__replaceLine::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns7__replaceLine::line = NULL;
	this->_ns7__replaceLine::newLine = NULL;
	/* transient soap skipped */
}

void _ns7__replaceLine::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons7__SoapProgramLine(soap, &this->_ns7__replaceLine::line);
	soap_serialize_PointerTostd__string(soap, &this->_ns7__replaceLine::newLine);
#endif
}

int _ns7__replaceLine::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__replaceLine(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__replaceLine(struct soap *soap, const char *tag, int id, const _ns7__replaceLine *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__replaceLine), type))
		return soap->error;
	if (!a->_ns7__replaceLine::line)
	{	if (soap_element_empty(soap, "line"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons7__SoapProgramLine(soap, "line", -1, &a->_ns7__replaceLine::line, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "newLine", -1, &a->_ns7__replaceLine::newLine, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__replaceLine::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__replaceLine(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__replaceLine * SOAP_FMAC4 soap_in__ns7__replaceLine(struct soap *soap, const char *tag, _ns7__replaceLine *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__replaceLine *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__replaceLine, sizeof(_ns7__replaceLine), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__replaceLine)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__replaceLine *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_line1 = 1;
	size_t soap_flag_newLine1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_line1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons7__SoapProgramLine(soap, "line", &a->_ns7__replaceLine::line, "ns7:SoapProgramLine"))
				{	soap_flag_line1--;
					continue;
				}
			}
			if (soap_flag_newLine1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "newLine", &a->_ns7__replaceLine::newLine, "xsd:string"))
				{	soap_flag_newLine1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns7__replaceLine::line))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns7__replaceLine *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__replaceLine, SOAP_TYPE__ns7__replaceLine, sizeof(_ns7__replaceLine), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__replaceLine * SOAP_FMAC2 soap_instantiate__ns7__replaceLine(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__replaceLine(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__replaceLine *p;
	size_t k = sizeof(_ns7__replaceLine);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__replaceLine);
		if (p)
			((_ns7__replaceLine*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__replaceLine, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__replaceLine*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__replaceLine location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__replaceLine, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__replaceLine::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__replaceLine(soap, tag ? tag : "ns7:replaceLine", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__replaceLine::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__replaceLine(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__replaceLine * SOAP_FMAC4 soap_get__ns7__replaceLine(struct soap *soap, _ns7__replaceLine *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__replaceLine(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__setCurrentInstructionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns7__setCurrentInstructionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns7__setCurrentInstructionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__setCurrentInstructionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__setCurrentInstructionResponse(struct soap *soap, const char *tag, int id, const _ns7__setCurrentInstructionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__setCurrentInstructionResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__setCurrentInstructionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__setCurrentInstructionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__setCurrentInstructionResponse * SOAP_FMAC4 soap_in__ns7__setCurrentInstructionResponse(struct soap *soap, const char *tag, _ns7__setCurrentInstructionResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__setCurrentInstructionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__setCurrentInstructionResponse, sizeof(_ns7__setCurrentInstructionResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__setCurrentInstructionResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__setCurrentInstructionResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns7__setCurrentInstructionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__setCurrentInstructionResponse, SOAP_TYPE__ns7__setCurrentInstructionResponse, sizeof(_ns7__setCurrentInstructionResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__setCurrentInstructionResponse * SOAP_FMAC2 soap_instantiate__ns7__setCurrentInstructionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__setCurrentInstructionResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__setCurrentInstructionResponse *p;
	size_t k = sizeof(_ns7__setCurrentInstructionResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__setCurrentInstructionResponse);
		if (p)
			((_ns7__setCurrentInstructionResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__setCurrentInstructionResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__setCurrentInstructionResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__setCurrentInstructionResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__setCurrentInstructionResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__setCurrentInstructionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__setCurrentInstructionResponse(soap, tag ? tag : "ns7:setCurrentInstructionResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__setCurrentInstructionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__setCurrentInstructionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__setCurrentInstructionResponse * SOAP_FMAC4 soap_get__ns7__setCurrentInstructionResponse(struct soap *soap, _ns7__setCurrentInstructionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__setCurrentInstructionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__setCurrentInstruction::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns7__setCurrentInstruction::taskName = NULL;
	this->_ns7__setCurrentInstruction::createdBy = NULL;
	soap_default_bool(soap, &this->_ns7__setCurrentInstruction::resetMotion);
	this->_ns7__setCurrentInstruction::line = NULL;
	/* transient soap skipped */
}

void _ns7__setCurrentInstruction::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns7__setCurrentInstruction::taskName);
	soap_serialize_PointerTostd__string(soap, &this->_ns7__setCurrentInstruction::createdBy);
	soap_serialize_PointerTons7__SoapProgramLine(soap, &this->_ns7__setCurrentInstruction::line);
#endif
}

int _ns7__setCurrentInstruction::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__setCurrentInstruction(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__setCurrentInstruction(struct soap *soap, const char *tag, int id, const _ns7__setCurrentInstruction *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__setCurrentInstruction), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "taskName", -1, &a->_ns7__setCurrentInstruction::taskName, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "createdBy", -1, &a->_ns7__setCurrentInstruction::createdBy, ""))
		return soap->error;
	if (soap_out_bool(soap, "resetMotion", -1, &a->_ns7__setCurrentInstruction::resetMotion, ""))
		return soap->error;
	if (!a->_ns7__setCurrentInstruction::line)
	{	if (soap_element_empty(soap, "line"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons7__SoapProgramLine(soap, "line", -1, &a->_ns7__setCurrentInstruction::line, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__setCurrentInstruction::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__setCurrentInstruction(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__setCurrentInstruction * SOAP_FMAC4 soap_in__ns7__setCurrentInstruction(struct soap *soap, const char *tag, _ns7__setCurrentInstruction *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__setCurrentInstruction *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__setCurrentInstruction, sizeof(_ns7__setCurrentInstruction), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__setCurrentInstruction)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__setCurrentInstruction *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_taskName1 = 1;
	size_t soap_flag_createdBy1 = 1;
	size_t soap_flag_resetMotion1 = 1;
	size_t soap_flag_line1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_taskName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "taskName", &a->_ns7__setCurrentInstruction::taskName, "xsd:string"))
				{	soap_flag_taskName1--;
					continue;
				}
			}
			if (soap_flag_createdBy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "createdBy", &a->_ns7__setCurrentInstruction::createdBy, "xsd:string"))
				{	soap_flag_createdBy1--;
					continue;
				}
			}
			if (soap_flag_resetMotion1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "resetMotion", &a->_ns7__setCurrentInstruction::resetMotion, "xsd:boolean"))
				{	soap_flag_resetMotion1--;
					continue;
				}
			}
			if (soap_flag_line1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons7__SoapProgramLine(soap, "line", &a->_ns7__setCurrentInstruction::line, "ns7:SoapProgramLine"))
				{	soap_flag_line1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resetMotion1 > 0 || !a->_ns7__setCurrentInstruction::line))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns7__setCurrentInstruction *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__setCurrentInstruction, SOAP_TYPE__ns7__setCurrentInstruction, sizeof(_ns7__setCurrentInstruction), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__setCurrentInstruction * SOAP_FMAC2 soap_instantiate__ns7__setCurrentInstruction(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__setCurrentInstruction(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__setCurrentInstruction *p;
	size_t k = sizeof(_ns7__setCurrentInstruction);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__setCurrentInstruction);
		if (p)
			((_ns7__setCurrentInstruction*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__setCurrentInstruction, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__setCurrentInstruction*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__setCurrentInstruction location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__setCurrentInstruction, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__setCurrentInstruction::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__setCurrentInstruction(soap, tag ? tag : "ns7:setCurrentInstruction", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__setCurrentInstruction::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__setCurrentInstruction(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__setCurrentInstruction * SOAP_FMAC4 soap_get__ns7__setCurrentInstruction(struct soap *soap, _ns7__setCurrentInstruction *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__setCurrentInstruction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__setProjectAsModifiedResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns7__setProjectAsModifiedResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns7__setProjectAsModifiedResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__setProjectAsModifiedResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__setProjectAsModifiedResponse(struct soap *soap, const char *tag, int id, const _ns7__setProjectAsModifiedResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__setProjectAsModifiedResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__setProjectAsModifiedResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__setProjectAsModifiedResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__setProjectAsModifiedResponse * SOAP_FMAC4 soap_in__ns7__setProjectAsModifiedResponse(struct soap *soap, const char *tag, _ns7__setProjectAsModifiedResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__setProjectAsModifiedResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__setProjectAsModifiedResponse, sizeof(_ns7__setProjectAsModifiedResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__setProjectAsModifiedResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__setProjectAsModifiedResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns7__setProjectAsModifiedResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__setProjectAsModifiedResponse, SOAP_TYPE__ns7__setProjectAsModifiedResponse, sizeof(_ns7__setProjectAsModifiedResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__setProjectAsModifiedResponse * SOAP_FMAC2 soap_instantiate__ns7__setProjectAsModifiedResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__setProjectAsModifiedResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__setProjectAsModifiedResponse *p;
	size_t k = sizeof(_ns7__setProjectAsModifiedResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__setProjectAsModifiedResponse);
		if (p)
			((_ns7__setProjectAsModifiedResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__setProjectAsModifiedResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__setProjectAsModifiedResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__setProjectAsModifiedResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__setProjectAsModifiedResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__setProjectAsModifiedResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__setProjectAsModifiedResponse(soap, tag ? tag : "ns7:setProjectAsModifiedResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__setProjectAsModifiedResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__setProjectAsModifiedResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__setProjectAsModifiedResponse * SOAP_FMAC4 soap_get__ns7__setProjectAsModifiedResponse(struct soap *soap, _ns7__setProjectAsModifiedResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__setProjectAsModifiedResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__setProjectAsModified::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns7__setProjectAsModified::prjName = NULL;
	/* transient soap skipped */
}

void _ns7__setProjectAsModified::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns7__setProjectAsModified::prjName);
#endif
}

int _ns7__setProjectAsModified::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__setProjectAsModified(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__setProjectAsModified(struct soap *soap, const char *tag, int id, const _ns7__setProjectAsModified *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__setProjectAsModified), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "prjName", -1, &a->_ns7__setProjectAsModified::prjName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__setProjectAsModified::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__setProjectAsModified(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__setProjectAsModified * SOAP_FMAC4 soap_in__ns7__setProjectAsModified(struct soap *soap, const char *tag, _ns7__setProjectAsModified *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__setProjectAsModified *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__setProjectAsModified, sizeof(_ns7__setProjectAsModified), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__setProjectAsModified)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__setProjectAsModified *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_prjName1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_prjName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "prjName", &a->_ns7__setProjectAsModified::prjName, "xsd:string"))
				{	soap_flag_prjName1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns7__setProjectAsModified *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__setProjectAsModified, SOAP_TYPE__ns7__setProjectAsModified, sizeof(_ns7__setProjectAsModified), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__setProjectAsModified * SOAP_FMAC2 soap_instantiate__ns7__setProjectAsModified(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__setProjectAsModified(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__setProjectAsModified *p;
	size_t k = sizeof(_ns7__setProjectAsModified);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__setProjectAsModified);
		if (p)
			((_ns7__setProjectAsModified*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__setProjectAsModified, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__setProjectAsModified*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__setProjectAsModified location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__setProjectAsModified, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__setProjectAsModified::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__setProjectAsModified(soap, tag ? tag : "ns7:setProjectAsModified", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__setProjectAsModified::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__setProjectAsModified(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__setProjectAsModified * SOAP_FMAC4 soap_get__ns7__setProjectAsModified(struct soap *soap, _ns7__setProjectAsModified *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__setProjectAsModified(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__execVal3Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns7__execVal3ReturnCode(soap, &this->_ns7__execVal3Response::retCode);
	this->_ns7__execVal3Response::strOut = NULL;
	/* transient soap skipped */
}

void _ns7__execVal3Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns7__execVal3Response::strOut);
#endif
}

int _ns7__execVal3Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__execVal3Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__execVal3Response(struct soap *soap, const char *tag, int id, const _ns7__execVal3Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__execVal3Response), type))
		return soap->error;
	if (soap_out_ns7__execVal3ReturnCode(soap, "retCode", -1, &a->_ns7__execVal3Response::retCode, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "strOut", -1, &a->_ns7__execVal3Response::strOut, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__execVal3Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__execVal3Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__execVal3Response * SOAP_FMAC4 soap_in__ns7__execVal3Response(struct soap *soap, const char *tag, _ns7__execVal3Response *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__execVal3Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__execVal3Response, sizeof(_ns7__execVal3Response), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__execVal3Response)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__execVal3Response *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_retCode1 = 1;
	size_t soap_flag_strOut1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_retCode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns7__execVal3ReturnCode(soap, "retCode", &a->_ns7__execVal3Response::retCode, "ns7:execVal3ReturnCode"))
				{	soap_flag_retCode1--;
					continue;
				}
			}
			if (soap_flag_strOut1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "strOut", &a->_ns7__execVal3Response::strOut, "xsd:string"))
				{	soap_flag_strOut1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_retCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns7__execVal3Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__execVal3Response, SOAP_TYPE__ns7__execVal3Response, sizeof(_ns7__execVal3Response), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__execVal3Response * SOAP_FMAC2 soap_instantiate__ns7__execVal3Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__execVal3Response(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__execVal3Response *p;
	size_t k = sizeof(_ns7__execVal3Response);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__execVal3Response);
		if (p)
			((_ns7__execVal3Response*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__execVal3Response, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__execVal3Response*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__execVal3Response location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__execVal3Response, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__execVal3Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__execVal3Response(soap, tag ? tag : "ns7:execVal3Response", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__execVal3Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__execVal3Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__execVal3Response * SOAP_FMAC4 soap_get__ns7__execVal3Response(struct soap *soap, _ns7__execVal3Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__execVal3Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__execVal3::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns7__execVal3::prjName = NULL;
	this->_ns7__execVal3::taskName = NULL;
	this->_ns7__execVal3::createdBy = NULL;
	soap_default_int(soap, &this->_ns7__execVal3::stackFrameIndex);
	this->_ns7__execVal3::cmd = NULL;
	/* transient soap skipped */
}

void _ns7__execVal3::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns7__execVal3::prjName);
	soap_serialize_PointerTostd__string(soap, &this->_ns7__execVal3::taskName);
	soap_serialize_PointerTostd__string(soap, &this->_ns7__execVal3::createdBy);
	soap_serialize_PointerTostd__string(soap, &this->_ns7__execVal3::cmd);
#endif
}

int _ns7__execVal3::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__execVal3(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__execVal3(struct soap *soap, const char *tag, int id, const _ns7__execVal3 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__execVal3), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "prjName", -1, &a->_ns7__execVal3::prjName, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "taskName", -1, &a->_ns7__execVal3::taskName, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "createdBy", -1, &a->_ns7__execVal3::createdBy, ""))
		return soap->error;
	if (soap_out_int(soap, "stackFrameIndex", -1, &a->_ns7__execVal3::stackFrameIndex, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "cmd", -1, &a->_ns7__execVal3::cmd, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__execVal3::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__execVal3(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__execVal3 * SOAP_FMAC4 soap_in__ns7__execVal3(struct soap *soap, const char *tag, _ns7__execVal3 *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__execVal3 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__execVal3, sizeof(_ns7__execVal3), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__execVal3)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__execVal3 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_prjName1 = 1;
	size_t soap_flag_taskName1 = 1;
	size_t soap_flag_createdBy1 = 1;
	size_t soap_flag_stackFrameIndex1 = 1;
	size_t soap_flag_cmd1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_prjName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "prjName", &a->_ns7__execVal3::prjName, "xsd:string"))
				{	soap_flag_prjName1--;
					continue;
				}
			}
			if (soap_flag_taskName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "taskName", &a->_ns7__execVal3::taskName, "xsd:string"))
				{	soap_flag_taskName1--;
					continue;
				}
			}
			if (soap_flag_createdBy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "createdBy", &a->_ns7__execVal3::createdBy, "xsd:string"))
				{	soap_flag_createdBy1--;
					continue;
				}
			}
			if (soap_flag_stackFrameIndex1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "stackFrameIndex", &a->_ns7__execVal3::stackFrameIndex, "xsd:int"))
				{	soap_flag_stackFrameIndex1--;
					continue;
				}
			}
			if (soap_flag_cmd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "cmd", &a->_ns7__execVal3::cmd, "xsd:string"))
				{	soap_flag_cmd1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_stackFrameIndex1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns7__execVal3 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__execVal3, SOAP_TYPE__ns7__execVal3, sizeof(_ns7__execVal3), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__execVal3 * SOAP_FMAC2 soap_instantiate__ns7__execVal3(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__execVal3(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__execVal3 *p;
	size_t k = sizeof(_ns7__execVal3);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__execVal3);
		if (p)
			((_ns7__execVal3*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__execVal3, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__execVal3*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__execVal3 location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__execVal3, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__execVal3::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__execVal3(soap, tag ? tag : "ns7:execVal3", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__execVal3::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__execVal3(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__execVal3 * SOAP_FMAC4 soap_get__ns7__execVal3(struct soap *soap, _ns7__execVal3 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__execVal3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__getWatchResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns7__getWatchResponse::data = NULL;
	/* transient soap skipped */
}

void _ns7__getWatchResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons7__MimeData(soap, &this->_ns7__getWatchResponse::data);
#endif
}

int _ns7__getWatchResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__getWatchResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__getWatchResponse(struct soap *soap, const char *tag, int id, const _ns7__getWatchResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__getWatchResponse), type))
		return soap->error;
	if (!a->_ns7__getWatchResponse::data)
	{	if (soap_element_empty(soap, "data"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons7__MimeData(soap, "data", -1, &a->_ns7__getWatchResponse::data, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__getWatchResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__getWatchResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__getWatchResponse * SOAP_FMAC4 soap_in__ns7__getWatchResponse(struct soap *soap, const char *tag, _ns7__getWatchResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__getWatchResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__getWatchResponse, sizeof(_ns7__getWatchResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__getWatchResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__getWatchResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_data1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_data1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons7__MimeData(soap, "data", &a->_ns7__getWatchResponse::data, "ns7:MimeData"))
				{	soap_flag_data1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns7__getWatchResponse::data))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns7__getWatchResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__getWatchResponse, SOAP_TYPE__ns7__getWatchResponse, sizeof(_ns7__getWatchResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__getWatchResponse * SOAP_FMAC2 soap_instantiate__ns7__getWatchResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__getWatchResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__getWatchResponse *p;
	size_t k = sizeof(_ns7__getWatchResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__getWatchResponse);
		if (p)
			((_ns7__getWatchResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__getWatchResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__getWatchResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__getWatchResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__getWatchResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__getWatchResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__getWatchResponse(soap, tag ? tag : "ns7:getWatchResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__getWatchResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__getWatchResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__getWatchResponse * SOAP_FMAC4 soap_get__ns7__getWatchResponse(struct soap *soap, _ns7__getWatchResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__getWatchResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__getWatches::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns7__getWatches::watch = NULL;
	/* transient soap skipped */
}

void _ns7__getWatches::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons7__SoapWatches(soap, &this->_ns7__getWatches::watch);
#endif
}

int _ns7__getWatches::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__getWatches(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__getWatches(struct soap *soap, const char *tag, int id, const _ns7__getWatches *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__getWatches), type))
		return soap->error;
	if (!a->_ns7__getWatches::watch)
	{	if (soap_element_empty(soap, "watch"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons7__SoapWatches(soap, "watch", -1, &a->_ns7__getWatches::watch, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__getWatches::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__getWatches(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__getWatches * SOAP_FMAC4 soap_in__ns7__getWatches(struct soap *soap, const char *tag, _ns7__getWatches *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__getWatches *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__getWatches, sizeof(_ns7__getWatches), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__getWatches)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__getWatches *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_watch1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_watch1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons7__SoapWatches(soap, "watch", &a->_ns7__getWatches::watch, "ns7:SoapWatches"))
				{	soap_flag_watch1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns7__getWatches::watch))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns7__getWatches *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__getWatches, SOAP_TYPE__ns7__getWatches, sizeof(_ns7__getWatches), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__getWatches * SOAP_FMAC2 soap_instantiate__ns7__getWatches(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__getWatches(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__getWatches *p;
	size_t k = sizeof(_ns7__getWatches);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__getWatches);
		if (p)
			((_ns7__getWatches*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__getWatches, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__getWatches*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__getWatches location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__getWatches, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__getWatches::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__getWatches(soap, tag ? tag : "ns7:getWatches", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__getWatches::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__getWatches(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__getWatches * SOAP_FMAC4 soap_get__ns7__getWatches(struct soap *soap, _ns7__getWatches *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__getWatches(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__getStackFrameResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns7__getStackFrameResponse::data = NULL;
	/* transient soap skipped */
}

void _ns7__getStackFrameResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons7__MimeData(soap, &this->_ns7__getStackFrameResponse::data);
#endif
}

int _ns7__getStackFrameResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__getStackFrameResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__getStackFrameResponse(struct soap *soap, const char *tag, int id, const _ns7__getStackFrameResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__getStackFrameResponse), type))
		return soap->error;
	if (!a->_ns7__getStackFrameResponse::data)
	{	if (soap_element_empty(soap, "data"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons7__MimeData(soap, "data", -1, &a->_ns7__getStackFrameResponse::data, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__getStackFrameResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__getStackFrameResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__getStackFrameResponse * SOAP_FMAC4 soap_in__ns7__getStackFrameResponse(struct soap *soap, const char *tag, _ns7__getStackFrameResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__getStackFrameResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__getStackFrameResponse, sizeof(_ns7__getStackFrameResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__getStackFrameResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__getStackFrameResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_data1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_data1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons7__MimeData(soap, "data", &a->_ns7__getStackFrameResponse::data, "ns7:MimeData"))
				{	soap_flag_data1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns7__getStackFrameResponse::data))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns7__getStackFrameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__getStackFrameResponse, SOAP_TYPE__ns7__getStackFrameResponse, sizeof(_ns7__getStackFrameResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__getStackFrameResponse * SOAP_FMAC2 soap_instantiate__ns7__getStackFrameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__getStackFrameResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__getStackFrameResponse *p;
	size_t k = sizeof(_ns7__getStackFrameResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__getStackFrameResponse);
		if (p)
			((_ns7__getStackFrameResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__getStackFrameResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__getStackFrameResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__getStackFrameResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__getStackFrameResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__getStackFrameResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__getStackFrameResponse(soap, tag ? tag : "ns7:getStackFrameResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__getStackFrameResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__getStackFrameResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__getStackFrameResponse * SOAP_FMAC4 soap_get__ns7__getStackFrameResponse(struct soap *soap, _ns7__getStackFrameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__getStackFrameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__getStackFrame::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns7__getStackFrame::taskName = NULL;
	this->_ns7__getStackFrame::createdBy = NULL;
	soap_default_int(soap, &this->_ns7__getStackFrame::stackFrameIndex);
	/* transient soap skipped */
}

void _ns7__getStackFrame::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns7__getStackFrame::taskName);
	soap_serialize_PointerTostd__string(soap, &this->_ns7__getStackFrame::createdBy);
#endif
}

int _ns7__getStackFrame::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__getStackFrame(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__getStackFrame(struct soap *soap, const char *tag, int id, const _ns7__getStackFrame *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__getStackFrame), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "taskName", -1, &a->_ns7__getStackFrame::taskName, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "createdBy", -1, &a->_ns7__getStackFrame::createdBy, ""))
		return soap->error;
	if (soap_out_int(soap, "stackFrameIndex", -1, &a->_ns7__getStackFrame::stackFrameIndex, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__getStackFrame::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__getStackFrame(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__getStackFrame * SOAP_FMAC4 soap_in__ns7__getStackFrame(struct soap *soap, const char *tag, _ns7__getStackFrame *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__getStackFrame *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__getStackFrame, sizeof(_ns7__getStackFrame), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__getStackFrame)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__getStackFrame *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_taskName1 = 1;
	size_t soap_flag_createdBy1 = 1;
	size_t soap_flag_stackFrameIndex1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_taskName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "taskName", &a->_ns7__getStackFrame::taskName, "xsd:string"))
				{	soap_flag_taskName1--;
					continue;
				}
			}
			if (soap_flag_createdBy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "createdBy", &a->_ns7__getStackFrame::createdBy, "xsd:string"))
				{	soap_flag_createdBy1--;
					continue;
				}
			}
			if (soap_flag_stackFrameIndex1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "stackFrameIndex", &a->_ns7__getStackFrame::stackFrameIndex, "xsd:int"))
				{	soap_flag_stackFrameIndex1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_stackFrameIndex1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns7__getStackFrame *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__getStackFrame, SOAP_TYPE__ns7__getStackFrame, sizeof(_ns7__getStackFrame), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__getStackFrame * SOAP_FMAC2 soap_instantiate__ns7__getStackFrame(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__getStackFrame(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__getStackFrame *p;
	size_t k = sizeof(_ns7__getStackFrame);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__getStackFrame);
		if (p)
			((_ns7__getStackFrame*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__getStackFrame, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__getStackFrame*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__getStackFrame location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__getStackFrame, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__getStackFrame::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__getStackFrame(soap, tag ? tag : "ns7:getStackFrame", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__getStackFrame::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__getStackFrame(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__getStackFrame * SOAP_FMAC4 soap_get__ns7__getStackFrame(struct soap *soap, _ns7__getStackFrame *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__getStackFrame(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__getCallStackResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns7__getCallStackResponse::callStack = NULL;
	/* transient soap skipped */
}

void _ns7__getCallStackResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons7__SoapCallStack(soap, &this->_ns7__getCallStackResponse::callStack);
#endif
}

int _ns7__getCallStackResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__getCallStackResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__getCallStackResponse(struct soap *soap, const char *tag, int id, const _ns7__getCallStackResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__getCallStackResponse), type))
		return soap->error;
	if (!a->_ns7__getCallStackResponse::callStack)
	{	if (soap_element_empty(soap, "callStack"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons7__SoapCallStack(soap, "callStack", -1, &a->_ns7__getCallStackResponse::callStack, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__getCallStackResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__getCallStackResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__getCallStackResponse * SOAP_FMAC4 soap_in__ns7__getCallStackResponse(struct soap *soap, const char *tag, _ns7__getCallStackResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__getCallStackResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__getCallStackResponse, sizeof(_ns7__getCallStackResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__getCallStackResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__getCallStackResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_callStack1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_callStack1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons7__SoapCallStack(soap, "callStack", &a->_ns7__getCallStackResponse::callStack, "ns7:SoapCallStack"))
				{	soap_flag_callStack1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns7__getCallStackResponse::callStack))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns7__getCallStackResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__getCallStackResponse, SOAP_TYPE__ns7__getCallStackResponse, sizeof(_ns7__getCallStackResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__getCallStackResponse * SOAP_FMAC2 soap_instantiate__ns7__getCallStackResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__getCallStackResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__getCallStackResponse *p;
	size_t k = sizeof(_ns7__getCallStackResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__getCallStackResponse);
		if (p)
			((_ns7__getCallStackResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__getCallStackResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__getCallStackResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__getCallStackResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__getCallStackResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__getCallStackResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__getCallStackResponse(soap, tag ? tag : "ns7:getCallStackResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__getCallStackResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__getCallStackResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__getCallStackResponse * SOAP_FMAC4 soap_get__ns7__getCallStackResponse(struct soap *soap, _ns7__getCallStackResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__getCallStackResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__getCallStack::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns7__getCallStack::taskName = NULL;
	this->_ns7__getCallStack::createdBy = NULL;
	/* transient soap skipped */
}

void _ns7__getCallStack::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns7__getCallStack::taskName);
	soap_serialize_PointerTostd__string(soap, &this->_ns7__getCallStack::createdBy);
#endif
}

int _ns7__getCallStack::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__getCallStack(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__getCallStack(struct soap *soap, const char *tag, int id, const _ns7__getCallStack *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__getCallStack), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "taskName", -1, &a->_ns7__getCallStack::taskName, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "createdBy", -1, &a->_ns7__getCallStack::createdBy, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__getCallStack::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__getCallStack(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__getCallStack * SOAP_FMAC4 soap_in__ns7__getCallStack(struct soap *soap, const char *tag, _ns7__getCallStack *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__getCallStack *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__getCallStack, sizeof(_ns7__getCallStack), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__getCallStack)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__getCallStack *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_taskName1 = 1;
	size_t soap_flag_createdBy1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_taskName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "taskName", &a->_ns7__getCallStack::taskName, "xsd:string"))
				{	soap_flag_taskName1--;
					continue;
				}
			}
			if (soap_flag_createdBy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "createdBy", &a->_ns7__getCallStack::createdBy, "xsd:string"))
				{	soap_flag_createdBy1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns7__getCallStack *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__getCallStack, SOAP_TYPE__ns7__getCallStack, sizeof(_ns7__getCallStack), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__getCallStack * SOAP_FMAC2 soap_instantiate__ns7__getCallStack(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__getCallStack(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__getCallStack *p;
	size_t k = sizeof(_ns7__getCallStack);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__getCallStack);
		if (p)
			((_ns7__getCallStack*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__getCallStack, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__getCallStack*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__getCallStack location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__getCallStack, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__getCallStack::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__getCallStack(soap, tag ? tag : "ns7:getCallStack", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__getCallStack::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__getCallStack(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__getCallStack * SOAP_FMAC4 soap_get__ns7__getCallStack(struct soap *soap, _ns7__getCallStack *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__getCallStack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__unsubscribeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns7__unsubscribeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns7__unsubscribeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__unsubscribeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__unsubscribeResponse(struct soap *soap, const char *tag, int id, const _ns7__unsubscribeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__unsubscribeResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__unsubscribeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__unsubscribeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__unsubscribeResponse * SOAP_FMAC4 soap_in__ns7__unsubscribeResponse(struct soap *soap, const char *tag, _ns7__unsubscribeResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__unsubscribeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__unsubscribeResponse, sizeof(_ns7__unsubscribeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__unsubscribeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__unsubscribeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns7__unsubscribeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__unsubscribeResponse, SOAP_TYPE__ns7__unsubscribeResponse, sizeof(_ns7__unsubscribeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__unsubscribeResponse * SOAP_FMAC2 soap_instantiate__ns7__unsubscribeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__unsubscribeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__unsubscribeResponse *p;
	size_t k = sizeof(_ns7__unsubscribeResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__unsubscribeResponse);
		if (p)
			((_ns7__unsubscribeResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__unsubscribeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__unsubscribeResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__unsubscribeResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__unsubscribeResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__unsubscribeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__unsubscribeResponse(soap, tag ? tag : "ns7:unsubscribeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__unsubscribeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__unsubscribeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__unsubscribeResponse * SOAP_FMAC4 soap_get__ns7__unsubscribeResponse(struct soap *soap, _ns7__unsubscribeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__unsubscribeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__unsubscribeToControllerEvents::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns7__unsubscribeToControllerEvents::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns7__unsubscribeToControllerEvents::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__unsubscribeToControllerEvents(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__unsubscribeToControllerEvents(struct soap *soap, const char *tag, int id, const _ns7__unsubscribeToControllerEvents *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__unsubscribeToControllerEvents), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__unsubscribeToControllerEvents::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__unsubscribeToControllerEvents(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__unsubscribeToControllerEvents * SOAP_FMAC4 soap_in__ns7__unsubscribeToControllerEvents(struct soap *soap, const char *tag, _ns7__unsubscribeToControllerEvents *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__unsubscribeToControllerEvents *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__unsubscribeToControllerEvents, sizeof(_ns7__unsubscribeToControllerEvents), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__unsubscribeToControllerEvents)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__unsubscribeToControllerEvents *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns7__unsubscribeToControllerEvents *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__unsubscribeToControllerEvents, SOAP_TYPE__ns7__unsubscribeToControllerEvents, sizeof(_ns7__unsubscribeToControllerEvents), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__unsubscribeToControllerEvents * SOAP_FMAC2 soap_instantiate__ns7__unsubscribeToControllerEvents(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__unsubscribeToControllerEvents(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__unsubscribeToControllerEvents *p;
	size_t k = sizeof(_ns7__unsubscribeToControllerEvents);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__unsubscribeToControllerEvents);
		if (p)
			((_ns7__unsubscribeToControllerEvents*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__unsubscribeToControllerEvents, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__unsubscribeToControllerEvents*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__unsubscribeToControllerEvents location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__unsubscribeToControllerEvents, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__unsubscribeToControllerEvents::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__unsubscribeToControllerEvents(soap, tag ? tag : "ns7:unsubscribeToControllerEvents", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__unsubscribeToControllerEvents::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__unsubscribeToControllerEvents(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__unsubscribeToControllerEvents * SOAP_FMAC4 soap_get__ns7__unsubscribeToControllerEvents(struct soap *soap, _ns7__unsubscribeToControllerEvents *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__unsubscribeToControllerEvents(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__subscribeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns7__subscribeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns7__subscribeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__subscribeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__subscribeResponse(struct soap *soap, const char *tag, int id, const _ns7__subscribeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__subscribeResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__subscribeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__subscribeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__subscribeResponse * SOAP_FMAC4 soap_in__ns7__subscribeResponse(struct soap *soap, const char *tag, _ns7__subscribeResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__subscribeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__subscribeResponse, sizeof(_ns7__subscribeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__subscribeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__subscribeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns7__subscribeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__subscribeResponse, SOAP_TYPE__ns7__subscribeResponse, sizeof(_ns7__subscribeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__subscribeResponse * SOAP_FMAC2 soap_instantiate__ns7__subscribeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__subscribeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__subscribeResponse *p;
	size_t k = sizeof(_ns7__subscribeResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__subscribeResponse);
		if (p)
			((_ns7__subscribeResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__subscribeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__subscribeResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__subscribeResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__subscribeResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__subscribeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__subscribeResponse(soap, tag ? tag : "ns7:subscribeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__subscribeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__subscribeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__subscribeResponse * SOAP_FMAC4 soap_get__ns7__subscribeResponse(struct soap *soap, _ns7__subscribeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__subscribeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__subscribeToControllerEvents::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns7__subscribeToControllerEvents::serviceUrl = NULL;
	soap_default_int(soap, &this->_ns7__subscribeToControllerEvents::sendInterval);
	/* transient soap skipped */
}

void _ns7__subscribeToControllerEvents::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns7__subscribeToControllerEvents::serviceUrl);
#endif
}

int _ns7__subscribeToControllerEvents::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__subscribeToControllerEvents(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__subscribeToControllerEvents(struct soap *soap, const char *tag, int id, const _ns7__subscribeToControllerEvents *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__subscribeToControllerEvents), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "serviceUrl", -1, &a->_ns7__subscribeToControllerEvents::serviceUrl, ""))
		return soap->error;
	if (soap_out_int(soap, "sendInterval", -1, &a->_ns7__subscribeToControllerEvents::sendInterval, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__subscribeToControllerEvents::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__subscribeToControllerEvents(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__subscribeToControllerEvents * SOAP_FMAC4 soap_in__ns7__subscribeToControllerEvents(struct soap *soap, const char *tag, _ns7__subscribeToControllerEvents *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__subscribeToControllerEvents *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__subscribeToControllerEvents, sizeof(_ns7__subscribeToControllerEvents), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__subscribeToControllerEvents)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__subscribeToControllerEvents *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_serviceUrl1 = 1;
	size_t soap_flag_sendInterval1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_serviceUrl1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "serviceUrl", &a->_ns7__subscribeToControllerEvents::serviceUrl, "xsd:string"))
				{	soap_flag_serviceUrl1--;
					continue;
				}
			}
			if (soap_flag_sendInterval1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "sendInterval", &a->_ns7__subscribeToControllerEvents::sendInterval, "xsd:int"))
				{	soap_flag_sendInterval1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sendInterval1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns7__subscribeToControllerEvents *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__subscribeToControllerEvents, SOAP_TYPE__ns7__subscribeToControllerEvents, sizeof(_ns7__subscribeToControllerEvents), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__subscribeToControllerEvents * SOAP_FMAC2 soap_instantiate__ns7__subscribeToControllerEvents(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__subscribeToControllerEvents(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__subscribeToControllerEvents *p;
	size_t k = sizeof(_ns7__subscribeToControllerEvents);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__subscribeToControllerEvents);
		if (p)
			((_ns7__subscribeToControllerEvents*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__subscribeToControllerEvents, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__subscribeToControllerEvents*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__subscribeToControllerEvents location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__subscribeToControllerEvents, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__subscribeToControllerEvents::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__subscribeToControllerEvents(soap, tag ? tag : "ns7:subscribeToControllerEvents", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__subscribeToControllerEvents::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__subscribeToControllerEvents(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__subscribeToControllerEvents * SOAP_FMAC4 soap_get__ns7__subscribeToControllerEvents(struct soap *soap, _ns7__subscribeToControllerEvents *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__subscribeToControllerEvents(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__taskStepResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns7__taskStepResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns7__taskStepResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__taskStepResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__taskStepResponse(struct soap *soap, const char *tag, int id, const _ns7__taskStepResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__taskStepResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__taskStepResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__taskStepResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__taskStepResponse * SOAP_FMAC4 soap_in__ns7__taskStepResponse(struct soap *soap, const char *tag, _ns7__taskStepResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__taskStepResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__taskStepResponse, sizeof(_ns7__taskStepResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__taskStepResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__taskStepResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns7__taskStepResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__taskStepResponse, SOAP_TYPE__ns7__taskStepResponse, sizeof(_ns7__taskStepResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__taskStepResponse * SOAP_FMAC2 soap_instantiate__ns7__taskStepResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__taskStepResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__taskStepResponse *p;
	size_t k = sizeof(_ns7__taskStepResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__taskStepResponse);
		if (p)
			((_ns7__taskStepResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__taskStepResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__taskStepResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__taskStepResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__taskStepResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__taskStepResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__taskStepResponse(soap, tag ? tag : "ns7:taskStepResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__taskStepResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__taskStepResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__taskStepResponse * SOAP_FMAC4 soap_get__ns7__taskStepResponse(struct soap *soap, _ns7__taskStepResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__taskStepResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__taskStep::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns7__taskStep::taskName = NULL;
	this->_ns7__taskStep::createdBy = NULL;
	soap_default_ns7__SoapTaskStep(soap, &this->_ns7__taskStep::stepType);
	/* transient soap skipped */
}

void _ns7__taskStep::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns7__taskStep::taskName);
	soap_serialize_PointerTostd__string(soap, &this->_ns7__taskStep::createdBy);
#endif
}

int _ns7__taskStep::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__taskStep(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__taskStep(struct soap *soap, const char *tag, int id, const _ns7__taskStep *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__taskStep), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "taskName", -1, &a->_ns7__taskStep::taskName, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "createdBy", -1, &a->_ns7__taskStep::createdBy, ""))
		return soap->error;
	if (soap_out_ns7__SoapTaskStep(soap, "stepType", -1, &a->_ns7__taskStep::stepType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__taskStep::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__taskStep(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__taskStep * SOAP_FMAC4 soap_in__ns7__taskStep(struct soap *soap, const char *tag, _ns7__taskStep *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__taskStep *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__taskStep, sizeof(_ns7__taskStep), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__taskStep)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__taskStep *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_taskName1 = 1;
	size_t soap_flag_createdBy1 = 1;
	size_t soap_flag_stepType1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_taskName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "taskName", &a->_ns7__taskStep::taskName, "xsd:string"))
				{	soap_flag_taskName1--;
					continue;
				}
			}
			if (soap_flag_createdBy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "createdBy", &a->_ns7__taskStep::createdBy, "xsd:string"))
				{	soap_flag_createdBy1--;
					continue;
				}
			}
			if (soap_flag_stepType1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns7__SoapTaskStep(soap, "stepType", &a->_ns7__taskStep::stepType, "ns7:SoapTaskStep"))
				{	soap_flag_stepType1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_stepType1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns7__taskStep *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__taskStep, SOAP_TYPE__ns7__taskStep, sizeof(_ns7__taskStep), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__taskStep * SOAP_FMAC2 soap_instantiate__ns7__taskStep(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__taskStep(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__taskStep *p;
	size_t k = sizeof(_ns7__taskStep);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__taskStep);
		if (p)
			((_ns7__taskStep*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__taskStep, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__taskStep*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__taskStep location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__taskStep, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__taskStep::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__taskStep(soap, tag ? tag : "ns7:taskStep", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__taskStep::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__taskStep(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__taskStep * SOAP_FMAC4 soap_get__ns7__taskStep(struct soap *soap, _ns7__taskStep *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__taskStep(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__taskKillResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns7__taskKillResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns7__taskKillResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__taskKillResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__taskKillResponse(struct soap *soap, const char *tag, int id, const _ns7__taskKillResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__taskKillResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__taskKillResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__taskKillResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__taskKillResponse * SOAP_FMAC4 soap_in__ns7__taskKillResponse(struct soap *soap, const char *tag, _ns7__taskKillResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__taskKillResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__taskKillResponse, sizeof(_ns7__taskKillResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__taskKillResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__taskKillResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns7__taskKillResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__taskKillResponse, SOAP_TYPE__ns7__taskKillResponse, sizeof(_ns7__taskKillResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__taskKillResponse * SOAP_FMAC2 soap_instantiate__ns7__taskKillResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__taskKillResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__taskKillResponse *p;
	size_t k = sizeof(_ns7__taskKillResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__taskKillResponse);
		if (p)
			((_ns7__taskKillResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__taskKillResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__taskKillResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__taskKillResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__taskKillResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__taskKillResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__taskKillResponse(soap, tag ? tag : "ns7:taskKillResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__taskKillResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__taskKillResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__taskKillResponse * SOAP_FMAC4 soap_get__ns7__taskKillResponse(struct soap *soap, _ns7__taskKillResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__taskKillResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__taskKill::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns7__taskKill::taskName = NULL;
	this->_ns7__taskKill::createdBy = NULL;
	/* transient soap skipped */
}

void _ns7__taskKill::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns7__taskKill::taskName);
	soap_serialize_PointerTostd__string(soap, &this->_ns7__taskKill::createdBy);
#endif
}

int _ns7__taskKill::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__taskKill(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__taskKill(struct soap *soap, const char *tag, int id, const _ns7__taskKill *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__taskKill), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "taskName", -1, &a->_ns7__taskKill::taskName, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "createdBy", -1, &a->_ns7__taskKill::createdBy, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__taskKill::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__taskKill(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__taskKill * SOAP_FMAC4 soap_in__ns7__taskKill(struct soap *soap, const char *tag, _ns7__taskKill *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__taskKill *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__taskKill, sizeof(_ns7__taskKill), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__taskKill)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__taskKill *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_taskName1 = 1;
	size_t soap_flag_createdBy1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_taskName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "taskName", &a->_ns7__taskKill::taskName, "xsd:string"))
				{	soap_flag_taskName1--;
					continue;
				}
			}
			if (soap_flag_createdBy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "createdBy", &a->_ns7__taskKill::createdBy, "xsd:string"))
				{	soap_flag_createdBy1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns7__taskKill *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__taskKill, SOAP_TYPE__ns7__taskKill, sizeof(_ns7__taskKill), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__taskKill * SOAP_FMAC2 soap_instantiate__ns7__taskKill(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__taskKill(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__taskKill *p;
	size_t k = sizeof(_ns7__taskKill);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__taskKill);
		if (p)
			((_ns7__taskKill*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__taskKill, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__taskKill*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__taskKill location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__taskKill, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__taskKill::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__taskKill(soap, tag ? tag : "ns7:taskKill", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__taskKill::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__taskKill(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__taskKill * SOAP_FMAC4 soap_get__ns7__taskKill(struct soap *soap, _ns7__taskKill *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__taskKill(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__taskResumeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns7__taskResumeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns7__taskResumeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__taskResumeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__taskResumeResponse(struct soap *soap, const char *tag, int id, const _ns7__taskResumeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__taskResumeResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__taskResumeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__taskResumeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__taskResumeResponse * SOAP_FMAC4 soap_in__ns7__taskResumeResponse(struct soap *soap, const char *tag, _ns7__taskResumeResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__taskResumeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__taskResumeResponse, sizeof(_ns7__taskResumeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__taskResumeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__taskResumeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns7__taskResumeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__taskResumeResponse, SOAP_TYPE__ns7__taskResumeResponse, sizeof(_ns7__taskResumeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__taskResumeResponse * SOAP_FMAC2 soap_instantiate__ns7__taskResumeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__taskResumeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__taskResumeResponse *p;
	size_t k = sizeof(_ns7__taskResumeResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__taskResumeResponse);
		if (p)
			((_ns7__taskResumeResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__taskResumeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__taskResumeResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__taskResumeResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__taskResumeResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__taskResumeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__taskResumeResponse(soap, tag ? tag : "ns7:taskResumeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__taskResumeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__taskResumeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__taskResumeResponse * SOAP_FMAC4 soap_get__ns7__taskResumeResponse(struct soap *soap, _ns7__taskResumeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__taskResumeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__taskResume::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns7__taskResume::taskName = NULL;
	this->_ns7__taskResume::createdBy = NULL;
	/* transient soap skipped */
}

void _ns7__taskResume::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns7__taskResume::taskName);
	soap_serialize_PointerTostd__string(soap, &this->_ns7__taskResume::createdBy);
#endif
}

int _ns7__taskResume::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__taskResume(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__taskResume(struct soap *soap, const char *tag, int id, const _ns7__taskResume *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__taskResume), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "taskName", -1, &a->_ns7__taskResume::taskName, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "createdBy", -1, &a->_ns7__taskResume::createdBy, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__taskResume::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__taskResume(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__taskResume * SOAP_FMAC4 soap_in__ns7__taskResume(struct soap *soap, const char *tag, _ns7__taskResume *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__taskResume *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__taskResume, sizeof(_ns7__taskResume), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__taskResume)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__taskResume *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_taskName1 = 1;
	size_t soap_flag_createdBy1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_taskName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "taskName", &a->_ns7__taskResume::taskName, "xsd:string"))
				{	soap_flag_taskName1--;
					continue;
				}
			}
			if (soap_flag_createdBy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "createdBy", &a->_ns7__taskResume::createdBy, "xsd:string"))
				{	soap_flag_createdBy1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns7__taskResume *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__taskResume, SOAP_TYPE__ns7__taskResume, sizeof(_ns7__taskResume), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__taskResume * SOAP_FMAC2 soap_instantiate__ns7__taskResume(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__taskResume(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__taskResume *p;
	size_t k = sizeof(_ns7__taskResume);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__taskResume);
		if (p)
			((_ns7__taskResume*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__taskResume, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__taskResume*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__taskResume location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__taskResume, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__taskResume::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__taskResume(soap, tag ? tag : "ns7:taskResume", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__taskResume::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__taskResume(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__taskResume * SOAP_FMAC4 soap_get__ns7__taskResume(struct soap *soap, _ns7__taskResume *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__taskResume(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__taskSuspendResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns7__taskSuspendResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns7__taskSuspendResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__taskSuspendResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__taskSuspendResponse(struct soap *soap, const char *tag, int id, const _ns7__taskSuspendResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__taskSuspendResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__taskSuspendResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__taskSuspendResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__taskSuspendResponse * SOAP_FMAC4 soap_in__ns7__taskSuspendResponse(struct soap *soap, const char *tag, _ns7__taskSuspendResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__taskSuspendResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__taskSuspendResponse, sizeof(_ns7__taskSuspendResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__taskSuspendResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__taskSuspendResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns7__taskSuspendResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__taskSuspendResponse, SOAP_TYPE__ns7__taskSuspendResponse, sizeof(_ns7__taskSuspendResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__taskSuspendResponse * SOAP_FMAC2 soap_instantiate__ns7__taskSuspendResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__taskSuspendResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__taskSuspendResponse *p;
	size_t k = sizeof(_ns7__taskSuspendResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__taskSuspendResponse);
		if (p)
			((_ns7__taskSuspendResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__taskSuspendResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__taskSuspendResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__taskSuspendResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__taskSuspendResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__taskSuspendResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__taskSuspendResponse(soap, tag ? tag : "ns7:taskSuspendResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__taskSuspendResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__taskSuspendResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__taskSuspendResponse * SOAP_FMAC4 soap_get__ns7__taskSuspendResponse(struct soap *soap, _ns7__taskSuspendResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__taskSuspendResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__taskSuspend::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns7__taskSuspend::taskName = NULL;
	this->_ns7__taskSuspend::createdBy = NULL;
	/* transient soap skipped */
}

void _ns7__taskSuspend::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns7__taskSuspend::taskName);
	soap_serialize_PointerTostd__string(soap, &this->_ns7__taskSuspend::createdBy);
#endif
}

int _ns7__taskSuspend::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__taskSuspend(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__taskSuspend(struct soap *soap, const char *tag, int id, const _ns7__taskSuspend *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__taskSuspend), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "taskName", -1, &a->_ns7__taskSuspend::taskName, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "createdBy", -1, &a->_ns7__taskSuspend::createdBy, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__taskSuspend::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__taskSuspend(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__taskSuspend * SOAP_FMAC4 soap_in__ns7__taskSuspend(struct soap *soap, const char *tag, _ns7__taskSuspend *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__taskSuspend *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__taskSuspend, sizeof(_ns7__taskSuspend), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__taskSuspend)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__taskSuspend *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_taskName1 = 1;
	size_t soap_flag_createdBy1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_taskName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "taskName", &a->_ns7__taskSuspend::taskName, "xsd:string"))
				{	soap_flag_taskName1--;
					continue;
				}
			}
			if (soap_flag_createdBy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "createdBy", &a->_ns7__taskSuspend::createdBy, "xsd:string"))
				{	soap_flag_createdBy1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns7__taskSuspend *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__taskSuspend, SOAP_TYPE__ns7__taskSuspend, sizeof(_ns7__taskSuspend), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__taskSuspend * SOAP_FMAC2 soap_instantiate__ns7__taskSuspend(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__taskSuspend(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__taskSuspend *p;
	size_t k = sizeof(_ns7__taskSuspend);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__taskSuspend);
		if (p)
			((_ns7__taskSuspend*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__taskSuspend, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__taskSuspend*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__taskSuspend location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__taskSuspend, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__taskSuspend::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__taskSuspend(soap, tag ? tag : "ns7:taskSuspend", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__taskSuspend::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__taskSuspend(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__taskSuspend * SOAP_FMAC4 soap_get__ns7__taskSuspend(struct soap *soap, _ns7__taskSuspend *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__taskSuspend(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__getTasksResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns7__getTasksResponse::tasks = NULL;
	/* transient soap skipped */
}

void _ns7__getTasksResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons7__SoapTasks(soap, &this->_ns7__getTasksResponse::tasks);
#endif
}

int _ns7__getTasksResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__getTasksResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__getTasksResponse(struct soap *soap, const char *tag, int id, const _ns7__getTasksResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__getTasksResponse), type))
		return soap->error;
	if (!a->_ns7__getTasksResponse::tasks)
	{	if (soap_element_empty(soap, "tasks"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons7__SoapTasks(soap, "tasks", -1, &a->_ns7__getTasksResponse::tasks, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__getTasksResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__getTasksResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__getTasksResponse * SOAP_FMAC4 soap_in__ns7__getTasksResponse(struct soap *soap, const char *tag, _ns7__getTasksResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__getTasksResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__getTasksResponse, sizeof(_ns7__getTasksResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__getTasksResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__getTasksResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_tasks1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tasks1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons7__SoapTasks(soap, "tasks", &a->_ns7__getTasksResponse::tasks, "ns7:SoapTasks"))
				{	soap_flag_tasks1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns7__getTasksResponse::tasks))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns7__getTasksResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__getTasksResponse, SOAP_TYPE__ns7__getTasksResponse, sizeof(_ns7__getTasksResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__getTasksResponse * SOAP_FMAC2 soap_instantiate__ns7__getTasksResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__getTasksResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__getTasksResponse *p;
	size_t k = sizeof(_ns7__getTasksResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__getTasksResponse);
		if (p)
			((_ns7__getTasksResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__getTasksResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__getTasksResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__getTasksResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__getTasksResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__getTasksResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__getTasksResponse(soap, tag ? tag : "ns7:getTasksResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__getTasksResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__getTasksResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__getTasksResponse * SOAP_FMAC4 soap_get__ns7__getTasksResponse(struct soap *soap, _ns7__getTasksResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__getTasksResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__getTasks::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns7__getTasks::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns7__getTasks::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__getTasks(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__getTasks(struct soap *soap, const char *tag, int id, const _ns7__getTasks *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__getTasks), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__getTasks::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__getTasks(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__getTasks * SOAP_FMAC4 soap_in__ns7__getTasks(struct soap *soap, const char *tag, _ns7__getTasks *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__getTasks *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__getTasks, sizeof(_ns7__getTasks), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__getTasks)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__getTasks *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns7__getTasks *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__getTasks, SOAP_TYPE__ns7__getTasks, sizeof(_ns7__getTasks), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__getTasks * SOAP_FMAC2 soap_instantiate__ns7__getTasks(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__getTasks(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__getTasks *p;
	size_t k = sizeof(_ns7__getTasks);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__getTasks);
		if (p)
			((_ns7__getTasks*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__getTasks, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__getTasks*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__getTasks location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__getTasks, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__getTasks::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__getTasks(soap, tag ? tag : "ns7:getTasks", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__getTasks::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__getTasks(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__getTasks * SOAP_FMAC4 soap_get__ns7__getTasks(struct soap *soap, _ns7__getTasks *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__getTasks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__clearAllBreakpointsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns7__clearAllBreakpointsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns7__clearAllBreakpointsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__clearAllBreakpointsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__clearAllBreakpointsResponse(struct soap *soap, const char *tag, int id, const _ns7__clearAllBreakpointsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__clearAllBreakpointsResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__clearAllBreakpointsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__clearAllBreakpointsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__clearAllBreakpointsResponse * SOAP_FMAC4 soap_in__ns7__clearAllBreakpointsResponse(struct soap *soap, const char *tag, _ns7__clearAllBreakpointsResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__clearAllBreakpointsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__clearAllBreakpointsResponse, sizeof(_ns7__clearAllBreakpointsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__clearAllBreakpointsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__clearAllBreakpointsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns7__clearAllBreakpointsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__clearAllBreakpointsResponse, SOAP_TYPE__ns7__clearAllBreakpointsResponse, sizeof(_ns7__clearAllBreakpointsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__clearAllBreakpointsResponse * SOAP_FMAC2 soap_instantiate__ns7__clearAllBreakpointsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__clearAllBreakpointsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__clearAllBreakpointsResponse *p;
	size_t k = sizeof(_ns7__clearAllBreakpointsResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__clearAllBreakpointsResponse);
		if (p)
			((_ns7__clearAllBreakpointsResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__clearAllBreakpointsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__clearAllBreakpointsResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__clearAllBreakpointsResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__clearAllBreakpointsResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__clearAllBreakpointsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__clearAllBreakpointsResponse(soap, tag ? tag : "ns7:clearAllBreakpointsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__clearAllBreakpointsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__clearAllBreakpointsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__clearAllBreakpointsResponse * SOAP_FMAC4 soap_get__ns7__clearAllBreakpointsResponse(struct soap *soap, _ns7__clearAllBreakpointsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__clearAllBreakpointsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__clearAllBreakpoints::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns7__clearAllBreakpoints::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns7__clearAllBreakpoints::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__clearAllBreakpoints(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__clearAllBreakpoints(struct soap *soap, const char *tag, int id, const _ns7__clearAllBreakpoints *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__clearAllBreakpoints), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__clearAllBreakpoints::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__clearAllBreakpoints(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__clearAllBreakpoints * SOAP_FMAC4 soap_in__ns7__clearAllBreakpoints(struct soap *soap, const char *tag, _ns7__clearAllBreakpoints *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__clearAllBreakpoints *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__clearAllBreakpoints, sizeof(_ns7__clearAllBreakpoints), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__clearAllBreakpoints)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__clearAllBreakpoints *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns7__clearAllBreakpoints *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__clearAllBreakpoints, SOAP_TYPE__ns7__clearAllBreakpoints, sizeof(_ns7__clearAllBreakpoints), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__clearAllBreakpoints * SOAP_FMAC2 soap_instantiate__ns7__clearAllBreakpoints(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__clearAllBreakpoints(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__clearAllBreakpoints *p;
	size_t k = sizeof(_ns7__clearAllBreakpoints);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__clearAllBreakpoints);
		if (p)
			((_ns7__clearAllBreakpoints*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__clearAllBreakpoints, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__clearAllBreakpoints*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__clearAllBreakpoints location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__clearAllBreakpoints, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__clearAllBreakpoints::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__clearAllBreakpoints(soap, tag ? tag : "ns7:clearAllBreakpoints", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__clearAllBreakpoints::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__clearAllBreakpoints(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__clearAllBreakpoints * SOAP_FMAC4 soap_get__ns7__clearAllBreakpoints(struct soap *soap, _ns7__clearAllBreakpoints *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__clearAllBreakpoints(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__clearBreakpointsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns7__clearBreakpointsResponse::out = NULL;
	/* transient soap skipped */
}

void _ns7__clearBreakpointsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons7__BreakpointsResponses(soap, &this->_ns7__clearBreakpointsResponse::out);
#endif
}

int _ns7__clearBreakpointsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__clearBreakpointsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__clearBreakpointsResponse(struct soap *soap, const char *tag, int id, const _ns7__clearBreakpointsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__clearBreakpointsResponse), type))
		return soap->error;
	if (!a->_ns7__clearBreakpointsResponse::out)
	{	if (soap_element_empty(soap, "out"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons7__BreakpointsResponses(soap, "out", -1, &a->_ns7__clearBreakpointsResponse::out, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__clearBreakpointsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__clearBreakpointsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__clearBreakpointsResponse * SOAP_FMAC4 soap_in__ns7__clearBreakpointsResponse(struct soap *soap, const char *tag, _ns7__clearBreakpointsResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__clearBreakpointsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__clearBreakpointsResponse, sizeof(_ns7__clearBreakpointsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__clearBreakpointsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__clearBreakpointsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_out1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons7__BreakpointsResponses(soap, "out", &a->_ns7__clearBreakpointsResponse::out, "ns7:BreakpointsResponses"))
				{	soap_flag_out1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns7__clearBreakpointsResponse::out))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns7__clearBreakpointsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__clearBreakpointsResponse, SOAP_TYPE__ns7__clearBreakpointsResponse, sizeof(_ns7__clearBreakpointsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__clearBreakpointsResponse * SOAP_FMAC2 soap_instantiate__ns7__clearBreakpointsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__clearBreakpointsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__clearBreakpointsResponse *p;
	size_t k = sizeof(_ns7__clearBreakpointsResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__clearBreakpointsResponse);
		if (p)
			((_ns7__clearBreakpointsResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__clearBreakpointsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__clearBreakpointsResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__clearBreakpointsResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__clearBreakpointsResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__clearBreakpointsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__clearBreakpointsResponse(soap, tag ? tag : "ns7:clearBreakpointsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__clearBreakpointsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__clearBreakpointsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__clearBreakpointsResponse * SOAP_FMAC4 soap_get__ns7__clearBreakpointsResponse(struct soap *soap, _ns7__clearBreakpointsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__clearBreakpointsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__clearBreakpoints::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns7__clearBreakpoints::breakpoints = NULL;
	/* transient soap skipped */
}

void _ns7__clearBreakpoints::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons7__SoapBreakpoints(soap, &this->_ns7__clearBreakpoints::breakpoints);
#endif
}

int _ns7__clearBreakpoints::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__clearBreakpoints(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__clearBreakpoints(struct soap *soap, const char *tag, int id, const _ns7__clearBreakpoints *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__clearBreakpoints), type))
		return soap->error;
	if (!a->_ns7__clearBreakpoints::breakpoints)
	{	if (soap_element_empty(soap, "breakpoints"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons7__SoapBreakpoints(soap, "breakpoints", -1, &a->_ns7__clearBreakpoints::breakpoints, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__clearBreakpoints::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__clearBreakpoints(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__clearBreakpoints * SOAP_FMAC4 soap_in__ns7__clearBreakpoints(struct soap *soap, const char *tag, _ns7__clearBreakpoints *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__clearBreakpoints *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__clearBreakpoints, sizeof(_ns7__clearBreakpoints), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__clearBreakpoints)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__clearBreakpoints *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_breakpoints1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_breakpoints1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons7__SoapBreakpoints(soap, "breakpoints", &a->_ns7__clearBreakpoints::breakpoints, "ns7:SoapBreakpoints"))
				{	soap_flag_breakpoints1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns7__clearBreakpoints::breakpoints))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns7__clearBreakpoints *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__clearBreakpoints, SOAP_TYPE__ns7__clearBreakpoints, sizeof(_ns7__clearBreakpoints), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__clearBreakpoints * SOAP_FMAC2 soap_instantiate__ns7__clearBreakpoints(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__clearBreakpoints(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__clearBreakpoints *p;
	size_t k = sizeof(_ns7__clearBreakpoints);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__clearBreakpoints);
		if (p)
			((_ns7__clearBreakpoints*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__clearBreakpoints, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__clearBreakpoints*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__clearBreakpoints location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__clearBreakpoints, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__clearBreakpoints::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__clearBreakpoints(soap, tag ? tag : "ns7:clearBreakpoints", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__clearBreakpoints::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__clearBreakpoints(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__clearBreakpoints * SOAP_FMAC4 soap_get__ns7__clearBreakpoints(struct soap *soap, _ns7__clearBreakpoints *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__clearBreakpoints(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__getBreakpointsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns7__getBreakpointsResponse::breakpoints = NULL;
	/* transient soap skipped */
}

void _ns7__getBreakpointsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons7__SoapBreakpoints(soap, &this->_ns7__getBreakpointsResponse::breakpoints);
#endif
}

int _ns7__getBreakpointsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__getBreakpointsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__getBreakpointsResponse(struct soap *soap, const char *tag, int id, const _ns7__getBreakpointsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__getBreakpointsResponse), type))
		return soap->error;
	if (!a->_ns7__getBreakpointsResponse::breakpoints)
	{	if (soap_element_empty(soap, "breakpoints"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons7__SoapBreakpoints(soap, "breakpoints", -1, &a->_ns7__getBreakpointsResponse::breakpoints, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__getBreakpointsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__getBreakpointsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__getBreakpointsResponse * SOAP_FMAC4 soap_in__ns7__getBreakpointsResponse(struct soap *soap, const char *tag, _ns7__getBreakpointsResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__getBreakpointsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__getBreakpointsResponse, sizeof(_ns7__getBreakpointsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__getBreakpointsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__getBreakpointsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_breakpoints1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_breakpoints1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons7__SoapBreakpoints(soap, "breakpoints", &a->_ns7__getBreakpointsResponse::breakpoints, "ns7:SoapBreakpoints"))
				{	soap_flag_breakpoints1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns7__getBreakpointsResponse::breakpoints))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns7__getBreakpointsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__getBreakpointsResponse, SOAP_TYPE__ns7__getBreakpointsResponse, sizeof(_ns7__getBreakpointsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__getBreakpointsResponse * SOAP_FMAC2 soap_instantiate__ns7__getBreakpointsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__getBreakpointsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__getBreakpointsResponse *p;
	size_t k = sizeof(_ns7__getBreakpointsResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__getBreakpointsResponse);
		if (p)
			((_ns7__getBreakpointsResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__getBreakpointsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__getBreakpointsResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__getBreakpointsResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__getBreakpointsResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__getBreakpointsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__getBreakpointsResponse(soap, tag ? tag : "ns7:getBreakpointsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__getBreakpointsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__getBreakpointsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__getBreakpointsResponse * SOAP_FMAC4 soap_get__ns7__getBreakpointsResponse(struct soap *soap, _ns7__getBreakpointsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__getBreakpointsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__getBreakpoints::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns7__getBreakpoints::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns7__getBreakpoints::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__getBreakpoints(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__getBreakpoints(struct soap *soap, const char *tag, int id, const _ns7__getBreakpoints *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__getBreakpoints), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__getBreakpoints::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__getBreakpoints(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__getBreakpoints * SOAP_FMAC4 soap_in__ns7__getBreakpoints(struct soap *soap, const char *tag, _ns7__getBreakpoints *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__getBreakpoints *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__getBreakpoints, sizeof(_ns7__getBreakpoints), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__getBreakpoints)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__getBreakpoints *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns7__getBreakpoints *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__getBreakpoints, SOAP_TYPE__ns7__getBreakpoints, sizeof(_ns7__getBreakpoints), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__getBreakpoints * SOAP_FMAC2 soap_instantiate__ns7__getBreakpoints(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__getBreakpoints(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__getBreakpoints *p;
	size_t k = sizeof(_ns7__getBreakpoints);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__getBreakpoints);
		if (p)
			((_ns7__getBreakpoints*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__getBreakpoints, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__getBreakpoints*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__getBreakpoints location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__getBreakpoints, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__getBreakpoints::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__getBreakpoints(soap, tag ? tag : "ns7:getBreakpoints", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__getBreakpoints::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__getBreakpoints(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__getBreakpoints * SOAP_FMAC4 soap_get__ns7__getBreakpoints(struct soap *soap, _ns7__getBreakpoints *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__getBreakpoints(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__setBreakpointsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns7__setBreakpointsResponse::out = NULL;
	/* transient soap skipped */
}

void _ns7__setBreakpointsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons7__BreakpointsResponses(soap, &this->_ns7__setBreakpointsResponse::out);
#endif
}

int _ns7__setBreakpointsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__setBreakpointsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__setBreakpointsResponse(struct soap *soap, const char *tag, int id, const _ns7__setBreakpointsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__setBreakpointsResponse), type))
		return soap->error;
	if (!a->_ns7__setBreakpointsResponse::out)
	{	if (soap_element_empty(soap, "out"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons7__BreakpointsResponses(soap, "out", -1, &a->_ns7__setBreakpointsResponse::out, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__setBreakpointsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__setBreakpointsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__setBreakpointsResponse * SOAP_FMAC4 soap_in__ns7__setBreakpointsResponse(struct soap *soap, const char *tag, _ns7__setBreakpointsResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__setBreakpointsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__setBreakpointsResponse, sizeof(_ns7__setBreakpointsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__setBreakpointsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__setBreakpointsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_out1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons7__BreakpointsResponses(soap, "out", &a->_ns7__setBreakpointsResponse::out, "ns7:BreakpointsResponses"))
				{	soap_flag_out1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns7__setBreakpointsResponse::out))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns7__setBreakpointsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__setBreakpointsResponse, SOAP_TYPE__ns7__setBreakpointsResponse, sizeof(_ns7__setBreakpointsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__setBreakpointsResponse * SOAP_FMAC2 soap_instantiate__ns7__setBreakpointsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__setBreakpointsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__setBreakpointsResponse *p;
	size_t k = sizeof(_ns7__setBreakpointsResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__setBreakpointsResponse);
		if (p)
			((_ns7__setBreakpointsResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__setBreakpointsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__setBreakpointsResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__setBreakpointsResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__setBreakpointsResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__setBreakpointsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__setBreakpointsResponse(soap, tag ? tag : "ns7:setBreakpointsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__setBreakpointsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__setBreakpointsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__setBreakpointsResponse * SOAP_FMAC4 soap_get__ns7__setBreakpointsResponse(struct soap *soap, _ns7__setBreakpointsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__setBreakpointsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__setBreakpoints::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns7__setBreakpoints::breakpoints = NULL;
	/* transient soap skipped */
}

void _ns7__setBreakpoints::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons7__SoapBreakpoints(soap, &this->_ns7__setBreakpoints::breakpoints);
#endif
}

int _ns7__setBreakpoints::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__setBreakpoints(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__setBreakpoints(struct soap *soap, const char *tag, int id, const _ns7__setBreakpoints *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__setBreakpoints), type))
		return soap->error;
	if (!a->_ns7__setBreakpoints::breakpoints)
	{	if (soap_element_empty(soap, "breakpoints"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons7__SoapBreakpoints(soap, "breakpoints", -1, &a->_ns7__setBreakpoints::breakpoints, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns7__setBreakpoints::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__setBreakpoints(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__setBreakpoints * SOAP_FMAC4 soap_in__ns7__setBreakpoints(struct soap *soap, const char *tag, _ns7__setBreakpoints *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__setBreakpoints *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__setBreakpoints, sizeof(_ns7__setBreakpoints), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns7__setBreakpoints)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns7__setBreakpoints *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_breakpoints1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_breakpoints1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons7__SoapBreakpoints(soap, "breakpoints", &a->_ns7__setBreakpoints::breakpoints, "ns7:SoapBreakpoints"))
				{	soap_flag_breakpoints1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns7__setBreakpoints::breakpoints))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns7__setBreakpoints *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__setBreakpoints, SOAP_TYPE__ns7__setBreakpoints, sizeof(_ns7__setBreakpoints), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns7__setBreakpoints * SOAP_FMAC2 soap_instantiate__ns7__setBreakpoints(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__setBreakpoints(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns7__setBreakpoints *p;
	size_t k = sizeof(_ns7__setBreakpoints);
	if (n < 0)
	{	p = SOAP_NEW(_ns7__setBreakpoints);
		if (p)
			((_ns7__setBreakpoints*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns7__setBreakpoints, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns7__setBreakpoints*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns7__setBreakpoints location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns7__setBreakpoints, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns7__setBreakpoints::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns7__setBreakpoints(soap, tag ? tag : "ns7:setBreakpoints", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__setBreakpoints::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__setBreakpoints(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__setBreakpoints * SOAP_FMAC4 soap_get__ns7__setBreakpoints(struct soap *soap, _ns7__setBreakpoints *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__setBreakpoints(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns7__SoapDhParametersArray::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons7__SoapDhParameters(soap, &this->ns7__SoapDhParametersArray::DhParameters);
	/* transient soap skipped */
}

void ns7__SoapDhParametersArray::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons7__SoapDhParameters(soap, &this->ns7__SoapDhParametersArray::DhParameters);
#endif
}

int ns7__SoapDhParametersArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__SoapDhParametersArray(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__SoapDhParametersArray(struct soap *soap, const char *tag, int id, const ns7__SoapDhParametersArray *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__SoapDhParametersArray), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons7__SoapDhParameters(soap, "DhParameters", -1, &a->ns7__SoapDhParametersArray::DhParameters, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns7__SoapDhParametersArray::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns7__SoapDhParametersArray(soap, tag, this, type);
}

SOAP_FMAC3 ns7__SoapDhParametersArray * SOAP_FMAC4 soap_in_ns7__SoapDhParametersArray(struct soap *soap, const char *tag, ns7__SoapDhParametersArray *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__SoapDhParametersArray *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__SoapDhParametersArray, sizeof(ns7__SoapDhParametersArray), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns7__SoapDhParametersArray)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns7__SoapDhParametersArray *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons7__SoapDhParameters(soap, "DhParameters", &a->ns7__SoapDhParametersArray::DhParameters, "ns7:SoapDhParameters"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns7__SoapDhParametersArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__SoapDhParametersArray, SOAP_TYPE_ns7__SoapDhParametersArray, sizeof(ns7__SoapDhParametersArray), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns7__SoapDhParametersArray * SOAP_FMAC2 soap_instantiate_ns7__SoapDhParametersArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__SoapDhParametersArray(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns7__SoapDhParametersArray *p;
	size_t k = sizeof(ns7__SoapDhParametersArray);
	if (n < 0)
	{	p = SOAP_NEW(ns7__SoapDhParametersArray);
		if (p)
			((ns7__SoapDhParametersArray*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns7__SoapDhParametersArray, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns7__SoapDhParametersArray*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns7__SoapDhParametersArray location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns7__SoapDhParametersArray, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns7__SoapDhParametersArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns7__SoapDhParametersArray(soap, tag ? tag : "ns7:SoapDhParametersArray", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns7__SoapDhParametersArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__SoapDhParametersArray(soap, this, tag, type);
}

SOAP_FMAC3 ns7__SoapDhParametersArray * SOAP_FMAC4 soap_get_ns7__SoapDhParametersArray(struct soap *soap, ns7__SoapDhParametersArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__SoapDhParametersArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns7__SoapDhParameters::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_double(soap, &this->ns7__SoapDhParameters::theta);
	soap_default_double(soap, &this->ns7__SoapDhParameters::d);
	soap_default_double(soap, &this->ns7__SoapDhParameters::a);
	soap_default_double(soap, &this->ns7__SoapDhParameters::alpha);
	soap_default_double(soap, &this->ns7__SoapDhParameters::beta);
	/* transient soap skipped */
}

void ns7__SoapDhParameters::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns7__SoapDhParameters::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__SoapDhParameters(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__SoapDhParameters(struct soap *soap, const char *tag, int id, const ns7__SoapDhParameters *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__SoapDhParameters), type))
		return soap->error;
	if (soap_out_double(soap, "theta", -1, &a->ns7__SoapDhParameters::theta, ""))
		return soap->error;
	if (soap_out_double(soap, "d", -1, &a->ns7__SoapDhParameters::d, ""))
		return soap->error;
	if (soap_out_double(soap, "a", -1, &a->ns7__SoapDhParameters::a, ""))
		return soap->error;
	if (soap_out_double(soap, "alpha", -1, &a->ns7__SoapDhParameters::alpha, ""))
		return soap->error;
	if (soap_out_double(soap, "beta", -1, &a->ns7__SoapDhParameters::beta, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns7__SoapDhParameters::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns7__SoapDhParameters(soap, tag, this, type);
}

SOAP_FMAC3 ns7__SoapDhParameters * SOAP_FMAC4 soap_in_ns7__SoapDhParameters(struct soap *soap, const char *tag, ns7__SoapDhParameters *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__SoapDhParameters *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__SoapDhParameters, sizeof(ns7__SoapDhParameters), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns7__SoapDhParameters)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns7__SoapDhParameters *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_theta1 = 1;
	size_t soap_flag_d1 = 1;
	size_t soap_flag_a1 = 1;
	size_t soap_flag_alpha1 = 1;
	size_t soap_flag_beta1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_theta1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "theta", &a->ns7__SoapDhParameters::theta, "xsd:double"))
				{	soap_flag_theta1--;
					continue;
				}
			}
			if (soap_flag_d1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "d", &a->ns7__SoapDhParameters::d, "xsd:double"))
				{	soap_flag_d1--;
					continue;
				}
			}
			if (soap_flag_a1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "a", &a->ns7__SoapDhParameters::a, "xsd:double"))
				{	soap_flag_a1--;
					continue;
				}
			}
			if (soap_flag_alpha1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "alpha", &a->ns7__SoapDhParameters::alpha, "xsd:double"))
				{	soap_flag_alpha1--;
					continue;
				}
			}
			if (soap_flag_beta1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "beta", &a->ns7__SoapDhParameters::beta, "xsd:double"))
				{	soap_flag_beta1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_theta1 > 0 || soap_flag_d1 > 0 || soap_flag_a1 > 0 || soap_flag_alpha1 > 0 || soap_flag_beta1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns7__SoapDhParameters *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__SoapDhParameters, SOAP_TYPE_ns7__SoapDhParameters, sizeof(ns7__SoapDhParameters), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns7__SoapDhParameters * SOAP_FMAC2 soap_instantiate_ns7__SoapDhParameters(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__SoapDhParameters(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns7__SoapDhParameters *p;
	size_t k = sizeof(ns7__SoapDhParameters);
	if (n < 0)
	{	p = SOAP_NEW(ns7__SoapDhParameters);
		if (p)
			((ns7__SoapDhParameters*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns7__SoapDhParameters, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns7__SoapDhParameters*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns7__SoapDhParameters location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns7__SoapDhParameters, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns7__SoapDhParameters::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns7__SoapDhParameters(soap, tag ? tag : "ns7:SoapDhParameters", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns7__SoapDhParameters::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__SoapDhParameters(soap, this, tag, type);
}

SOAP_FMAC3 ns7__SoapDhParameters * SOAP_FMAC4 soap_get_ns7__SoapDhParameters(struct soap *soap, ns7__SoapDhParameters *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__SoapDhParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns7__SoapPhysicalIoUnlockResponses::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons7__SoapPhysicalIoUnlockResponse(soap, &this->ns7__SoapPhysicalIoUnlockResponses::PhysicalIoResponse);
	/* transient soap skipped */
}

void ns7__SoapPhysicalIoUnlockResponses::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons7__SoapPhysicalIoUnlockResponse(soap, &this->ns7__SoapPhysicalIoUnlockResponses::PhysicalIoResponse);
#endif
}

int ns7__SoapPhysicalIoUnlockResponses::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__SoapPhysicalIoUnlockResponses(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__SoapPhysicalIoUnlockResponses(struct soap *soap, const char *tag, int id, const ns7__SoapPhysicalIoUnlockResponses *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__SoapPhysicalIoUnlockResponses), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons7__SoapPhysicalIoUnlockResponse(soap, "PhysicalIoResponse", -1, &a->ns7__SoapPhysicalIoUnlockResponses::PhysicalIoResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns7__SoapPhysicalIoUnlockResponses::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns7__SoapPhysicalIoUnlockResponses(soap, tag, this, type);
}

SOAP_FMAC3 ns7__SoapPhysicalIoUnlockResponses * SOAP_FMAC4 soap_in_ns7__SoapPhysicalIoUnlockResponses(struct soap *soap, const char *tag, ns7__SoapPhysicalIoUnlockResponses *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__SoapPhysicalIoUnlockResponses *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__SoapPhysicalIoUnlockResponses, sizeof(ns7__SoapPhysicalIoUnlockResponses), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns7__SoapPhysicalIoUnlockResponses)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns7__SoapPhysicalIoUnlockResponses *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons7__SoapPhysicalIoUnlockResponse(soap, "PhysicalIoResponse", &a->ns7__SoapPhysicalIoUnlockResponses::PhysicalIoResponse, "ns7:SoapPhysicalIoUnlockResponse"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns7__SoapPhysicalIoUnlockResponses *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__SoapPhysicalIoUnlockResponses, SOAP_TYPE_ns7__SoapPhysicalIoUnlockResponses, sizeof(ns7__SoapPhysicalIoUnlockResponses), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns7__SoapPhysicalIoUnlockResponses * SOAP_FMAC2 soap_instantiate_ns7__SoapPhysicalIoUnlockResponses(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__SoapPhysicalIoUnlockResponses(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns7__SoapPhysicalIoUnlockResponses *p;
	size_t k = sizeof(ns7__SoapPhysicalIoUnlockResponses);
	if (n < 0)
	{	p = SOAP_NEW(ns7__SoapPhysicalIoUnlockResponses);
		if (p)
			((ns7__SoapPhysicalIoUnlockResponses*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns7__SoapPhysicalIoUnlockResponses, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns7__SoapPhysicalIoUnlockResponses*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns7__SoapPhysicalIoUnlockResponses location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns7__SoapPhysicalIoUnlockResponses, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns7__SoapPhysicalIoUnlockResponses::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns7__SoapPhysicalIoUnlockResponses(soap, tag ? tag : "ns7:SoapPhysicalIoUnlockResponses", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns7__SoapPhysicalIoUnlockResponses::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__SoapPhysicalIoUnlockResponses(soap, this, tag, type);
}

SOAP_FMAC3 ns7__SoapPhysicalIoUnlockResponses * SOAP_FMAC4 soap_get_ns7__SoapPhysicalIoUnlockResponses(struct soap *soap, ns7__SoapPhysicalIoUnlockResponses *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__SoapPhysicalIoUnlockResponses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns7__SoapPhysicalIoUnlockResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns7__SoapPhysicalIoUnlockResponse::response = NULL;
	this->ns7__SoapPhysicalIoUnlockResponse::state = NULL;
	/* transient soap skipped */
}

void ns7__SoapPhysicalIoUnlockResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons7__SoapPhysicalIoResponse(soap, &this->ns7__SoapPhysicalIoUnlockResponse::response);
	soap_serialize_PointerTons7__SoapPhysicalIoState(soap, &this->ns7__SoapPhysicalIoUnlockResponse::state);
#endif
}

int ns7__SoapPhysicalIoUnlockResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__SoapPhysicalIoUnlockResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__SoapPhysicalIoUnlockResponse(struct soap *soap, const char *tag, int id, const ns7__SoapPhysicalIoUnlockResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__SoapPhysicalIoUnlockResponse), type))
		return soap->error;
	if (!a->ns7__SoapPhysicalIoUnlockResponse::response)
	{	if (soap_element_empty(soap, "response"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons7__SoapPhysicalIoResponse(soap, "response", -1, &a->ns7__SoapPhysicalIoUnlockResponse::response, ""))
		return soap->error;
	if (!a->ns7__SoapPhysicalIoUnlockResponse::state)
	{	if (soap_element_empty(soap, "state"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons7__SoapPhysicalIoState(soap, "state", -1, &a->ns7__SoapPhysicalIoUnlockResponse::state, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns7__SoapPhysicalIoUnlockResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns7__SoapPhysicalIoUnlockResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns7__SoapPhysicalIoUnlockResponse * SOAP_FMAC4 soap_in_ns7__SoapPhysicalIoUnlockResponse(struct soap *soap, const char *tag, ns7__SoapPhysicalIoUnlockResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__SoapPhysicalIoUnlockResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__SoapPhysicalIoUnlockResponse, sizeof(ns7__SoapPhysicalIoUnlockResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns7__SoapPhysicalIoUnlockResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns7__SoapPhysicalIoUnlockResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_response1 = 1;
	size_t soap_flag_state1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_response1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons7__SoapPhysicalIoResponse(soap, "response", &a->ns7__SoapPhysicalIoUnlockResponse::response, "ns7:SoapPhysicalIoResponse"))
				{	soap_flag_response1--;
					continue;
				}
			}
			if (soap_flag_state1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons7__SoapPhysicalIoState(soap, "state", &a->ns7__SoapPhysicalIoUnlockResponse::state, "ns7:SoapPhysicalIoState"))
				{	soap_flag_state1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns7__SoapPhysicalIoUnlockResponse::response || !a->ns7__SoapPhysicalIoUnlockResponse::state))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns7__SoapPhysicalIoUnlockResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__SoapPhysicalIoUnlockResponse, SOAP_TYPE_ns7__SoapPhysicalIoUnlockResponse, sizeof(ns7__SoapPhysicalIoUnlockResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns7__SoapPhysicalIoUnlockResponse * SOAP_FMAC2 soap_instantiate_ns7__SoapPhysicalIoUnlockResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__SoapPhysicalIoUnlockResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns7__SoapPhysicalIoUnlockResponse *p;
	size_t k = sizeof(ns7__SoapPhysicalIoUnlockResponse);
	if (n < 0)
	{	p = SOAP_NEW(ns7__SoapPhysicalIoUnlockResponse);
		if (p)
			((ns7__SoapPhysicalIoUnlockResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns7__SoapPhysicalIoUnlockResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns7__SoapPhysicalIoUnlockResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns7__SoapPhysicalIoUnlockResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns7__SoapPhysicalIoUnlockResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns7__SoapPhysicalIoUnlockResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns7__SoapPhysicalIoUnlockResponse(soap, tag ? tag : "ns7:SoapPhysicalIoUnlockResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns7__SoapPhysicalIoUnlockResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__SoapPhysicalIoUnlockResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns7__SoapPhysicalIoUnlockResponse * SOAP_FMAC4 soap_get_ns7__SoapPhysicalIoUnlockResponse(struct soap *soap, ns7__SoapPhysicalIoUnlockResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__SoapPhysicalIoUnlockResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns7__SoapPhysicalIoResponses::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons7__SoapPhysicalIoResponse(soap, &this->ns7__SoapPhysicalIoResponses::PhysicalIoResponse);
	/* transient soap skipped */
}

void ns7__SoapPhysicalIoResponses::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons7__SoapPhysicalIoResponse(soap, &this->ns7__SoapPhysicalIoResponses::PhysicalIoResponse);
#endif
}

int ns7__SoapPhysicalIoResponses::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__SoapPhysicalIoResponses(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__SoapPhysicalIoResponses(struct soap *soap, const char *tag, int id, const ns7__SoapPhysicalIoResponses *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__SoapPhysicalIoResponses), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons7__SoapPhysicalIoResponse(soap, "PhysicalIoResponse", -1, &a->ns7__SoapPhysicalIoResponses::PhysicalIoResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns7__SoapPhysicalIoResponses::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns7__SoapPhysicalIoResponses(soap, tag, this, type);
}

SOAP_FMAC3 ns7__SoapPhysicalIoResponses * SOAP_FMAC4 soap_in_ns7__SoapPhysicalIoResponses(struct soap *soap, const char *tag, ns7__SoapPhysicalIoResponses *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__SoapPhysicalIoResponses *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__SoapPhysicalIoResponses, sizeof(ns7__SoapPhysicalIoResponses), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns7__SoapPhysicalIoResponses)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns7__SoapPhysicalIoResponses *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons7__SoapPhysicalIoResponse(soap, "PhysicalIoResponse", &a->ns7__SoapPhysicalIoResponses::PhysicalIoResponse, "ns7:SoapPhysicalIoResponse"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns7__SoapPhysicalIoResponses *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__SoapPhysicalIoResponses, SOAP_TYPE_ns7__SoapPhysicalIoResponses, sizeof(ns7__SoapPhysicalIoResponses), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns7__SoapPhysicalIoResponses * SOAP_FMAC2 soap_instantiate_ns7__SoapPhysicalIoResponses(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__SoapPhysicalIoResponses(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns7__SoapPhysicalIoResponses *p;
	size_t k = sizeof(ns7__SoapPhysicalIoResponses);
	if (n < 0)
	{	p = SOAP_NEW(ns7__SoapPhysicalIoResponses);
		if (p)
			((ns7__SoapPhysicalIoResponses*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns7__SoapPhysicalIoResponses, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns7__SoapPhysicalIoResponses*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns7__SoapPhysicalIoResponses location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns7__SoapPhysicalIoResponses, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns7__SoapPhysicalIoResponses::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns7__SoapPhysicalIoResponses(soap, tag ? tag : "ns7:SoapPhysicalIoResponses", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns7__SoapPhysicalIoResponses::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__SoapPhysicalIoResponses(soap, this, tag, type);
}

SOAP_FMAC3 ns7__SoapPhysicalIoResponses * SOAP_FMAC4 soap_get_ns7__SoapPhysicalIoResponses(struct soap *soap, ns7__SoapPhysicalIoResponses *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__SoapPhysicalIoResponses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns7__SoapPhysicalIoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->ns7__SoapPhysicalIoResponse::success);
	soap_default_bool(soap, &this->ns7__SoapPhysicalIoResponse::found);
	/* transient soap skipped */
}

void ns7__SoapPhysicalIoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns7__SoapPhysicalIoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__SoapPhysicalIoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__SoapPhysicalIoResponse(struct soap *soap, const char *tag, int id, const ns7__SoapPhysicalIoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__SoapPhysicalIoResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "success", -1, &a->ns7__SoapPhysicalIoResponse::success, ""))
		return soap->error;
	if (soap_out_bool(soap, "found", -1, &a->ns7__SoapPhysicalIoResponse::found, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns7__SoapPhysicalIoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns7__SoapPhysicalIoResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns7__SoapPhysicalIoResponse * SOAP_FMAC4 soap_in_ns7__SoapPhysicalIoResponse(struct soap *soap, const char *tag, ns7__SoapPhysicalIoResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__SoapPhysicalIoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__SoapPhysicalIoResponse, sizeof(ns7__SoapPhysicalIoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns7__SoapPhysicalIoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns7__SoapPhysicalIoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_success1 = 1;
	size_t soap_flag_found1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_success1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "success", &a->ns7__SoapPhysicalIoResponse::success, "xsd:boolean"))
				{	soap_flag_success1--;
					continue;
				}
			}
			if (soap_flag_found1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "found", &a->ns7__SoapPhysicalIoResponse::found, "xsd:boolean"))
				{	soap_flag_found1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_success1 > 0 || soap_flag_found1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns7__SoapPhysicalIoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__SoapPhysicalIoResponse, SOAP_TYPE_ns7__SoapPhysicalIoResponse, sizeof(ns7__SoapPhysicalIoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns7__SoapPhysicalIoResponse * SOAP_FMAC2 soap_instantiate_ns7__SoapPhysicalIoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__SoapPhysicalIoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns7__SoapPhysicalIoResponse *p;
	size_t k = sizeof(ns7__SoapPhysicalIoResponse);
	if (n < 0)
	{	p = SOAP_NEW(ns7__SoapPhysicalIoResponse);
		if (p)
			((ns7__SoapPhysicalIoResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns7__SoapPhysicalIoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns7__SoapPhysicalIoResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns7__SoapPhysicalIoResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns7__SoapPhysicalIoResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns7__SoapPhysicalIoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns7__SoapPhysicalIoResponse(soap, tag ? tag : "ns7:SoapPhysicalIoResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns7__SoapPhysicalIoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__SoapPhysicalIoResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns7__SoapPhysicalIoResponse * SOAP_FMAC4 soap_get_ns7__SoapPhysicalIoResponse(struct soap *soap, ns7__SoapPhysicalIoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__SoapPhysicalIoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns7__SoapPhysicalIosStates::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons7__SoapPhysicalIoState(soap, &this->ns7__SoapPhysicalIosStates::PhysicalIoState);
	/* transient soap skipped */
}

void ns7__SoapPhysicalIosStates::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons7__SoapPhysicalIoState(soap, &this->ns7__SoapPhysicalIosStates::PhysicalIoState);
#endif
}

int ns7__SoapPhysicalIosStates::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__SoapPhysicalIosStates(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__SoapPhysicalIosStates(struct soap *soap, const char *tag, int id, const ns7__SoapPhysicalIosStates *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__SoapPhysicalIosStates), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons7__SoapPhysicalIoState(soap, "PhysicalIoState", -1, &a->ns7__SoapPhysicalIosStates::PhysicalIoState, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns7__SoapPhysicalIosStates::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns7__SoapPhysicalIosStates(soap, tag, this, type);
}

SOAP_FMAC3 ns7__SoapPhysicalIosStates * SOAP_FMAC4 soap_in_ns7__SoapPhysicalIosStates(struct soap *soap, const char *tag, ns7__SoapPhysicalIosStates *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__SoapPhysicalIosStates *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__SoapPhysicalIosStates, sizeof(ns7__SoapPhysicalIosStates), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns7__SoapPhysicalIosStates)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns7__SoapPhysicalIosStates *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons7__SoapPhysicalIoState(soap, "PhysicalIoState", &a->ns7__SoapPhysicalIosStates::PhysicalIoState, "ns7:SoapPhysicalIoState"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns7__SoapPhysicalIosStates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__SoapPhysicalIosStates, SOAP_TYPE_ns7__SoapPhysicalIosStates, sizeof(ns7__SoapPhysicalIosStates), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns7__SoapPhysicalIosStates * SOAP_FMAC2 soap_instantiate_ns7__SoapPhysicalIosStates(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__SoapPhysicalIosStates(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns7__SoapPhysicalIosStates *p;
	size_t k = sizeof(ns7__SoapPhysicalIosStates);
	if (n < 0)
	{	p = SOAP_NEW(ns7__SoapPhysicalIosStates);
		if (p)
			((ns7__SoapPhysicalIosStates*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns7__SoapPhysicalIosStates, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns7__SoapPhysicalIosStates*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns7__SoapPhysicalIosStates location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns7__SoapPhysicalIosStates, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns7__SoapPhysicalIosStates::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns7__SoapPhysicalIosStates(soap, tag ? tag : "ns7:SoapPhysicalIosStates", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns7__SoapPhysicalIosStates::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__SoapPhysicalIosStates(soap, this, tag, type);
}

SOAP_FMAC3 ns7__SoapPhysicalIosStates * SOAP_FMAC4 soap_get_ns7__SoapPhysicalIosStates(struct soap *soap, ns7__SoapPhysicalIosStates *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__SoapPhysicalIosStates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns7__SoapPhysicalIoValues::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfdouble(soap, &this->ns7__SoapPhysicalIoValues::PhysicalIoValue);
	/* transient soap skipped */
}

void ns7__SoapPhysicalIoValues::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfdouble(soap, &this->ns7__SoapPhysicalIoValues::PhysicalIoValue);
#endif
}

int ns7__SoapPhysicalIoValues::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__SoapPhysicalIoValues(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__SoapPhysicalIoValues(struct soap *soap, const char *tag, int id, const ns7__SoapPhysicalIoValues *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__SoapPhysicalIoValues), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfdouble(soap, "PhysicalIoValue", -1, &a->ns7__SoapPhysicalIoValues::PhysicalIoValue, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns7__SoapPhysicalIoValues::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns7__SoapPhysicalIoValues(soap, tag, this, type);
}

SOAP_FMAC3 ns7__SoapPhysicalIoValues * SOAP_FMAC4 soap_in_ns7__SoapPhysicalIoValues(struct soap *soap, const char *tag, ns7__SoapPhysicalIoValues *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__SoapPhysicalIoValues *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__SoapPhysicalIoValues, sizeof(ns7__SoapPhysicalIoValues), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns7__SoapPhysicalIoValues)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns7__SoapPhysicalIoValues *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfdouble(soap, "PhysicalIoValue", &a->ns7__SoapPhysicalIoValues::PhysicalIoValue, "xsd:double"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns7__SoapPhysicalIoValues *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__SoapPhysicalIoValues, SOAP_TYPE_ns7__SoapPhysicalIoValues, sizeof(ns7__SoapPhysicalIoValues), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns7__SoapPhysicalIoValues * SOAP_FMAC2 soap_instantiate_ns7__SoapPhysicalIoValues(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__SoapPhysicalIoValues(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns7__SoapPhysicalIoValues *p;
	size_t k = sizeof(ns7__SoapPhysicalIoValues);
	if (n < 0)
	{	p = SOAP_NEW(ns7__SoapPhysicalIoValues);
		if (p)
			((ns7__SoapPhysicalIoValues*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns7__SoapPhysicalIoValues, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns7__SoapPhysicalIoValues*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns7__SoapPhysicalIoValues location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns7__SoapPhysicalIoValues, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns7__SoapPhysicalIoValues::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns7__SoapPhysicalIoValues(soap, tag ? tag : "ns7:SoapPhysicalIoValues", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns7__SoapPhysicalIoValues::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__SoapPhysicalIoValues(soap, this, tag, type);
}

SOAP_FMAC3 ns7__SoapPhysicalIoValues * SOAP_FMAC4 soap_get_ns7__SoapPhysicalIoValues(struct soap *soap, ns7__SoapPhysicalIoValues *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__SoapPhysicalIoValues(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns7__SoapPhysicalIoState::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns7__SoapPhysicalIoEnumState(soap, &this->ns7__SoapPhysicalIoState::state);
	soap_default_bool(soap, &this->ns7__SoapPhysicalIoState::locked);
	soap_default_bool(soap, &this->ns7__SoapPhysicalIoState::simulated);
	soap_default_double(soap, &this->ns7__SoapPhysicalIoState::value);
	this->ns7__SoapPhysicalIoState::description = NULL;
	this->ns7__SoapPhysicalIoState::attrib = NULL;
	/* transient soap skipped */
}

void ns7__SoapPhysicalIoState::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns7__SoapPhysicalIoState::description);
	soap_serialize_PointerTons7__SoapPhysicalIoAttrib(soap, &this->ns7__SoapPhysicalIoState::attrib);
#endif
}

int ns7__SoapPhysicalIoState::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__SoapPhysicalIoState(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__SoapPhysicalIoState(struct soap *soap, const char *tag, int id, const ns7__SoapPhysicalIoState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__SoapPhysicalIoState), type))
		return soap->error;
	if (soap_out_ns7__SoapPhysicalIoEnumState(soap, "state", -1, &a->ns7__SoapPhysicalIoState::state, ""))
		return soap->error;
	if (soap_out_bool(soap, "locked", -1, &a->ns7__SoapPhysicalIoState::locked, ""))
		return soap->error;
	if (soap_out_bool(soap, "simulated", -1, &a->ns7__SoapPhysicalIoState::simulated, ""))
		return soap->error;
	if (soap_out_double(soap, "value", -1, &a->ns7__SoapPhysicalIoState::value, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "description", -1, &a->ns7__SoapPhysicalIoState::description, ""))
		return soap->error;
	if (!a->ns7__SoapPhysicalIoState::attrib)
	{	if (soap_element_empty(soap, "attrib"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons7__SoapPhysicalIoAttrib(soap, "attrib", -1, &a->ns7__SoapPhysicalIoState::attrib, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns7__SoapPhysicalIoState::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns7__SoapPhysicalIoState(soap, tag, this, type);
}

SOAP_FMAC3 ns7__SoapPhysicalIoState * SOAP_FMAC4 soap_in_ns7__SoapPhysicalIoState(struct soap *soap, const char *tag, ns7__SoapPhysicalIoState *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__SoapPhysicalIoState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__SoapPhysicalIoState, sizeof(ns7__SoapPhysicalIoState), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns7__SoapPhysicalIoState)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns7__SoapPhysicalIoState *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_state1 = 1;
	size_t soap_flag_locked1 = 1;
	size_t soap_flag_simulated1 = 1;
	size_t soap_flag_value1 = 1;
	size_t soap_flag_description1 = 1;
	size_t soap_flag_attrib1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_state1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns7__SoapPhysicalIoEnumState(soap, "state", &a->ns7__SoapPhysicalIoState::state, "ns7:SoapPhysicalIoEnumState"))
				{	soap_flag_state1--;
					continue;
				}
			}
			if (soap_flag_locked1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "locked", &a->ns7__SoapPhysicalIoState::locked, "xsd:boolean"))
				{	soap_flag_locked1--;
					continue;
				}
			}
			if (soap_flag_simulated1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "simulated", &a->ns7__SoapPhysicalIoState::simulated, "xsd:boolean"))
				{	soap_flag_simulated1--;
					continue;
				}
			}
			if (soap_flag_value1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "value", &a->ns7__SoapPhysicalIoState::value, "xsd:double"))
				{	soap_flag_value1--;
					continue;
				}
			}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "description", &a->ns7__SoapPhysicalIoState::description, "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			}
			if (soap_flag_attrib1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons7__SoapPhysicalIoAttrib(soap, "attrib", &a->ns7__SoapPhysicalIoState::attrib, "ns7:SoapPhysicalIoAttrib"))
				{	soap_flag_attrib1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_state1 > 0 || soap_flag_locked1 > 0 || soap_flag_simulated1 > 0 || soap_flag_value1 > 0 || !a->ns7__SoapPhysicalIoState::attrib))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns7__SoapPhysicalIoState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__SoapPhysicalIoState, SOAP_TYPE_ns7__SoapPhysicalIoState, sizeof(ns7__SoapPhysicalIoState), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns7__SoapPhysicalIoState * SOAP_FMAC2 soap_instantiate_ns7__SoapPhysicalIoState(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__SoapPhysicalIoState(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns7__SoapPhysicalIoState *p;
	size_t k = sizeof(ns7__SoapPhysicalIoState);
	if (n < 0)
	{	p = SOAP_NEW(ns7__SoapPhysicalIoState);
		if (p)
			((ns7__SoapPhysicalIoState*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns7__SoapPhysicalIoState, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns7__SoapPhysicalIoState*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns7__SoapPhysicalIoState location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns7__SoapPhysicalIoState, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns7__SoapPhysicalIoState::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns7__SoapPhysicalIoState(soap, tag ? tag : "ns7:SoapPhysicalIoState", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns7__SoapPhysicalIoState::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__SoapPhysicalIoState(soap, this, tag, type);
}

SOAP_FMAC3 ns7__SoapPhysicalIoState * SOAP_FMAC4 soap_get_ns7__SoapPhysicalIoState(struct soap *soap, ns7__SoapPhysicalIoState *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__SoapPhysicalIoState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns7__SoapPhysicalIoAttrib::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns7__SoapPhysicalIoAttrib::__union_SoapPhysicalIoAttrib = -1;
	/* transient soap skipped */
}

void ns7__SoapPhysicalIoAttrib::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__ns7__union_SoapPhysicalIoAttrib(soap, this->ns7__SoapPhysicalIoAttrib::__union_SoapPhysicalIoAttrib, &this->ns7__SoapPhysicalIoAttrib::union_SoapPhysicalIoAttrib);
#endif
}

int ns7__SoapPhysicalIoAttrib::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__SoapPhysicalIoAttrib(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__SoapPhysicalIoAttrib(struct soap *soap, const char *tag, int id, const ns7__SoapPhysicalIoAttrib *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__SoapPhysicalIoAttrib), type))
		return soap->error;
	if (soap_out__ns7__union_SoapPhysicalIoAttrib(soap, a->ns7__SoapPhysicalIoAttrib::__union_SoapPhysicalIoAttrib, &a->ns7__SoapPhysicalIoAttrib::union_SoapPhysicalIoAttrib))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns7__SoapPhysicalIoAttrib::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns7__SoapPhysicalIoAttrib(soap, tag, this, type);
}

SOAP_FMAC3 ns7__SoapPhysicalIoAttrib * SOAP_FMAC4 soap_in_ns7__SoapPhysicalIoAttrib(struct soap *soap, const char *tag, ns7__SoapPhysicalIoAttrib *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__SoapPhysicalIoAttrib *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__SoapPhysicalIoAttrib, sizeof(ns7__SoapPhysicalIoAttrib), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (!tag || *tag == '-' || (soap->body && *soap->href != '#'))
	{
		if (!soap_in__ns7__union_SoapPhysicalIoAttrib(soap, &a->__union_SoapPhysicalIoAttrib, &a->union_SoapPhysicalIoAttrib))
			return NULL;
		if (tag && *tag != '-')
		{	soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_TAG_MISMATCH || soap_element_end_in(soap, tag))
				return NULL;
		}
	}
	else
	{	a = (ns7__SoapPhysicalIoAttrib *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__SoapPhysicalIoAttrib, SOAP_TYPE_ns7__SoapPhysicalIoAttrib, sizeof(ns7__SoapPhysicalIoAttrib), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns7__SoapPhysicalIoAttrib * SOAP_FMAC2 soap_instantiate_ns7__SoapPhysicalIoAttrib(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__SoapPhysicalIoAttrib(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns7__SoapPhysicalIoAttrib *p;
	size_t k = sizeof(ns7__SoapPhysicalIoAttrib);
	if (n < 0)
	{	p = SOAP_NEW(ns7__SoapPhysicalIoAttrib);
		if (p)
			((ns7__SoapPhysicalIoAttrib*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns7__SoapPhysicalIoAttrib, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns7__SoapPhysicalIoAttrib*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns7__SoapPhysicalIoAttrib location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns7__SoapPhysicalIoAttrib, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns7__SoapPhysicalIoAttrib::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns7__SoapPhysicalIoAttrib(soap, tag ? tag : "ns7:SoapPhysicalIoAttrib", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns7__SoapPhysicalIoAttrib::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__SoapPhysicalIoAttrib(soap, this, tag, type);
}

SOAP_FMAC3 ns7__SoapPhysicalIoAttrib * SOAP_FMAC4 soap_get_ns7__SoapPhysicalIoAttrib(struct soap *soap, ns7__SoapPhysicalIoAttrib *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__SoapPhysicalIoAttrib(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns7__SoapPhysicalAioAttrib::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_double(soap, &this->ns7__SoapPhysicalAioAttrib::coefA);
	soap_default_double(soap, &this->ns7__SoapPhysicalAioAttrib::coefB);
	/* transient soap skipped */
}

void ns7__SoapPhysicalAioAttrib::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns7__SoapPhysicalAioAttrib::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__SoapPhysicalAioAttrib(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__SoapPhysicalAioAttrib(struct soap *soap, const char *tag, int id, const ns7__SoapPhysicalAioAttrib *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__SoapPhysicalAioAttrib), type))
		return soap->error;
	if (soap_out_double(soap, "coefA", -1, &a->ns7__SoapPhysicalAioAttrib::coefA, ""))
		return soap->error;
	if (soap_out_double(soap, "coefB", -1, &a->ns7__SoapPhysicalAioAttrib::coefB, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns7__SoapPhysicalAioAttrib::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns7__SoapPhysicalAioAttrib(soap, tag, this, type);
}

SOAP_FMAC3 ns7__SoapPhysicalAioAttrib * SOAP_FMAC4 soap_in_ns7__SoapPhysicalAioAttrib(struct soap *soap, const char *tag, ns7__SoapPhysicalAioAttrib *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__SoapPhysicalAioAttrib *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__SoapPhysicalAioAttrib, sizeof(ns7__SoapPhysicalAioAttrib), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns7__SoapPhysicalAioAttrib)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns7__SoapPhysicalAioAttrib *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_coefA1 = 1;
	size_t soap_flag_coefB1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_coefA1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "coefA", &a->ns7__SoapPhysicalAioAttrib::coefA, "xsd:double"))
				{	soap_flag_coefA1--;
					continue;
				}
			}
			if (soap_flag_coefB1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "coefB", &a->ns7__SoapPhysicalAioAttrib::coefB, "xsd:double"))
				{	soap_flag_coefB1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_coefA1 > 0 || soap_flag_coefB1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns7__SoapPhysicalAioAttrib *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__SoapPhysicalAioAttrib, SOAP_TYPE_ns7__SoapPhysicalAioAttrib, sizeof(ns7__SoapPhysicalAioAttrib), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns7__SoapPhysicalAioAttrib * SOAP_FMAC2 soap_instantiate_ns7__SoapPhysicalAioAttrib(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__SoapPhysicalAioAttrib(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns7__SoapPhysicalAioAttrib *p;
	size_t k = sizeof(ns7__SoapPhysicalAioAttrib);
	if (n < 0)
	{	p = SOAP_NEW(ns7__SoapPhysicalAioAttrib);
		if (p)
			((ns7__SoapPhysicalAioAttrib*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns7__SoapPhysicalAioAttrib, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns7__SoapPhysicalAioAttrib*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns7__SoapPhysicalAioAttrib location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns7__SoapPhysicalAioAttrib, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns7__SoapPhysicalAioAttrib::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns7__SoapPhysicalAioAttrib(soap, tag ? tag : "ns7:SoapPhysicalAioAttrib", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns7__SoapPhysicalAioAttrib::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__SoapPhysicalAioAttrib(soap, this, tag, type);
}

SOAP_FMAC3 ns7__SoapPhysicalAioAttrib * SOAP_FMAC4 soap_get_ns7__SoapPhysicalAioAttrib(struct soap *soap, ns7__SoapPhysicalAioAttrib *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__SoapPhysicalAioAttrib(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns7__SoapPhysicalDioAttrib::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->ns7__SoapPhysicalDioAttrib::inverted);
	/* transient soap skipped */
}

void ns7__SoapPhysicalDioAttrib::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns7__SoapPhysicalDioAttrib::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__SoapPhysicalDioAttrib(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__SoapPhysicalDioAttrib(struct soap *soap, const char *tag, int id, const ns7__SoapPhysicalDioAttrib *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__SoapPhysicalDioAttrib), type))
		return soap->error;
	if (soap_out_bool(soap, "inverted", -1, &a->ns7__SoapPhysicalDioAttrib::inverted, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns7__SoapPhysicalDioAttrib::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns7__SoapPhysicalDioAttrib(soap, tag, this, type);
}

SOAP_FMAC3 ns7__SoapPhysicalDioAttrib * SOAP_FMAC4 soap_in_ns7__SoapPhysicalDioAttrib(struct soap *soap, const char *tag, ns7__SoapPhysicalDioAttrib *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__SoapPhysicalDioAttrib *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__SoapPhysicalDioAttrib, sizeof(ns7__SoapPhysicalDioAttrib), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns7__SoapPhysicalDioAttrib)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns7__SoapPhysicalDioAttrib *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_inverted1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_inverted1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "inverted", &a->ns7__SoapPhysicalDioAttrib::inverted, "xsd:boolean"))
				{	soap_flag_inverted1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_inverted1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns7__SoapPhysicalDioAttrib *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__SoapPhysicalDioAttrib, SOAP_TYPE_ns7__SoapPhysicalDioAttrib, sizeof(ns7__SoapPhysicalDioAttrib), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns7__SoapPhysicalDioAttrib * SOAP_FMAC2 soap_instantiate_ns7__SoapPhysicalDioAttrib(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__SoapPhysicalDioAttrib(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns7__SoapPhysicalDioAttrib *p;
	size_t k = sizeof(ns7__SoapPhysicalDioAttrib);
	if (n < 0)
	{	p = SOAP_NEW(ns7__SoapPhysicalDioAttrib);
		if (p)
			((ns7__SoapPhysicalDioAttrib*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns7__SoapPhysicalDioAttrib, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns7__SoapPhysicalDioAttrib*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns7__SoapPhysicalDioAttrib location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns7__SoapPhysicalDioAttrib, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns7__SoapPhysicalDioAttrib::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns7__SoapPhysicalDioAttrib(soap, tag ? tag : "ns7:SoapPhysicalDioAttrib", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns7__SoapPhysicalDioAttrib::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__SoapPhysicalDioAttrib(soap, this, tag, type);
}

SOAP_FMAC3 ns7__SoapPhysicalDioAttrib * SOAP_FMAC4 soap_get_ns7__SoapPhysicalDioAttrib(struct soap *soap, ns7__SoapPhysicalDioAttrib *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__SoapPhysicalDioAttrib(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns7__SoapPhysicalIoLinks::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns7__SoapPhysicalIoLinks::PhysicalPath);
	/* transient soap skipped */
}

void ns7__SoapPhysicalIoLinks::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns7__SoapPhysicalIoLinks::PhysicalPath);
#endif
}

int ns7__SoapPhysicalIoLinks::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__SoapPhysicalIoLinks(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__SoapPhysicalIoLinks(struct soap *soap, const char *tag, int id, const ns7__SoapPhysicalIoLinks *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__SoapPhysicalIoLinks), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "PhysicalPath", -1, &a->ns7__SoapPhysicalIoLinks::PhysicalPath, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns7__SoapPhysicalIoLinks::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns7__SoapPhysicalIoLinks(soap, tag, this, type);
}

SOAP_FMAC3 ns7__SoapPhysicalIoLinks * SOAP_FMAC4 soap_in_ns7__SoapPhysicalIoLinks(struct soap *soap, const char *tag, ns7__SoapPhysicalIoLinks *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__SoapPhysicalIoLinks *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__SoapPhysicalIoLinks, sizeof(ns7__SoapPhysicalIoLinks), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns7__SoapPhysicalIoLinks)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns7__SoapPhysicalIoLinks *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfstd__string(soap, "PhysicalPath", &a->ns7__SoapPhysicalIoLinks::PhysicalPath, "xsd:string"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns7__SoapPhysicalIoLinks *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__SoapPhysicalIoLinks, SOAP_TYPE_ns7__SoapPhysicalIoLinks, sizeof(ns7__SoapPhysicalIoLinks), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns7__SoapPhysicalIoLinks * SOAP_FMAC2 soap_instantiate_ns7__SoapPhysicalIoLinks(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__SoapPhysicalIoLinks(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns7__SoapPhysicalIoLinks *p;
	size_t k = sizeof(ns7__SoapPhysicalIoLinks);
	if (n < 0)
	{	p = SOAP_NEW(ns7__SoapPhysicalIoLinks);
		if (p)
			((ns7__SoapPhysicalIoLinks*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns7__SoapPhysicalIoLinks, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns7__SoapPhysicalIoLinks*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns7__SoapPhysicalIoLinks location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns7__SoapPhysicalIoLinks, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns7__SoapPhysicalIoLinks::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns7__SoapPhysicalIoLinks(soap, tag ? tag : "ns7:SoapPhysicalIoLinks", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns7__SoapPhysicalIoLinks::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__SoapPhysicalIoLinks(soap, this, tag, type);
}

SOAP_FMAC3 ns7__SoapPhysicalIoLinks * SOAP_FMAC4 soap_get_ns7__SoapPhysicalIoLinks(struct soap *soap, ns7__SoapPhysicalIoLinks *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__SoapPhysicalIoLinks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns7__SoapWatches::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons7__SoapData(soap, &this->ns7__SoapWatches::SoapData);
	/* transient soap skipped */
}

void ns7__SoapWatches::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons7__SoapData(soap, &this->ns7__SoapWatches::SoapData);
#endif
}

int ns7__SoapWatches::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__SoapWatches(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__SoapWatches(struct soap *soap, const char *tag, int id, const ns7__SoapWatches *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__SoapWatches), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons7__SoapData(soap, "SoapData", -1, &a->ns7__SoapWatches::SoapData, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns7__SoapWatches::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns7__SoapWatches(soap, tag, this, type);
}

SOAP_FMAC3 ns7__SoapWatches * SOAP_FMAC4 soap_in_ns7__SoapWatches(struct soap *soap, const char *tag, ns7__SoapWatches *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__SoapWatches *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__SoapWatches, sizeof(ns7__SoapWatches), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns7__SoapWatches)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns7__SoapWatches *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons7__SoapData(soap, "SoapData", &a->ns7__SoapWatches::SoapData, "ns7:SoapData"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns7__SoapWatches *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__SoapWatches, SOAP_TYPE_ns7__SoapWatches, sizeof(ns7__SoapWatches), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns7__SoapWatches * SOAP_FMAC2 soap_instantiate_ns7__SoapWatches(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__SoapWatches(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns7__SoapWatches *p;
	size_t k = sizeof(ns7__SoapWatches);
	if (n < 0)
	{	p = SOAP_NEW(ns7__SoapWatches);
		if (p)
			((ns7__SoapWatches*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns7__SoapWatches, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns7__SoapWatches*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns7__SoapWatches location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns7__SoapWatches, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns7__SoapWatches::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns7__SoapWatches(soap, tag ? tag : "ns7:SoapWatches", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns7__SoapWatches::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__SoapWatches(soap, this, tag, type);
}

SOAP_FMAC3 ns7__SoapWatches * SOAP_FMAC4 soap_get_ns7__SoapWatches(struct soap *soap, ns7__SoapWatches *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__SoapWatches(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns7__SoapData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns7__SoapData::appName = NULL;
	this->ns7__SoapData::dataName = NULL;
	this->ns7__SoapData::dataIndex = NULL;
	/* transient soap skipped */
}

void ns7__SoapData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns7__SoapData::appName);
	soap_serialize_PointerTostd__string(soap, &this->ns7__SoapData::dataName);
	soap_serialize_PointerTostd__string(soap, &this->ns7__SoapData::dataIndex);
#endif
}

int ns7__SoapData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__SoapData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__SoapData(struct soap *soap, const char *tag, int id, const ns7__SoapData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__SoapData), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "appName", -1, &a->ns7__SoapData::appName, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "dataName", -1, &a->ns7__SoapData::dataName, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "dataIndex", -1, &a->ns7__SoapData::dataIndex, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns7__SoapData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns7__SoapData(soap, tag, this, type);
}

SOAP_FMAC3 ns7__SoapData * SOAP_FMAC4 soap_in_ns7__SoapData(struct soap *soap, const char *tag, ns7__SoapData *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__SoapData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__SoapData, sizeof(ns7__SoapData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns7__SoapData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns7__SoapData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_appName1 = 1;
	size_t soap_flag_dataName1 = 1;
	size_t soap_flag_dataIndex1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_appName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "appName", &a->ns7__SoapData::appName, "xsd:string"))
				{	soap_flag_appName1--;
					continue;
				}
			}
			if (soap_flag_dataName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "dataName", &a->ns7__SoapData::dataName, "xsd:string"))
				{	soap_flag_dataName1--;
					continue;
				}
			}
			if (soap_flag_dataIndex1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "dataIndex", &a->ns7__SoapData::dataIndex, "xsd:string"))
				{	soap_flag_dataIndex1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns7__SoapData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__SoapData, SOAP_TYPE_ns7__SoapData, sizeof(ns7__SoapData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns7__SoapData * SOAP_FMAC2 soap_instantiate_ns7__SoapData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__SoapData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns7__SoapData *p;
	size_t k = sizeof(ns7__SoapData);
	if (n < 0)
	{	p = SOAP_NEW(ns7__SoapData);
		if (p)
			((ns7__SoapData*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns7__SoapData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns7__SoapData*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns7__SoapData location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns7__SoapData, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns7__SoapData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns7__SoapData(soap, tag ? tag : "ns7:SoapData", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns7__SoapData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__SoapData(soap, this, tag, type);
}

SOAP_FMAC3 ns7__SoapData * SOAP_FMAC4 soap_get_ns7__SoapData(struct soap *soap, ns7__SoapData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__SoapData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns7__SoapCallStack::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons7__SoapStackFrameAbstract(soap, &this->ns7__SoapCallStack::SfAbstract);
	/* transient soap skipped */
}

void ns7__SoapCallStack::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons7__SoapStackFrameAbstract(soap, &this->ns7__SoapCallStack::SfAbstract);
#endif
}

int ns7__SoapCallStack::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__SoapCallStack(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__SoapCallStack(struct soap *soap, const char *tag, int id, const ns7__SoapCallStack *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__SoapCallStack), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons7__SoapStackFrameAbstract(soap, "SfAbstract", -1, &a->ns7__SoapCallStack::SfAbstract, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns7__SoapCallStack::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns7__SoapCallStack(soap, tag, this, type);
}

SOAP_FMAC3 ns7__SoapCallStack * SOAP_FMAC4 soap_in_ns7__SoapCallStack(struct soap *soap, const char *tag, ns7__SoapCallStack *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__SoapCallStack *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__SoapCallStack, sizeof(ns7__SoapCallStack), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns7__SoapCallStack)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns7__SoapCallStack *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons7__SoapStackFrameAbstract(soap, "SfAbstract", &a->ns7__SoapCallStack::SfAbstract, "ns7:SoapStackFrameAbstract"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns7__SoapCallStack *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__SoapCallStack, SOAP_TYPE_ns7__SoapCallStack, sizeof(ns7__SoapCallStack), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns7__SoapCallStack * SOAP_FMAC2 soap_instantiate_ns7__SoapCallStack(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__SoapCallStack(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns7__SoapCallStack *p;
	size_t k = sizeof(ns7__SoapCallStack);
	if (n < 0)
	{	p = SOAP_NEW(ns7__SoapCallStack);
		if (p)
			((ns7__SoapCallStack*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns7__SoapCallStack, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns7__SoapCallStack*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns7__SoapCallStack location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns7__SoapCallStack, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns7__SoapCallStack::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns7__SoapCallStack(soap, tag ? tag : "ns7:SoapCallStack", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns7__SoapCallStack::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__SoapCallStack(soap, this, tag, type);
}

SOAP_FMAC3 ns7__SoapCallStack * SOAP_FMAC4 soap_get_ns7__SoapCallStack(struct soap *soap, ns7__SoapCallStack *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__SoapCallStack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns7__SoapStackFrameAbstract::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns7__SoapStackFrameAbstract::currentInstruction = NULL;
	/* transient soap skipped */
}

void ns7__SoapStackFrameAbstract::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons7__SoapInstruction(soap, &this->ns7__SoapStackFrameAbstract::currentInstruction);
#endif
}

int ns7__SoapStackFrameAbstract::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__SoapStackFrameAbstract(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__SoapStackFrameAbstract(struct soap *soap, const char *tag, int id, const ns7__SoapStackFrameAbstract *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__SoapStackFrameAbstract), type))
		return soap->error;
	if (!a->ns7__SoapStackFrameAbstract::currentInstruction)
	{	if (soap_element_empty(soap, "currentInstruction"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons7__SoapInstruction(soap, "currentInstruction", -1, &a->ns7__SoapStackFrameAbstract::currentInstruction, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns7__SoapStackFrameAbstract::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns7__SoapStackFrameAbstract(soap, tag, this, type);
}

SOAP_FMAC3 ns7__SoapStackFrameAbstract * SOAP_FMAC4 soap_in_ns7__SoapStackFrameAbstract(struct soap *soap, const char *tag, ns7__SoapStackFrameAbstract *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__SoapStackFrameAbstract *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__SoapStackFrameAbstract, sizeof(ns7__SoapStackFrameAbstract), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns7__SoapStackFrameAbstract)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns7__SoapStackFrameAbstract *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_currentInstruction1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_currentInstruction1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons7__SoapInstruction(soap, "currentInstruction", &a->ns7__SoapStackFrameAbstract::currentInstruction, "ns7:SoapInstruction"))
				{	soap_flag_currentInstruction1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns7__SoapStackFrameAbstract::currentInstruction))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns7__SoapStackFrameAbstract *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__SoapStackFrameAbstract, SOAP_TYPE_ns7__SoapStackFrameAbstract, sizeof(ns7__SoapStackFrameAbstract), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns7__SoapStackFrameAbstract * SOAP_FMAC2 soap_instantiate_ns7__SoapStackFrameAbstract(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__SoapStackFrameAbstract(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns7__SoapStackFrameAbstract *p;
	size_t k = sizeof(ns7__SoapStackFrameAbstract);
	if (n < 0)
	{	p = SOAP_NEW(ns7__SoapStackFrameAbstract);
		if (p)
			((ns7__SoapStackFrameAbstract*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns7__SoapStackFrameAbstract, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns7__SoapStackFrameAbstract*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns7__SoapStackFrameAbstract location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns7__SoapStackFrameAbstract, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns7__SoapStackFrameAbstract::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns7__SoapStackFrameAbstract(soap, tag ? tag : "ns7:SoapStackFrameAbstract", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns7__SoapStackFrameAbstract::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__SoapStackFrameAbstract(soap, this, tag, type);
}

SOAP_FMAC3 ns7__SoapStackFrameAbstract * SOAP_FMAC4 soap_get_ns7__SoapStackFrameAbstract(struct soap *soap, ns7__SoapStackFrameAbstract *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__SoapStackFrameAbstract(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns7__SoapInstruction::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns7__SoapInstruction::programLine = NULL;
	/* transient soap skipped */
}

void ns7__SoapInstruction::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons7__SoapProgramLine(soap, &this->ns7__SoapInstruction::programLine);
#endif
}

int ns7__SoapInstruction::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__SoapInstruction(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__SoapInstruction(struct soap *soap, const char *tag, int id, const ns7__SoapInstruction *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__SoapInstruction), type))
		return soap->error;
	if (!a->ns7__SoapInstruction::programLine)
	{	if (soap_element_empty(soap, "programLine"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons7__SoapProgramLine(soap, "programLine", -1, &a->ns7__SoapInstruction::programLine, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns7__SoapInstruction::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns7__SoapInstruction(soap, tag, this, type);
}

SOAP_FMAC3 ns7__SoapInstruction * SOAP_FMAC4 soap_in_ns7__SoapInstruction(struct soap *soap, const char *tag, ns7__SoapInstruction *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__SoapInstruction *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__SoapInstruction, sizeof(ns7__SoapInstruction), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns7__SoapInstruction)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns7__SoapInstruction *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_programLine1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_programLine1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons7__SoapProgramLine(soap, "programLine", &a->ns7__SoapInstruction::programLine, "ns7:SoapProgramLine"))
				{	soap_flag_programLine1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns7__SoapInstruction::programLine))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns7__SoapInstruction *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__SoapInstruction, SOAP_TYPE_ns7__SoapInstruction, sizeof(ns7__SoapInstruction), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns7__SoapInstruction * SOAP_FMAC2 soap_instantiate_ns7__SoapInstruction(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__SoapInstruction(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns7__SoapInstruction *p;
	size_t k = sizeof(ns7__SoapInstruction);
	if (n < 0)
	{	p = SOAP_NEW(ns7__SoapInstruction);
		if (p)
			((ns7__SoapInstruction*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns7__SoapInstruction, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns7__SoapInstruction*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns7__SoapInstruction location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns7__SoapInstruction, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns7__SoapInstruction::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns7__SoapInstruction(soap, tag ? tag : "ns7:SoapInstruction", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns7__SoapInstruction::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__SoapInstruction(soap, this, tag, type);
}

SOAP_FMAC3 ns7__SoapInstruction * SOAP_FMAC4 soap_get_ns7__SoapInstruction(struct soap *soap, ns7__SoapInstruction *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__SoapInstruction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns7__SoapTasks::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons7__SoapTask(soap, &this->ns7__SoapTasks::Task);
	/* transient soap skipped */
}

void ns7__SoapTasks::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons7__SoapTask(soap, &this->ns7__SoapTasks::Task);
#endif
}

int ns7__SoapTasks::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__SoapTasks(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__SoapTasks(struct soap *soap, const char *tag, int id, const ns7__SoapTasks *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__SoapTasks), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons7__SoapTask(soap, "Task", -1, &a->ns7__SoapTasks::Task, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns7__SoapTasks::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns7__SoapTasks(soap, tag, this, type);
}

SOAP_FMAC3 ns7__SoapTasks * SOAP_FMAC4 soap_in_ns7__SoapTasks(struct soap *soap, const char *tag, ns7__SoapTasks *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__SoapTasks *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__SoapTasks, sizeof(ns7__SoapTasks), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns7__SoapTasks)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns7__SoapTasks *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons7__SoapTask(soap, "Task", &a->ns7__SoapTasks::Task, "ns7:SoapTask"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns7__SoapTasks *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__SoapTasks, SOAP_TYPE_ns7__SoapTasks, sizeof(ns7__SoapTasks), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns7__SoapTasks * SOAP_FMAC2 soap_instantiate_ns7__SoapTasks(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__SoapTasks(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns7__SoapTasks *p;
	size_t k = sizeof(ns7__SoapTasks);
	if (n < 0)
	{	p = SOAP_NEW(ns7__SoapTasks);
		if (p)
			((ns7__SoapTasks*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns7__SoapTasks, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns7__SoapTasks*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns7__SoapTasks location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns7__SoapTasks, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns7__SoapTasks::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns7__SoapTasks(soap, tag ? tag : "ns7:SoapTasks", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns7__SoapTasks::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__SoapTasks(soap, this, tag, type);
}

SOAP_FMAC3 ns7__SoapTasks * SOAP_FMAC4 soap_get_ns7__SoapTasks(struct soap *soap, ns7__SoapTasks *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__SoapTasks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns7__SoapTask::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns7__SoapTask::name = NULL;
	soap_default_ns7__SoapTaskState(soap, &this->ns7__SoapTask::state);
	soap_default_int(soap, &this->ns7__SoapTask::priority);
	this->ns7__SoapTask::createdBy = NULL;
	soap_default_int(soap, &this->ns7__SoapTask::runtimeError);
	this->ns7__SoapTask::runtimeErrorDescription = NULL;
	this->ns7__SoapTask::programLine = NULL;
	/* transient soap skipped */
}

void ns7__SoapTask::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns7__SoapTask::name);
	soap_serialize_PointerTostd__string(soap, &this->ns7__SoapTask::createdBy);
	soap_serialize_PointerTostd__string(soap, &this->ns7__SoapTask::runtimeErrorDescription);
	soap_serialize_PointerTons7__SoapProgramLine(soap, &this->ns7__SoapTask::programLine);
#endif
}

int ns7__SoapTask::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__SoapTask(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__SoapTask(struct soap *soap, const char *tag, int id, const ns7__SoapTask *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__SoapTask), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "name", -1, &a->ns7__SoapTask::name, ""))
		return soap->error;
	if (soap_out_ns7__SoapTaskState(soap, "state", -1, &a->ns7__SoapTask::state, ""))
		return soap->error;
	if (soap_out_int(soap, "priority", -1, &a->ns7__SoapTask::priority, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "createdBy", -1, &a->ns7__SoapTask::createdBy, ""))
		return soap->error;
	if (soap_out_int(soap, "runtimeError", -1, &a->ns7__SoapTask::runtimeError, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "runtimeErrorDescription", -1, &a->ns7__SoapTask::runtimeErrorDescription, ""))
		return soap->error;
	if (!a->ns7__SoapTask::programLine)
	{	if (soap_element_empty(soap, "programLine"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons7__SoapProgramLine(soap, "programLine", -1, &a->ns7__SoapTask::programLine, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns7__SoapTask::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns7__SoapTask(soap, tag, this, type);
}

SOAP_FMAC3 ns7__SoapTask * SOAP_FMAC4 soap_in_ns7__SoapTask(struct soap *soap, const char *tag, ns7__SoapTask *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__SoapTask *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__SoapTask, sizeof(ns7__SoapTask), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns7__SoapTask)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns7__SoapTask *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_name1 = 1;
	size_t soap_flag_state1 = 1;
	size_t soap_flag_priority1 = 1;
	size_t soap_flag_createdBy1 = 1;
	size_t soap_flag_runtimeError1 = 1;
	size_t soap_flag_runtimeErrorDescription1 = 1;
	size_t soap_flag_programLine1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "name", &a->ns7__SoapTask::name, "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			}
			if (soap_flag_state1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns7__SoapTaskState(soap, "state", &a->ns7__SoapTask::state, "ns7:SoapTaskState"))
				{	soap_flag_state1--;
					continue;
				}
			}
			if (soap_flag_priority1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "priority", &a->ns7__SoapTask::priority, "xsd:int"))
				{	soap_flag_priority1--;
					continue;
				}
			}
			if (soap_flag_createdBy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "createdBy", &a->ns7__SoapTask::createdBy, "xsd:string"))
				{	soap_flag_createdBy1--;
					continue;
				}
			}
			if (soap_flag_runtimeError1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "runtimeError", &a->ns7__SoapTask::runtimeError, "xsd:int"))
				{	soap_flag_runtimeError1--;
					continue;
				}
			}
			if (soap_flag_runtimeErrorDescription1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "runtimeErrorDescription", &a->ns7__SoapTask::runtimeErrorDescription, "xsd:string"))
				{	soap_flag_runtimeErrorDescription1--;
					continue;
				}
			}
			if (soap_flag_programLine1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons7__SoapProgramLine(soap, "programLine", &a->ns7__SoapTask::programLine, "ns7:SoapProgramLine"))
				{	soap_flag_programLine1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_state1 > 0 || soap_flag_priority1 > 0 || soap_flag_runtimeError1 > 0 || !a->ns7__SoapTask::programLine))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns7__SoapTask *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__SoapTask, SOAP_TYPE_ns7__SoapTask, sizeof(ns7__SoapTask), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns7__SoapTask * SOAP_FMAC2 soap_instantiate_ns7__SoapTask(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__SoapTask(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns7__SoapTask *p;
	size_t k = sizeof(ns7__SoapTask);
	if (n < 0)
	{	p = SOAP_NEW(ns7__SoapTask);
		if (p)
			((ns7__SoapTask*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns7__SoapTask, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns7__SoapTask*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns7__SoapTask location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns7__SoapTask, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns7__SoapTask::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns7__SoapTask(soap, tag ? tag : "ns7:SoapTask", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns7__SoapTask::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__SoapTask(soap, this, tag, type);
}

SOAP_FMAC3 ns7__SoapTask * SOAP_FMAC4 soap_get_ns7__SoapTask(struct soap *soap, ns7__SoapTask *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__SoapTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns7__MimeData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns7__MimeData::data.xsd__base64Binary::soap_default(soap);
	this->ns7__MimeData::ns5__contentType = NULL;
	/* transient soap skipped */
}

void ns7__MimeData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns7__MimeData::data.soap_serialize(soap);
#endif
}

int ns7__MimeData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__MimeData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__MimeData(struct soap *soap, const char *tag, int id, const ns7__MimeData *a, const char *type)
{
	if (((ns7__MimeData*)a)->ns5__contentType)
	{	soap_set_attr(soap, "ns5:contentType", soap_std__string2s(soap, *((ns7__MimeData*)a)->ns5__contentType), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__MimeData), type))
		return soap->error;
	if ((a->ns7__MimeData::data).soap_out(soap, "data", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns7__MimeData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns7__MimeData(soap, tag, this, type);
}

SOAP_FMAC3 ns7__MimeData * SOAP_FMAC4 soap_in_ns7__MimeData(struct soap *soap, const char *tag, ns7__MimeData *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__MimeData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__MimeData, sizeof(ns7__MimeData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns7__MimeData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns7__MimeData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "ns5:contentType", 1, 0);
		if (t)
		{
			if (!(((ns7__MimeData*)a)->ns5__contentType = soap_new_std__string(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2std__string(soap, t, ((ns7__MimeData*)a)->ns5__contentType))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_data1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_data1 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns7__MimeData::data).soap_in(soap, "data", "xsd:base64Binary"))
				{	soap_flag_data1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_data1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns7__MimeData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__MimeData, SOAP_TYPE_ns7__MimeData, sizeof(ns7__MimeData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns7__MimeData * SOAP_FMAC2 soap_instantiate_ns7__MimeData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__MimeData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns7__MimeData *p;
	size_t k = sizeof(ns7__MimeData);
	if (n < 0)
	{	p = SOAP_NEW(ns7__MimeData);
		if (p)
			((ns7__MimeData*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns7__MimeData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns7__MimeData*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns7__MimeData location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns7__MimeData, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns7__MimeData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns7__MimeData(soap, tag ? tag : "ns7:MimeData", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns7__MimeData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__MimeData(soap, this, tag, type);
}

SOAP_FMAC3 ns7__MimeData * SOAP_FMAC4 soap_get_ns7__MimeData(struct soap *soap, ns7__MimeData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__MimeData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns7__BreakpointsResponses::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons7__BreakpointsResponse(soap, &this->ns7__BreakpointsResponses::BreakpointResponse);
	/* transient soap skipped */
}

void ns7__BreakpointsResponses::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons7__BreakpointsResponse(soap, &this->ns7__BreakpointsResponses::BreakpointResponse);
#endif
}

int ns7__BreakpointsResponses::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__BreakpointsResponses(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__BreakpointsResponses(struct soap *soap, const char *tag, int id, const ns7__BreakpointsResponses *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__BreakpointsResponses), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons7__BreakpointsResponse(soap, "BreakpointResponse", -1, &a->ns7__BreakpointsResponses::BreakpointResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns7__BreakpointsResponses::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns7__BreakpointsResponses(soap, tag, this, type);
}

SOAP_FMAC3 ns7__BreakpointsResponses * SOAP_FMAC4 soap_in_ns7__BreakpointsResponses(struct soap *soap, const char *tag, ns7__BreakpointsResponses *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__BreakpointsResponses *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__BreakpointsResponses, sizeof(ns7__BreakpointsResponses), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns7__BreakpointsResponses)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns7__BreakpointsResponses *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons7__BreakpointsResponse(soap, "BreakpointResponse", &a->ns7__BreakpointsResponses::BreakpointResponse, "ns7:BreakpointsResponse"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns7__BreakpointsResponses *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__BreakpointsResponses, SOAP_TYPE_ns7__BreakpointsResponses, sizeof(ns7__BreakpointsResponses), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns7__BreakpointsResponses * SOAP_FMAC2 soap_instantiate_ns7__BreakpointsResponses(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__BreakpointsResponses(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns7__BreakpointsResponses *p;
	size_t k = sizeof(ns7__BreakpointsResponses);
	if (n < 0)
	{	p = SOAP_NEW(ns7__BreakpointsResponses);
		if (p)
			((ns7__BreakpointsResponses*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns7__BreakpointsResponses, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns7__BreakpointsResponses*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns7__BreakpointsResponses location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns7__BreakpointsResponses, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns7__BreakpointsResponses::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns7__BreakpointsResponses(soap, tag ? tag : "ns7:BreakpointsResponses", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns7__BreakpointsResponses::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__BreakpointsResponses(soap, this, tag, type);
}

SOAP_FMAC3 ns7__BreakpointsResponses * SOAP_FMAC4 soap_get_ns7__BreakpointsResponses(struct soap *soap, ns7__BreakpointsResponses *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__BreakpointsResponses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns7__BreakpointsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns7__BreakpointsResponse::breakpointIndex);
	soap_default_ns1__ServerExceptionCode(soap, &this->ns7__BreakpointsResponse::errorCode);
	/* transient soap skipped */
}

void ns7__BreakpointsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns7__BreakpointsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__BreakpointsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__BreakpointsResponse(struct soap *soap, const char *tag, int id, const ns7__BreakpointsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__BreakpointsResponse), type))
		return soap->error;
	if (soap_out_int(soap, "breakpointIndex", -1, &a->ns7__BreakpointsResponse::breakpointIndex, ""))
		return soap->error;
	if (soap_out_ns1__ServerExceptionCode(soap, "errorCode", -1, &a->ns7__BreakpointsResponse::errorCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns7__BreakpointsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns7__BreakpointsResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns7__BreakpointsResponse * SOAP_FMAC4 soap_in_ns7__BreakpointsResponse(struct soap *soap, const char *tag, ns7__BreakpointsResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__BreakpointsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__BreakpointsResponse, sizeof(ns7__BreakpointsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns7__BreakpointsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns7__BreakpointsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_breakpointIndex1 = 1;
	size_t soap_flag_errorCode1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_breakpointIndex1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "breakpointIndex", &a->ns7__BreakpointsResponse::breakpointIndex, "xsd:int"))
				{	soap_flag_breakpointIndex1--;
					continue;
				}
			}
			if (soap_flag_errorCode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns1__ServerExceptionCode(soap, "errorCode", &a->ns7__BreakpointsResponse::errorCode, "ns1:ServerExceptionCode"))
				{	soap_flag_errorCode1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_breakpointIndex1 > 0 || soap_flag_errorCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns7__BreakpointsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__BreakpointsResponse, SOAP_TYPE_ns7__BreakpointsResponse, sizeof(ns7__BreakpointsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns7__BreakpointsResponse * SOAP_FMAC2 soap_instantiate_ns7__BreakpointsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__BreakpointsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns7__BreakpointsResponse *p;
	size_t k = sizeof(ns7__BreakpointsResponse);
	if (n < 0)
	{	p = SOAP_NEW(ns7__BreakpointsResponse);
		if (p)
			((ns7__BreakpointsResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns7__BreakpointsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns7__BreakpointsResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns7__BreakpointsResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns7__BreakpointsResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns7__BreakpointsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns7__BreakpointsResponse(soap, tag ? tag : "ns7:BreakpointsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns7__BreakpointsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__BreakpointsResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns7__BreakpointsResponse * SOAP_FMAC4 soap_get_ns7__BreakpointsResponse(struct soap *soap, ns7__BreakpointsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__BreakpointsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns7__SoapBreakpoints::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons7__SoapBreakpoint(soap, &this->ns7__SoapBreakpoints::BreakPoint);
	/* transient soap skipped */
}

void ns7__SoapBreakpoints::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons7__SoapBreakpoint(soap, &this->ns7__SoapBreakpoints::BreakPoint);
#endif
}

int ns7__SoapBreakpoints::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__SoapBreakpoints(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__SoapBreakpoints(struct soap *soap, const char *tag, int id, const ns7__SoapBreakpoints *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__SoapBreakpoints), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons7__SoapBreakpoint(soap, "BreakPoint", -1, &a->ns7__SoapBreakpoints::BreakPoint, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns7__SoapBreakpoints::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns7__SoapBreakpoints(soap, tag, this, type);
}

SOAP_FMAC3 ns7__SoapBreakpoints * SOAP_FMAC4 soap_in_ns7__SoapBreakpoints(struct soap *soap, const char *tag, ns7__SoapBreakpoints *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__SoapBreakpoints *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__SoapBreakpoints, sizeof(ns7__SoapBreakpoints), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns7__SoapBreakpoints)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns7__SoapBreakpoints *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons7__SoapBreakpoint(soap, "BreakPoint", &a->ns7__SoapBreakpoints::BreakPoint, "ns7:SoapBreakpoint"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns7__SoapBreakpoints *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__SoapBreakpoints, SOAP_TYPE_ns7__SoapBreakpoints, sizeof(ns7__SoapBreakpoints), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns7__SoapBreakpoints * SOAP_FMAC2 soap_instantiate_ns7__SoapBreakpoints(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__SoapBreakpoints(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns7__SoapBreakpoints *p;
	size_t k = sizeof(ns7__SoapBreakpoints);
	if (n < 0)
	{	p = SOAP_NEW(ns7__SoapBreakpoints);
		if (p)
			((ns7__SoapBreakpoints*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns7__SoapBreakpoints, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns7__SoapBreakpoints*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns7__SoapBreakpoints location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns7__SoapBreakpoints, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns7__SoapBreakpoints::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns7__SoapBreakpoints(soap, tag ? tag : "ns7:SoapBreakpoints", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns7__SoapBreakpoints::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__SoapBreakpoints(soap, this, tag, type);
}

SOAP_FMAC3 ns7__SoapBreakpoints * SOAP_FMAC4 soap_get_ns7__SoapBreakpoints(struct soap *soap, ns7__SoapBreakpoints *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__SoapBreakpoints(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns7__SoapBreakpoint::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns7__SoapBreakpoint::programLine = NULL;
	/* transient soap skipped */
}

void ns7__SoapBreakpoint::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons7__SoapProgramLine(soap, &this->ns7__SoapBreakpoint::programLine);
#endif
}

int ns7__SoapBreakpoint::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__SoapBreakpoint(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__SoapBreakpoint(struct soap *soap, const char *tag, int id, const ns7__SoapBreakpoint *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__SoapBreakpoint), type))
		return soap->error;
	if (!a->ns7__SoapBreakpoint::programLine)
	{	if (soap_element_empty(soap, "programLine"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons7__SoapProgramLine(soap, "programLine", -1, &a->ns7__SoapBreakpoint::programLine, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns7__SoapBreakpoint::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns7__SoapBreakpoint(soap, tag, this, type);
}

SOAP_FMAC3 ns7__SoapBreakpoint * SOAP_FMAC4 soap_in_ns7__SoapBreakpoint(struct soap *soap, const char *tag, ns7__SoapBreakpoint *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__SoapBreakpoint *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__SoapBreakpoint, sizeof(ns7__SoapBreakpoint), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns7__SoapBreakpoint)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns7__SoapBreakpoint *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_programLine1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_programLine1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons7__SoapProgramLine(soap, "programLine", &a->ns7__SoapBreakpoint::programLine, "ns7:SoapProgramLine"))
				{	soap_flag_programLine1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ns7__SoapBreakpoint::programLine))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns7__SoapBreakpoint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__SoapBreakpoint, SOAP_TYPE_ns7__SoapBreakpoint, sizeof(ns7__SoapBreakpoint), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns7__SoapBreakpoint * SOAP_FMAC2 soap_instantiate_ns7__SoapBreakpoint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__SoapBreakpoint(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns7__SoapBreakpoint *p;
	size_t k = sizeof(ns7__SoapBreakpoint);
	if (n < 0)
	{	p = SOAP_NEW(ns7__SoapBreakpoint);
		if (p)
			((ns7__SoapBreakpoint*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns7__SoapBreakpoint, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns7__SoapBreakpoint*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns7__SoapBreakpoint location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns7__SoapBreakpoint, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns7__SoapBreakpoint::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns7__SoapBreakpoint(soap, tag ? tag : "ns7:SoapBreakpoint", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns7__SoapBreakpoint::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__SoapBreakpoint(soap, this, tag, type);
}

SOAP_FMAC3 ns7__SoapBreakpoint * SOAP_FMAC4 soap_get_ns7__SoapBreakpoint(struct soap *soap, ns7__SoapBreakpoint *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__SoapBreakpoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns7__SoapProgramLine::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns7__SoapProgramLine::appName = NULL;
	this->ns7__SoapProgramLine::pgmName = NULL;
	soap_default_int(soap, &this->ns7__SoapProgramLine::lineNumber);
	this->ns7__SoapProgramLine::lineContent = NULL;
	/* transient soap skipped */
}

void ns7__SoapProgramLine::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns7__SoapProgramLine::appName);
	soap_serialize_PointerTostd__string(soap, &this->ns7__SoapProgramLine::pgmName);
	soap_serialize_PointerTostd__string(soap, &this->ns7__SoapProgramLine::lineContent);
#endif
}

int ns7__SoapProgramLine::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__SoapProgramLine(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__SoapProgramLine(struct soap *soap, const char *tag, int id, const ns7__SoapProgramLine *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__SoapProgramLine), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "appName", -1, &a->ns7__SoapProgramLine::appName, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "pgmName", -1, &a->ns7__SoapProgramLine::pgmName, ""))
		return soap->error;
	if (soap_out_int(soap, "lineNumber", -1, &a->ns7__SoapProgramLine::lineNumber, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "lineContent", -1, &a->ns7__SoapProgramLine::lineContent, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns7__SoapProgramLine::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns7__SoapProgramLine(soap, tag, this, type);
}

SOAP_FMAC3 ns7__SoapProgramLine * SOAP_FMAC4 soap_in_ns7__SoapProgramLine(struct soap *soap, const char *tag, ns7__SoapProgramLine *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__SoapProgramLine *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__SoapProgramLine, sizeof(ns7__SoapProgramLine), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns7__SoapProgramLine)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns7__SoapProgramLine *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_appName1 = 1;
	size_t soap_flag_pgmName1 = 1;
	size_t soap_flag_lineNumber1 = 1;
	size_t soap_flag_lineContent1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_appName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "appName", &a->ns7__SoapProgramLine::appName, "xsd:string"))
				{	soap_flag_appName1--;
					continue;
				}
			}
			if (soap_flag_pgmName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "pgmName", &a->ns7__SoapProgramLine::pgmName, "xsd:string"))
				{	soap_flag_pgmName1--;
					continue;
				}
			}
			if (soap_flag_lineNumber1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "lineNumber", &a->ns7__SoapProgramLine::lineNumber, "xsd:int"))
				{	soap_flag_lineNumber1--;
					continue;
				}
			}
			if (soap_flag_lineContent1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "lineContent", &a->ns7__SoapProgramLine::lineContent, "xsd:string"))
				{	soap_flag_lineContent1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_lineNumber1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns7__SoapProgramLine *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__SoapProgramLine, SOAP_TYPE_ns7__SoapProgramLine, sizeof(ns7__SoapProgramLine), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns7__SoapProgramLine * SOAP_FMAC2 soap_instantiate_ns7__SoapProgramLine(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__SoapProgramLine(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns7__SoapProgramLine *p;
	size_t k = sizeof(ns7__SoapProgramLine);
	if (n < 0)
	{	p = SOAP_NEW(ns7__SoapProgramLine);
		if (p)
			((ns7__SoapProgramLine*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns7__SoapProgramLine, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns7__SoapProgramLine*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns7__SoapProgramLine location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns7__SoapProgramLine, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns7__SoapProgramLine::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns7__SoapProgramLine(soap, tag ? tag : "ns7:SoapProgramLine", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns7__SoapProgramLine::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__SoapProgramLine(soap, this, tag, type);
}

SOAP_FMAC3 ns7__SoapProgramLine * SOAP_FMAC4 soap_get_ns7__SoapProgramLine(struct soap *soap, ns7__SoapProgramLine *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__SoapProgramLine(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns7__Records::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns7__Records::record);
	/* transient soap skipped */
}

void ns7__Records::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns7__Records::record);
#endif
}

int ns7__Records::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__Records(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__Records(struct soap *soap, const char *tag, int id, const ns7__Records *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__Records), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "record", -1, &a->ns7__Records::record, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns7__Records::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns7__Records(soap, tag, this, type);
}

SOAP_FMAC3 ns7__Records * SOAP_FMAC4 soap_in_ns7__Records(struct soap *soap, const char *tag, ns7__Records *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__Records *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__Records, sizeof(ns7__Records), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns7__Records)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns7__Records *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfstd__string(soap, "record", &a->ns7__Records::record, "xsd:string"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns7__Records *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__Records, SOAP_TYPE_ns7__Records, sizeof(ns7__Records), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns7__Records * SOAP_FMAC2 soap_instantiate_ns7__Records(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__Records(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns7__Records *p;
	size_t k = sizeof(ns7__Records);
	if (n < 0)
	{	p = SOAP_NEW(ns7__Records);
		if (p)
			((ns7__Records*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns7__Records, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns7__Records*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns7__Records location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns7__Records, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns7__Records::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns7__Records(soap, tag ? tag : "ns7:Records", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns7__Records::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__Records(soap, this, tag, type);
}

SOAP_FMAC3 ns7__Records * SOAP_FMAC4 soap_get_ns7__Records(struct soap *soap, ns7__Records *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__Records(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns7__VALApplications::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__VALApplication(soap, &this->ns7__VALApplications::application);
	/* transient soap skipped */
}

void ns7__VALApplications::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons2__VALApplication(soap, &this->ns7__VALApplications::application);
#endif
}

int ns7__VALApplications::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__VALApplications(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__VALApplications(struct soap *soap, const char *tag, int id, const ns7__VALApplications *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__VALApplications), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__VALApplication(soap, "application", -1, &a->ns7__VALApplications::application, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns7__VALApplications::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns7__VALApplications(soap, tag, this, type);
}

SOAP_FMAC3 ns7__VALApplications * SOAP_FMAC4 soap_in_ns7__VALApplications(struct soap *soap, const char *tag, ns7__VALApplications *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__VALApplications *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__VALApplications, sizeof(ns7__VALApplications), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns7__VALApplications)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns7__VALApplications *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons2__VALApplication(soap, "application", &a->ns7__VALApplications::application, "ns2:VALApplication"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns7__VALApplications *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__VALApplications, SOAP_TYPE_ns7__VALApplications, sizeof(ns7__VALApplications), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns7__VALApplications * SOAP_FMAC2 soap_instantiate_ns7__VALApplications(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__VALApplications(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns7__VALApplications *p;
	size_t k = sizeof(ns7__VALApplications);
	if (n < 0)
	{	p = SOAP_NEW(ns7__VALApplications);
		if (p)
			((ns7__VALApplications*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns7__VALApplications, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns7__VALApplications*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns7__VALApplications location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns7__VALApplications, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns7__VALApplications::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns7__VALApplications(soap, tag ? tag : "ns7:VALApplications", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns7__VALApplications::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__VALApplications(soap, this, tag, type);
}

SOAP_FMAC3 ns7__VALApplications * SOAP_FMAC4 soap_get_ns7__VALApplications(struct soap *soap, ns7__VALApplications *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__VALApplications(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns7__Robots::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__Robot(soap, &this->ns7__Robots::Robots);
	/* transient soap skipped */
}

void ns7__Robots::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__Robot(soap, &this->ns7__Robots::Robots);
#endif
}

int ns7__Robots::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__Robots(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__Robots(struct soap *soap, const char *tag, int id, const ns7__Robots *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__Robots), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__Robot(soap, "Robots", -1, &a->ns7__Robots::Robots, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns7__Robots::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns7__Robots(soap, tag, this, type);
}

SOAP_FMAC3 ns7__Robots * SOAP_FMAC4 soap_in_ns7__Robots(struct soap *soap, const char *tag, ns7__Robots *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__Robots *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__Robots, sizeof(ns7__Robots), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns7__Robots)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns7__Robots *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__Robot(soap, "Robots", &a->ns7__Robots::Robots, "ns1:Robot"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns7__Robots *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__Robots, SOAP_TYPE_ns7__Robots, sizeof(ns7__Robots), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns7__Robots * SOAP_FMAC2 soap_instantiate_ns7__Robots(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__Robots(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns7__Robots *p;
	size_t k = sizeof(ns7__Robots);
	if (n < 0)
	{	p = SOAP_NEW(ns7__Robots);
		if (p)
			((ns7__Robots*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns7__Robots, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns7__Robots*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns7__Robots location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns7__Robots, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns7__Robots::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns7__Robots(soap, tag ? tag : "ns7:Robots", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns7__Robots::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__Robots(soap, this, tag, type);
}

SOAP_FMAC3 ns7__Robots * SOAP_FMAC4 soap_get_ns7__Robots(struct soap *soap, ns7__Robots *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__Robots(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns7__Versions::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__Version(soap, &this->ns7__Versions::Versions);
	/* transient soap skipped */
}

void ns7__Versions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__Version(soap, &this->ns7__Versions::Versions);
#endif
}

int ns7__Versions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__Versions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__Versions(struct soap *soap, const char *tag, int id, const ns7__Versions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__Versions), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__Version(soap, "Versions", -1, &a->ns7__Versions::Versions, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns7__Versions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns7__Versions(soap, tag, this, type);
}

SOAP_FMAC3 ns7__Versions * SOAP_FMAC4 soap_in_ns7__Versions(struct soap *soap, const char *tag, ns7__Versions *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__Versions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__Versions, sizeof(ns7__Versions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns7__Versions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns7__Versions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__Version(soap, "Versions", &a->ns7__Versions::Versions, "ns1:Version"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns7__Versions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__Versions, SOAP_TYPE_ns7__Versions, sizeof(ns7__Versions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns7__Versions * SOAP_FMAC2 soap_instantiate_ns7__Versions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__Versions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns7__Versions *p;
	size_t k = sizeof(ns7__Versions);
	if (n < 0)
	{	p = SOAP_NEW(ns7__Versions);
		if (p)
			((ns7__Versions*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns7__Versions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns7__Versions*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns7__Versions location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns7__Versions, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns7__Versions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns7__Versions(soap, tag ? tag : "ns7:Versions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns7__Versions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__Versions(soap, this, tag, type);
}

SOAP_FMAC3 ns7__Versions * SOAP_FMAC4 soap_get_ns7__Versions(struct soap *soap, ns7__Versions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__Versions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns7__Parameters::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__Parameter(soap, &this->ns7__Parameters::Parameters);
	/* transient soap skipped */
}

void ns7__Parameters::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__Parameter(soap, &this->ns7__Parameters::Parameters);
#endif
}

int ns7__Parameters::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__Parameters(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__Parameters(struct soap *soap, const char *tag, int id, const ns7__Parameters *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__Parameters), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__Parameter(soap, "Parameters", -1, &a->ns7__Parameters::Parameters, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns7__Parameters::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns7__Parameters(soap, tag, this, type);
}

SOAP_FMAC3 ns7__Parameters * SOAP_FMAC4 soap_in_ns7__Parameters(struct soap *soap, const char *tag, ns7__Parameters *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__Parameters *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__Parameters, sizeof(ns7__Parameters), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns7__Parameters)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns7__Parameters *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__Parameter(soap, "Parameters", &a->ns7__Parameters::Parameters, "ns1:Parameter"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns7__Parameters *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__Parameters, SOAP_TYPE_ns7__Parameters, sizeof(ns7__Parameters), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns7__Parameters * SOAP_FMAC2 soap_instantiate_ns7__Parameters(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__Parameters(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns7__Parameters *p;
	size_t k = sizeof(ns7__Parameters);
	if (n < 0)
	{	p = SOAP_NEW(ns7__Parameters);
		if (p)
			((ns7__Parameters*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns7__Parameters, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns7__Parameters*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns7__Parameters location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns7__Parameters, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns7__Parameters::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns7__Parameters(soap, tag ? tag : "ns7:Parameters", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns7__Parameters::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__Parameters(soap, this, tag, type);
}

SOAP_FMAC3 ns7__Parameters * SOAP_FMAC4 soap_get_ns7__Parameters(struct soap *soap, ns7__Parameters *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__Parameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns7__JointPos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfdouble(soap, &this->ns7__JointPos::item);
	/* transient soap skipped */
}

void ns7__JointPos::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfdouble(soap, &this->ns7__JointPos::item);
#endif
}

int ns7__JointPos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__JointPos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__JointPos(struct soap *soap, const char *tag, int id, const ns7__JointPos *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__JointPos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfdouble(soap, "item", -1, &a->ns7__JointPos::item, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns7__JointPos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns7__JointPos(soap, tag, this, type);
}

SOAP_FMAC3 ns7__JointPos * SOAP_FMAC4 soap_in_ns7__JointPos(struct soap *soap, const char *tag, ns7__JointPos *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__JointPos *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__JointPos, sizeof(ns7__JointPos), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns7__JointPos)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns7__JointPos *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfdouble(soap, "item", &a->ns7__JointPos::item, "xsd:double"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->ns7__JointPos::item.size() < 1 || a->ns7__JointPos::item.size() > 100))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns7__JointPos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__JointPos, SOAP_TYPE_ns7__JointPos, sizeof(ns7__JointPos), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns7__JointPos * SOAP_FMAC2 soap_instantiate_ns7__JointPos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__JointPos(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns7__JointPos *p;
	size_t k = sizeof(ns7__JointPos);
	if (n < 0)
	{	p = SOAP_NEW(ns7__JointPos);
		if (p)
			((ns7__JointPos*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns7__JointPos, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns7__JointPos*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns7__JointPos location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns7__JointPos, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns7__JointPos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns7__JointPos(soap, tag ? tag : "ns7:JointPos", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns7__JointPos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__JointPos(soap, this, tag, type);
}

SOAP_FMAC3 ns7__JointPos * SOAP_FMAC4 soap_get_ns7__JointPos(struct soap *soap, ns7__JointPos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__JointPos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__SoapDhParametersArray::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons7__SoapDhParameters(soap, &this->ns5__SoapDhParametersArray::DhParameters);
	/* transient soap skipped */
}

void ns5__SoapDhParametersArray::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons7__SoapDhParameters(soap, &this->ns5__SoapDhParametersArray::DhParameters);
#endif
}

int ns5__SoapDhParametersArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__SoapDhParametersArray(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__SoapDhParametersArray(struct soap *soap, const char *tag, int id, const ns5__SoapDhParametersArray *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__SoapDhParametersArray), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons7__SoapDhParameters(soap, "DhParameters", -1, &a->ns5__SoapDhParametersArray::DhParameters, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__SoapDhParametersArray::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__SoapDhParametersArray(soap, tag, this, type);
}

SOAP_FMAC3 ns5__SoapDhParametersArray * SOAP_FMAC4 soap_in_ns5__SoapDhParametersArray(struct soap *soap, const char *tag, ns5__SoapDhParametersArray *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__SoapDhParametersArray *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__SoapDhParametersArray, sizeof(ns5__SoapDhParametersArray), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__SoapDhParametersArray)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__SoapDhParametersArray *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons7__SoapDhParameters(soap, "DhParameters", &a->ns5__SoapDhParametersArray::DhParameters, "ns7:SoapDhParameters"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__SoapDhParametersArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__SoapDhParametersArray, SOAP_TYPE_ns5__SoapDhParametersArray, sizeof(ns5__SoapDhParametersArray), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__SoapDhParametersArray * SOAP_FMAC2 soap_instantiate_ns5__SoapDhParametersArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__SoapDhParametersArray(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__SoapDhParametersArray *p;
	size_t k = sizeof(ns5__SoapDhParametersArray);
	if (n < 0)
	{	p = SOAP_NEW(ns5__SoapDhParametersArray);
		if (p)
			((ns5__SoapDhParametersArray*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__SoapDhParametersArray, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns5__SoapDhParametersArray*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__SoapDhParametersArray location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__SoapDhParametersArray, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__SoapDhParametersArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__SoapDhParametersArray(soap, tag ? tag : "ns5:SoapDhParametersArray", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__SoapDhParametersArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__SoapDhParametersArray(soap, this, tag, type);
}

SOAP_FMAC3 ns5__SoapDhParametersArray * SOAP_FMAC4 soap_get_ns5__SoapDhParametersArray(struct soap *soap, ns5__SoapDhParametersArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__SoapDhParametersArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__SoapPhysicalIoUnlockResponses::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons7__SoapPhysicalIoUnlockResponse(soap, &this->ns5__SoapPhysicalIoUnlockResponses::PhysicalIoResponse);
	/* transient soap skipped */
}

void ns5__SoapPhysicalIoUnlockResponses::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons7__SoapPhysicalIoUnlockResponse(soap, &this->ns5__SoapPhysicalIoUnlockResponses::PhysicalIoResponse);
#endif
}

int ns5__SoapPhysicalIoUnlockResponses::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__SoapPhysicalIoUnlockResponses(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__SoapPhysicalIoUnlockResponses(struct soap *soap, const char *tag, int id, const ns5__SoapPhysicalIoUnlockResponses *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__SoapPhysicalIoUnlockResponses), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons7__SoapPhysicalIoUnlockResponse(soap, "PhysicalIoResponse", -1, &a->ns5__SoapPhysicalIoUnlockResponses::PhysicalIoResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__SoapPhysicalIoUnlockResponses::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__SoapPhysicalIoUnlockResponses(soap, tag, this, type);
}

SOAP_FMAC3 ns5__SoapPhysicalIoUnlockResponses * SOAP_FMAC4 soap_in_ns5__SoapPhysicalIoUnlockResponses(struct soap *soap, const char *tag, ns5__SoapPhysicalIoUnlockResponses *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__SoapPhysicalIoUnlockResponses *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__SoapPhysicalIoUnlockResponses, sizeof(ns5__SoapPhysicalIoUnlockResponses), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__SoapPhysicalIoUnlockResponses)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__SoapPhysicalIoUnlockResponses *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons7__SoapPhysicalIoUnlockResponse(soap, "PhysicalIoResponse", &a->ns5__SoapPhysicalIoUnlockResponses::PhysicalIoResponse, "ns7:SoapPhysicalIoUnlockResponse"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__SoapPhysicalIoUnlockResponses *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__SoapPhysicalIoUnlockResponses, SOAP_TYPE_ns5__SoapPhysicalIoUnlockResponses, sizeof(ns5__SoapPhysicalIoUnlockResponses), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__SoapPhysicalIoUnlockResponses * SOAP_FMAC2 soap_instantiate_ns5__SoapPhysicalIoUnlockResponses(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__SoapPhysicalIoUnlockResponses(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__SoapPhysicalIoUnlockResponses *p;
	size_t k = sizeof(ns5__SoapPhysicalIoUnlockResponses);
	if (n < 0)
	{	p = SOAP_NEW(ns5__SoapPhysicalIoUnlockResponses);
		if (p)
			((ns5__SoapPhysicalIoUnlockResponses*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__SoapPhysicalIoUnlockResponses, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns5__SoapPhysicalIoUnlockResponses*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__SoapPhysicalIoUnlockResponses location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__SoapPhysicalIoUnlockResponses, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__SoapPhysicalIoUnlockResponses::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__SoapPhysicalIoUnlockResponses(soap, tag ? tag : "ns5:SoapPhysicalIoUnlockResponses", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__SoapPhysicalIoUnlockResponses::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__SoapPhysicalIoUnlockResponses(soap, this, tag, type);
}

SOAP_FMAC3 ns5__SoapPhysicalIoUnlockResponses * SOAP_FMAC4 soap_get_ns5__SoapPhysicalIoUnlockResponses(struct soap *soap, ns5__SoapPhysicalIoUnlockResponses *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__SoapPhysicalIoUnlockResponses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__SoapPhysicalIoResponses::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons7__SoapPhysicalIoResponse(soap, &this->ns5__SoapPhysicalIoResponses::PhysicalIoResponse);
	/* transient soap skipped */
}

void ns5__SoapPhysicalIoResponses::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons7__SoapPhysicalIoResponse(soap, &this->ns5__SoapPhysicalIoResponses::PhysicalIoResponse);
#endif
}

int ns5__SoapPhysicalIoResponses::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__SoapPhysicalIoResponses(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__SoapPhysicalIoResponses(struct soap *soap, const char *tag, int id, const ns5__SoapPhysicalIoResponses *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__SoapPhysicalIoResponses), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons7__SoapPhysicalIoResponse(soap, "PhysicalIoResponse", -1, &a->ns5__SoapPhysicalIoResponses::PhysicalIoResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__SoapPhysicalIoResponses::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__SoapPhysicalIoResponses(soap, tag, this, type);
}

SOAP_FMAC3 ns5__SoapPhysicalIoResponses * SOAP_FMAC4 soap_in_ns5__SoapPhysicalIoResponses(struct soap *soap, const char *tag, ns5__SoapPhysicalIoResponses *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__SoapPhysicalIoResponses *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__SoapPhysicalIoResponses, sizeof(ns5__SoapPhysicalIoResponses), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__SoapPhysicalIoResponses)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__SoapPhysicalIoResponses *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons7__SoapPhysicalIoResponse(soap, "PhysicalIoResponse", &a->ns5__SoapPhysicalIoResponses::PhysicalIoResponse, "ns7:SoapPhysicalIoResponse"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__SoapPhysicalIoResponses *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__SoapPhysicalIoResponses, SOAP_TYPE_ns5__SoapPhysicalIoResponses, sizeof(ns5__SoapPhysicalIoResponses), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__SoapPhysicalIoResponses * SOAP_FMAC2 soap_instantiate_ns5__SoapPhysicalIoResponses(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__SoapPhysicalIoResponses(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__SoapPhysicalIoResponses *p;
	size_t k = sizeof(ns5__SoapPhysicalIoResponses);
	if (n < 0)
	{	p = SOAP_NEW(ns5__SoapPhysicalIoResponses);
		if (p)
			((ns5__SoapPhysicalIoResponses*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__SoapPhysicalIoResponses, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns5__SoapPhysicalIoResponses*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__SoapPhysicalIoResponses location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__SoapPhysicalIoResponses, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__SoapPhysicalIoResponses::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__SoapPhysicalIoResponses(soap, tag ? tag : "ns5:SoapPhysicalIoResponses", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__SoapPhysicalIoResponses::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__SoapPhysicalIoResponses(soap, this, tag, type);
}

SOAP_FMAC3 ns5__SoapPhysicalIoResponses * SOAP_FMAC4 soap_get_ns5__SoapPhysicalIoResponses(struct soap *soap, ns5__SoapPhysicalIoResponses *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__SoapPhysicalIoResponses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__SoapPhysicalIosStates::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons7__SoapPhysicalIoState(soap, &this->ns5__SoapPhysicalIosStates::PhysicalIoState);
	/* transient soap skipped */
}

void ns5__SoapPhysicalIosStates::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons7__SoapPhysicalIoState(soap, &this->ns5__SoapPhysicalIosStates::PhysicalIoState);
#endif
}

int ns5__SoapPhysicalIosStates::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__SoapPhysicalIosStates(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__SoapPhysicalIosStates(struct soap *soap, const char *tag, int id, const ns5__SoapPhysicalIosStates *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__SoapPhysicalIosStates), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons7__SoapPhysicalIoState(soap, "PhysicalIoState", -1, &a->ns5__SoapPhysicalIosStates::PhysicalIoState, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__SoapPhysicalIosStates::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__SoapPhysicalIosStates(soap, tag, this, type);
}

SOAP_FMAC3 ns5__SoapPhysicalIosStates * SOAP_FMAC4 soap_in_ns5__SoapPhysicalIosStates(struct soap *soap, const char *tag, ns5__SoapPhysicalIosStates *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__SoapPhysicalIosStates *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__SoapPhysicalIosStates, sizeof(ns5__SoapPhysicalIosStates), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__SoapPhysicalIosStates)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__SoapPhysicalIosStates *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons7__SoapPhysicalIoState(soap, "PhysicalIoState", &a->ns5__SoapPhysicalIosStates::PhysicalIoState, "ns7:SoapPhysicalIoState"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__SoapPhysicalIosStates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__SoapPhysicalIosStates, SOAP_TYPE_ns5__SoapPhysicalIosStates, sizeof(ns5__SoapPhysicalIosStates), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__SoapPhysicalIosStates * SOAP_FMAC2 soap_instantiate_ns5__SoapPhysicalIosStates(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__SoapPhysicalIosStates(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__SoapPhysicalIosStates *p;
	size_t k = sizeof(ns5__SoapPhysicalIosStates);
	if (n < 0)
	{	p = SOAP_NEW(ns5__SoapPhysicalIosStates);
		if (p)
			((ns5__SoapPhysicalIosStates*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__SoapPhysicalIosStates, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns5__SoapPhysicalIosStates*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__SoapPhysicalIosStates location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__SoapPhysicalIosStates, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__SoapPhysicalIosStates::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__SoapPhysicalIosStates(soap, tag ? tag : "ns5:SoapPhysicalIosStates", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__SoapPhysicalIosStates::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__SoapPhysicalIosStates(soap, this, tag, type);
}

SOAP_FMAC3 ns5__SoapPhysicalIosStates * SOAP_FMAC4 soap_get_ns5__SoapPhysicalIosStates(struct soap *soap, ns5__SoapPhysicalIosStates *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__SoapPhysicalIosStates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__SoapPhysicalIoValues::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfdouble(soap, &this->ns5__SoapPhysicalIoValues::PhysicalIoValue);
	/* transient soap skipped */
}

void ns5__SoapPhysicalIoValues::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfdouble(soap, &this->ns5__SoapPhysicalIoValues::PhysicalIoValue);
#endif
}

int ns5__SoapPhysicalIoValues::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__SoapPhysicalIoValues(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__SoapPhysicalIoValues(struct soap *soap, const char *tag, int id, const ns5__SoapPhysicalIoValues *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__SoapPhysicalIoValues), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfdouble(soap, "PhysicalIoValue", -1, &a->ns5__SoapPhysicalIoValues::PhysicalIoValue, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__SoapPhysicalIoValues::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__SoapPhysicalIoValues(soap, tag, this, type);
}

SOAP_FMAC3 ns5__SoapPhysicalIoValues * SOAP_FMAC4 soap_in_ns5__SoapPhysicalIoValues(struct soap *soap, const char *tag, ns5__SoapPhysicalIoValues *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__SoapPhysicalIoValues *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__SoapPhysicalIoValues, sizeof(ns5__SoapPhysicalIoValues), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__SoapPhysicalIoValues)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__SoapPhysicalIoValues *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfdouble(soap, "PhysicalIoValue", &a->ns5__SoapPhysicalIoValues::PhysicalIoValue, "xsd:double"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__SoapPhysicalIoValues *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__SoapPhysicalIoValues, SOAP_TYPE_ns5__SoapPhysicalIoValues, sizeof(ns5__SoapPhysicalIoValues), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__SoapPhysicalIoValues * SOAP_FMAC2 soap_instantiate_ns5__SoapPhysicalIoValues(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__SoapPhysicalIoValues(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__SoapPhysicalIoValues *p;
	size_t k = sizeof(ns5__SoapPhysicalIoValues);
	if (n < 0)
	{	p = SOAP_NEW(ns5__SoapPhysicalIoValues);
		if (p)
			((ns5__SoapPhysicalIoValues*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__SoapPhysicalIoValues, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns5__SoapPhysicalIoValues*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__SoapPhysicalIoValues location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__SoapPhysicalIoValues, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__SoapPhysicalIoValues::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__SoapPhysicalIoValues(soap, tag ? tag : "ns5:SoapPhysicalIoValues", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__SoapPhysicalIoValues::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__SoapPhysicalIoValues(soap, this, tag, type);
}

SOAP_FMAC3 ns5__SoapPhysicalIoValues * SOAP_FMAC4 soap_get_ns5__SoapPhysicalIoValues(struct soap *soap, ns5__SoapPhysicalIoValues *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__SoapPhysicalIoValues(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__SoapPhysicalIoLinks::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns5__SoapPhysicalIoLinks::PhysicalPath);
	/* transient soap skipped */
}

void ns5__SoapPhysicalIoLinks::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns5__SoapPhysicalIoLinks::PhysicalPath);
#endif
}

int ns5__SoapPhysicalIoLinks::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__SoapPhysicalIoLinks(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__SoapPhysicalIoLinks(struct soap *soap, const char *tag, int id, const ns5__SoapPhysicalIoLinks *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__SoapPhysicalIoLinks), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "PhysicalPath", -1, &a->ns5__SoapPhysicalIoLinks::PhysicalPath, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__SoapPhysicalIoLinks::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__SoapPhysicalIoLinks(soap, tag, this, type);
}

SOAP_FMAC3 ns5__SoapPhysicalIoLinks * SOAP_FMAC4 soap_in_ns5__SoapPhysicalIoLinks(struct soap *soap, const char *tag, ns5__SoapPhysicalIoLinks *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__SoapPhysicalIoLinks *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__SoapPhysicalIoLinks, sizeof(ns5__SoapPhysicalIoLinks), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__SoapPhysicalIoLinks)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__SoapPhysicalIoLinks *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfstd__string(soap, "PhysicalPath", &a->ns5__SoapPhysicalIoLinks::PhysicalPath, "xsd:string"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__SoapPhysicalIoLinks *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__SoapPhysicalIoLinks, SOAP_TYPE_ns5__SoapPhysicalIoLinks, sizeof(ns5__SoapPhysicalIoLinks), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__SoapPhysicalIoLinks * SOAP_FMAC2 soap_instantiate_ns5__SoapPhysicalIoLinks(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__SoapPhysicalIoLinks(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__SoapPhysicalIoLinks *p;
	size_t k = sizeof(ns5__SoapPhysicalIoLinks);
	if (n < 0)
	{	p = SOAP_NEW(ns5__SoapPhysicalIoLinks);
		if (p)
			((ns5__SoapPhysicalIoLinks*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__SoapPhysicalIoLinks, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns5__SoapPhysicalIoLinks*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__SoapPhysicalIoLinks location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__SoapPhysicalIoLinks, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__SoapPhysicalIoLinks::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__SoapPhysicalIoLinks(soap, tag ? tag : "ns5:SoapPhysicalIoLinks", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__SoapPhysicalIoLinks::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__SoapPhysicalIoLinks(soap, this, tag, type);
}

SOAP_FMAC3 ns5__SoapPhysicalIoLinks * SOAP_FMAC4 soap_get_ns5__SoapPhysicalIoLinks(struct soap *soap, ns5__SoapPhysicalIoLinks *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__SoapPhysicalIoLinks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__SoapWatches::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons7__SoapData(soap, &this->ns5__SoapWatches::SoapData);
	/* transient soap skipped */
}

void ns5__SoapWatches::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons7__SoapData(soap, &this->ns5__SoapWatches::SoapData);
#endif
}

int ns5__SoapWatches::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__SoapWatches(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__SoapWatches(struct soap *soap, const char *tag, int id, const ns5__SoapWatches *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__SoapWatches), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons7__SoapData(soap, "SoapData", -1, &a->ns5__SoapWatches::SoapData, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__SoapWatches::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__SoapWatches(soap, tag, this, type);
}

SOAP_FMAC3 ns5__SoapWatches * SOAP_FMAC4 soap_in_ns5__SoapWatches(struct soap *soap, const char *tag, ns5__SoapWatches *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__SoapWatches *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__SoapWatches, sizeof(ns5__SoapWatches), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__SoapWatches)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__SoapWatches *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons7__SoapData(soap, "SoapData", &a->ns5__SoapWatches::SoapData, "ns7:SoapData"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__SoapWatches *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__SoapWatches, SOAP_TYPE_ns5__SoapWatches, sizeof(ns5__SoapWatches), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__SoapWatches * SOAP_FMAC2 soap_instantiate_ns5__SoapWatches(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__SoapWatches(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__SoapWatches *p;
	size_t k = sizeof(ns5__SoapWatches);
	if (n < 0)
	{	p = SOAP_NEW(ns5__SoapWatches);
		if (p)
			((ns5__SoapWatches*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__SoapWatches, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns5__SoapWatches*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__SoapWatches location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__SoapWatches, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__SoapWatches::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__SoapWatches(soap, tag ? tag : "ns5:SoapWatches", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__SoapWatches::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__SoapWatches(soap, this, tag, type);
}

SOAP_FMAC3 ns5__SoapWatches * SOAP_FMAC4 soap_get_ns5__SoapWatches(struct soap *soap, ns5__SoapWatches *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__SoapWatches(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__SoapCallStack::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons7__SoapStackFrameAbstract(soap, &this->ns5__SoapCallStack::SfAbstract);
	/* transient soap skipped */
}

void ns5__SoapCallStack::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons7__SoapStackFrameAbstract(soap, &this->ns5__SoapCallStack::SfAbstract);
#endif
}

int ns5__SoapCallStack::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__SoapCallStack(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__SoapCallStack(struct soap *soap, const char *tag, int id, const ns5__SoapCallStack *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__SoapCallStack), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons7__SoapStackFrameAbstract(soap, "SfAbstract", -1, &a->ns5__SoapCallStack::SfAbstract, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__SoapCallStack::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__SoapCallStack(soap, tag, this, type);
}

SOAP_FMAC3 ns5__SoapCallStack * SOAP_FMAC4 soap_in_ns5__SoapCallStack(struct soap *soap, const char *tag, ns5__SoapCallStack *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__SoapCallStack *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__SoapCallStack, sizeof(ns5__SoapCallStack), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__SoapCallStack)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__SoapCallStack *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons7__SoapStackFrameAbstract(soap, "SfAbstract", &a->ns5__SoapCallStack::SfAbstract, "ns7:SoapStackFrameAbstract"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__SoapCallStack *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__SoapCallStack, SOAP_TYPE_ns5__SoapCallStack, sizeof(ns5__SoapCallStack), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__SoapCallStack * SOAP_FMAC2 soap_instantiate_ns5__SoapCallStack(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__SoapCallStack(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__SoapCallStack *p;
	size_t k = sizeof(ns5__SoapCallStack);
	if (n < 0)
	{	p = SOAP_NEW(ns5__SoapCallStack);
		if (p)
			((ns5__SoapCallStack*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__SoapCallStack, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns5__SoapCallStack*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__SoapCallStack location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__SoapCallStack, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__SoapCallStack::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__SoapCallStack(soap, tag ? tag : "ns5:SoapCallStack", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__SoapCallStack::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__SoapCallStack(soap, this, tag, type);
}

SOAP_FMAC3 ns5__SoapCallStack * SOAP_FMAC4 soap_get_ns5__SoapCallStack(struct soap *soap, ns5__SoapCallStack *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__SoapCallStack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__SoapTasks::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons7__SoapTask(soap, &this->ns5__SoapTasks::Task);
	/* transient soap skipped */
}

void ns5__SoapTasks::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons7__SoapTask(soap, &this->ns5__SoapTasks::Task);
#endif
}

int ns5__SoapTasks::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__SoapTasks(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__SoapTasks(struct soap *soap, const char *tag, int id, const ns5__SoapTasks *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__SoapTasks), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons7__SoapTask(soap, "Task", -1, &a->ns5__SoapTasks::Task, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__SoapTasks::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__SoapTasks(soap, tag, this, type);
}

SOAP_FMAC3 ns5__SoapTasks * SOAP_FMAC4 soap_in_ns5__SoapTasks(struct soap *soap, const char *tag, ns5__SoapTasks *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__SoapTasks *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__SoapTasks, sizeof(ns5__SoapTasks), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__SoapTasks)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__SoapTasks *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons7__SoapTask(soap, "Task", &a->ns5__SoapTasks::Task, "ns7:SoapTask"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__SoapTasks *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__SoapTasks, SOAP_TYPE_ns5__SoapTasks, sizeof(ns5__SoapTasks), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__SoapTasks * SOAP_FMAC2 soap_instantiate_ns5__SoapTasks(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__SoapTasks(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__SoapTasks *p;
	size_t k = sizeof(ns5__SoapTasks);
	if (n < 0)
	{	p = SOAP_NEW(ns5__SoapTasks);
		if (p)
			((ns5__SoapTasks*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__SoapTasks, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns5__SoapTasks*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__SoapTasks location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__SoapTasks, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__SoapTasks::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__SoapTasks(soap, tag ? tag : "ns5:SoapTasks", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__SoapTasks::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__SoapTasks(soap, this, tag, type);
}

SOAP_FMAC3 ns5__SoapTasks * SOAP_FMAC4 soap_get_ns5__SoapTasks(struct soap *soap, ns5__SoapTasks *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__SoapTasks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__BreakpointsResponses::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons7__BreakpointsResponse(soap, &this->ns5__BreakpointsResponses::BreakpointResponse);
	/* transient soap skipped */
}

void ns5__BreakpointsResponses::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons7__BreakpointsResponse(soap, &this->ns5__BreakpointsResponses::BreakpointResponse);
#endif
}

int ns5__BreakpointsResponses::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__BreakpointsResponses(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__BreakpointsResponses(struct soap *soap, const char *tag, int id, const ns5__BreakpointsResponses *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__BreakpointsResponses), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons7__BreakpointsResponse(soap, "BreakpointResponse", -1, &a->ns5__BreakpointsResponses::BreakpointResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__BreakpointsResponses::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__BreakpointsResponses(soap, tag, this, type);
}

SOAP_FMAC3 ns5__BreakpointsResponses * SOAP_FMAC4 soap_in_ns5__BreakpointsResponses(struct soap *soap, const char *tag, ns5__BreakpointsResponses *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__BreakpointsResponses *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__BreakpointsResponses, sizeof(ns5__BreakpointsResponses), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__BreakpointsResponses)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__BreakpointsResponses *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons7__BreakpointsResponse(soap, "BreakpointResponse", &a->ns5__BreakpointsResponses::BreakpointResponse, "ns7:BreakpointsResponse"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__BreakpointsResponses *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__BreakpointsResponses, SOAP_TYPE_ns5__BreakpointsResponses, sizeof(ns5__BreakpointsResponses), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__BreakpointsResponses * SOAP_FMAC2 soap_instantiate_ns5__BreakpointsResponses(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__BreakpointsResponses(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__BreakpointsResponses *p;
	size_t k = sizeof(ns5__BreakpointsResponses);
	if (n < 0)
	{	p = SOAP_NEW(ns5__BreakpointsResponses);
		if (p)
			((ns5__BreakpointsResponses*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__BreakpointsResponses, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns5__BreakpointsResponses*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__BreakpointsResponses location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__BreakpointsResponses, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__BreakpointsResponses::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__BreakpointsResponses(soap, tag ? tag : "ns5:BreakpointsResponses", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__BreakpointsResponses::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__BreakpointsResponses(soap, this, tag, type);
}

SOAP_FMAC3 ns5__BreakpointsResponses * SOAP_FMAC4 soap_get_ns5__BreakpointsResponses(struct soap *soap, ns5__BreakpointsResponses *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__BreakpointsResponses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__SoapBreakpoints::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons7__SoapBreakpoint(soap, &this->ns5__SoapBreakpoints::BreakPoint);
	/* transient soap skipped */
}

void ns5__SoapBreakpoints::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons7__SoapBreakpoint(soap, &this->ns5__SoapBreakpoints::BreakPoint);
#endif
}

int ns5__SoapBreakpoints::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__SoapBreakpoints(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__SoapBreakpoints(struct soap *soap, const char *tag, int id, const ns5__SoapBreakpoints *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__SoapBreakpoints), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons7__SoapBreakpoint(soap, "BreakPoint", -1, &a->ns5__SoapBreakpoints::BreakPoint, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__SoapBreakpoints::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__SoapBreakpoints(soap, tag, this, type);
}

SOAP_FMAC3 ns5__SoapBreakpoints * SOAP_FMAC4 soap_in_ns5__SoapBreakpoints(struct soap *soap, const char *tag, ns5__SoapBreakpoints *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__SoapBreakpoints *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__SoapBreakpoints, sizeof(ns5__SoapBreakpoints), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__SoapBreakpoints)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__SoapBreakpoints *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons7__SoapBreakpoint(soap, "BreakPoint", &a->ns5__SoapBreakpoints::BreakPoint, "ns7:SoapBreakpoint"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__SoapBreakpoints *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__SoapBreakpoints, SOAP_TYPE_ns5__SoapBreakpoints, sizeof(ns5__SoapBreakpoints), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__SoapBreakpoints * SOAP_FMAC2 soap_instantiate_ns5__SoapBreakpoints(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__SoapBreakpoints(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__SoapBreakpoints *p;
	size_t k = sizeof(ns5__SoapBreakpoints);
	if (n < 0)
	{	p = SOAP_NEW(ns5__SoapBreakpoints);
		if (p)
			((ns5__SoapBreakpoints*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__SoapBreakpoints, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns5__SoapBreakpoints*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__SoapBreakpoints location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__SoapBreakpoints, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__SoapBreakpoints::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__SoapBreakpoints(soap, tag ? tag : "ns5:SoapBreakpoints", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__SoapBreakpoints::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__SoapBreakpoints(soap, this, tag, type);
}

SOAP_FMAC3 ns5__SoapBreakpoints * SOAP_FMAC4 soap_get_ns5__SoapBreakpoints(struct soap *soap, ns5__SoapBreakpoints *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__SoapBreakpoints(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__Records::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns5__Records::record);
	/* transient soap skipped */
}

void ns5__Records::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns5__Records::record);
#endif
}

int ns5__Records::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__Records(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__Records(struct soap *soap, const char *tag, int id, const ns5__Records *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__Records), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "record", -1, &a->ns5__Records::record, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__Records::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__Records(soap, tag, this, type);
}

SOAP_FMAC3 ns5__Records * SOAP_FMAC4 soap_in_ns5__Records(struct soap *soap, const char *tag, ns5__Records *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__Records *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__Records, sizeof(ns5__Records), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__Records)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__Records *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfstd__string(soap, "record", &a->ns5__Records::record, "xsd:string"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__Records *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__Records, SOAP_TYPE_ns5__Records, sizeof(ns5__Records), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__Records * SOAP_FMAC2 soap_instantiate_ns5__Records(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__Records(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__Records *p;
	size_t k = sizeof(ns5__Records);
	if (n < 0)
	{	p = SOAP_NEW(ns5__Records);
		if (p)
			((ns5__Records*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__Records, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns5__Records*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__Records location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__Records, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__Records::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__Records(soap, tag ? tag : "ns5:Records", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__Records::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__Records(soap, this, tag, type);
}

SOAP_FMAC3 ns5__Records * SOAP_FMAC4 soap_get_ns5__Records(struct soap *soap, ns5__Records *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__Records(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__VALApplications::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__VALApplication(soap, &this->ns5__VALApplications::application);
	/* transient soap skipped */
}

void ns5__VALApplications::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons2__VALApplication(soap, &this->ns5__VALApplications::application);
#endif
}

int ns5__VALApplications::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__VALApplications(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__VALApplications(struct soap *soap, const char *tag, int id, const ns5__VALApplications *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__VALApplications), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__VALApplication(soap, "application", -1, &a->ns5__VALApplications::application, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__VALApplications::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__VALApplications(soap, tag, this, type);
}

SOAP_FMAC3 ns5__VALApplications * SOAP_FMAC4 soap_in_ns5__VALApplications(struct soap *soap, const char *tag, ns5__VALApplications *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__VALApplications *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__VALApplications, sizeof(ns5__VALApplications), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__VALApplications)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__VALApplications *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons2__VALApplication(soap, "application", &a->ns5__VALApplications::application, "ns2:VALApplication"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__VALApplications *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__VALApplications, SOAP_TYPE_ns5__VALApplications, sizeof(ns5__VALApplications), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__VALApplications * SOAP_FMAC2 soap_instantiate_ns5__VALApplications(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__VALApplications(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__VALApplications *p;
	size_t k = sizeof(ns5__VALApplications);
	if (n < 0)
	{	p = SOAP_NEW(ns5__VALApplications);
		if (p)
			((ns5__VALApplications*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__VALApplications, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns5__VALApplications*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__VALApplications location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__VALApplications, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__VALApplications::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__VALApplications(soap, tag ? tag : "ns5:VALApplications", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__VALApplications::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__VALApplications(soap, this, tag, type);
}

SOAP_FMAC3 ns5__VALApplications * SOAP_FMAC4 soap_get_ns5__VALApplications(struct soap *soap, ns5__VALApplications *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__VALApplications(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__Robots::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__Robot(soap, &this->ns5__Robots::Robots);
	/* transient soap skipped */
}

void ns5__Robots::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__Robot(soap, &this->ns5__Robots::Robots);
#endif
}

int ns5__Robots::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__Robots(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__Robots(struct soap *soap, const char *tag, int id, const ns5__Robots *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__Robots), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__Robot(soap, "Robots", -1, &a->ns5__Robots::Robots, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__Robots::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__Robots(soap, tag, this, type);
}

SOAP_FMAC3 ns5__Robots * SOAP_FMAC4 soap_in_ns5__Robots(struct soap *soap, const char *tag, ns5__Robots *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__Robots *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__Robots, sizeof(ns5__Robots), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__Robots)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__Robots *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__Robot(soap, "Robots", &a->ns5__Robots::Robots, "ns1:Robot"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__Robots *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__Robots, SOAP_TYPE_ns5__Robots, sizeof(ns5__Robots), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__Robots * SOAP_FMAC2 soap_instantiate_ns5__Robots(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__Robots(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__Robots *p;
	size_t k = sizeof(ns5__Robots);
	if (n < 0)
	{	p = SOAP_NEW(ns5__Robots);
		if (p)
			((ns5__Robots*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__Robots, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns5__Robots*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__Robots location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__Robots, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__Robots::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__Robots(soap, tag ? tag : "ns5:Robots", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__Robots::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__Robots(soap, this, tag, type);
}

SOAP_FMAC3 ns5__Robots * SOAP_FMAC4 soap_get_ns5__Robots(struct soap *soap, ns5__Robots *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__Robots(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__Versions::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__Version(soap, &this->ns5__Versions::Versions);
	/* transient soap skipped */
}

void ns5__Versions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__Version(soap, &this->ns5__Versions::Versions);
#endif
}

int ns5__Versions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__Versions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__Versions(struct soap *soap, const char *tag, int id, const ns5__Versions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__Versions), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__Version(soap, "Versions", -1, &a->ns5__Versions::Versions, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__Versions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__Versions(soap, tag, this, type);
}

SOAP_FMAC3 ns5__Versions * SOAP_FMAC4 soap_in_ns5__Versions(struct soap *soap, const char *tag, ns5__Versions *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__Versions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__Versions, sizeof(ns5__Versions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__Versions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__Versions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__Version(soap, "Versions", &a->ns5__Versions::Versions, "ns1:Version"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__Versions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__Versions, SOAP_TYPE_ns5__Versions, sizeof(ns5__Versions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__Versions * SOAP_FMAC2 soap_instantiate_ns5__Versions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__Versions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__Versions *p;
	size_t k = sizeof(ns5__Versions);
	if (n < 0)
	{	p = SOAP_NEW(ns5__Versions);
		if (p)
			((ns5__Versions*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__Versions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns5__Versions*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__Versions location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__Versions, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__Versions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__Versions(soap, tag ? tag : "ns5:Versions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__Versions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__Versions(soap, this, tag, type);
}

SOAP_FMAC3 ns5__Versions * SOAP_FMAC4 soap_get_ns5__Versions(struct soap *soap, ns5__Versions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__Versions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__Parameters::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__Parameter(soap, &this->ns5__Parameters::Parameters);
	/* transient soap skipped */
}

void ns5__Parameters::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__Parameter(soap, &this->ns5__Parameters::Parameters);
#endif
}

int ns5__Parameters::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__Parameters(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__Parameters(struct soap *soap, const char *tag, int id, const ns5__Parameters *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__Parameters), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__Parameter(soap, "Parameters", -1, &a->ns5__Parameters::Parameters, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__Parameters::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__Parameters(soap, tag, this, type);
}

SOAP_FMAC3 ns5__Parameters * SOAP_FMAC4 soap_in_ns5__Parameters(struct soap *soap, const char *tag, ns5__Parameters *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__Parameters *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__Parameters, sizeof(ns5__Parameters), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__Parameters)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__Parameters *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__Parameter(soap, "Parameters", &a->ns5__Parameters::Parameters, "ns1:Parameter"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__Parameters *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__Parameters, SOAP_TYPE_ns5__Parameters, sizeof(ns5__Parameters), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__Parameters * SOAP_FMAC2 soap_instantiate_ns5__Parameters(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__Parameters(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__Parameters *p;
	size_t k = sizeof(ns5__Parameters);
	if (n < 0)
	{	p = SOAP_NEW(ns5__Parameters);
		if (p)
			((ns5__Parameters*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__Parameters, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns5__Parameters*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__Parameters location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__Parameters, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__Parameters::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__Parameters(soap, tag ? tag : "ns5:Parameters", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__Parameters::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__Parameters(soap, this, tag, type);
}

SOAP_FMAC3 ns5__Parameters * SOAP_FMAC4 soap_get_ns5__Parameters(struct soap *soap, ns5__Parameters *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__Parameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns5__JointPos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfdouble(soap, &this->ns5__JointPos::item);
	/* transient soap skipped */
}

void ns5__JointPos::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfdouble(soap, &this->ns5__JointPos::item);
#endif
}

int ns5__JointPos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__JointPos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__JointPos(struct soap *soap, const char *tag, int id, const ns5__JointPos *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__JointPos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfdouble(soap, "item", -1, &a->ns5__JointPos::item, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__JointPos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__JointPos(soap, tag, this, type);
}

SOAP_FMAC3 ns5__JointPos * SOAP_FMAC4 soap_in_ns5__JointPos(struct soap *soap, const char *tag, ns5__JointPos *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__JointPos *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__JointPos, sizeof(ns5__JointPos), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns5__JointPos)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns5__JointPos *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfdouble(soap, "item", &a->ns5__JointPos::item, "xsd:double"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->ns5__JointPos::item.size() < 1 || a->ns5__JointPos::item.size() > 100))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns5__JointPos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__JointPos, SOAP_TYPE_ns5__JointPos, sizeof(ns5__JointPos), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns5__JointPos * SOAP_FMAC2 soap_instantiate_ns5__JointPos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__JointPos(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns5__JointPos *p;
	size_t k = sizeof(ns5__JointPos);
	if (n < 0)
	{	p = SOAP_NEW(ns5__JointPos);
		if (p)
			((ns5__JointPos*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns5__JointPos, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns5__JointPos*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns5__JointPos location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns5__JointPos, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns5__JointPos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns5__JointPos(soap, tag ? tag : "ns5:JointPos", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__JointPos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__JointPos(soap, this, tag, type);
}

SOAP_FMAC3 ns5__JointPos * SOAP_FMAC4 soap_get_ns5__JointPos(struct soap *soap, ns5__JointPos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__JointPos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__setRobotPosResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__setRobotPosResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__setRobotPosResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__setRobotPosResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setRobotPosResponse(struct soap *soap, const char *tag, int id, const _ns1__setRobotPosResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setRobotPosResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__setRobotPosResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__setRobotPosResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__setRobotPosResponse * SOAP_FMAC4 soap_in__ns1__setRobotPosResponse(struct soap *soap, const char *tag, _ns1__setRobotPosResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__setRobotPosResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setRobotPosResponse, sizeof(_ns1__setRobotPosResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__setRobotPosResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__setRobotPosResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__setRobotPosResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setRobotPosResponse, SOAP_TYPE__ns1__setRobotPosResponse, sizeof(_ns1__setRobotPosResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__setRobotPosResponse * SOAP_FMAC2 soap_instantiate__ns1__setRobotPosResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__setRobotPosResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__setRobotPosResponse *p;
	size_t k = sizeof(_ns1__setRobotPosResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__setRobotPosResponse);
		if (p)
			((_ns1__setRobotPosResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__setRobotPosResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__setRobotPosResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__setRobotPosResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__setRobotPosResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__setRobotPosResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__setRobotPosResponse(soap, tag ? tag : "ns1:setRobotPosResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__setRobotPosResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__setRobotPosResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__setRobotPosResponse * SOAP_FMAC4 soap_get__ns1__setRobotPosResponse(struct soap *soap, _ns1__setRobotPosResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setRobotPosResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__setRobotJointPos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__setRobotJointPos::robot);
	this->_ns1__setRobotJointPos::pos = NULL;
	/* transient soap skipped */
}

void _ns1__setRobotJointPos::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__JointPos(soap, &this->_ns1__setRobotJointPos::pos);
#endif
}

int _ns1__setRobotJointPos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__setRobotJointPos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setRobotJointPos(struct soap *soap, const char *tag, int id, const _ns1__setRobotJointPos *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setRobotJointPos), type))
		return soap->error;
	if (soap_out_int(soap, "robot", -1, &a->_ns1__setRobotJointPos::robot, ""))
		return soap->error;
	if (!a->_ns1__setRobotJointPos::pos)
	{	if (soap_element_empty(soap, "pos"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__JointPos(soap, "pos", -1, &a->_ns1__setRobotJointPos::pos, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__setRobotJointPos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__setRobotJointPos(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__setRobotJointPos * SOAP_FMAC4 soap_in__ns1__setRobotJointPos(struct soap *soap, const char *tag, _ns1__setRobotJointPos *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__setRobotJointPos *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setRobotJointPos, sizeof(_ns1__setRobotJointPos), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__setRobotJointPos)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__setRobotJointPos *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_robot1 = 1;
	size_t soap_flag_pos1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_robot1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "robot", &a->_ns1__setRobotJointPos::robot, "xsd:int"))
				{	soap_flag_robot1--;
					continue;
				}
			}
			if (soap_flag_pos1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__JointPos(soap, "pos", &a->_ns1__setRobotJointPos::pos, "ns1:JointPos"))
				{	soap_flag_pos1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_robot1 > 0 || !a->_ns1__setRobotJointPos::pos))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__setRobotJointPos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setRobotJointPos, SOAP_TYPE__ns1__setRobotJointPos, sizeof(_ns1__setRobotJointPos), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__setRobotJointPos * SOAP_FMAC2 soap_instantiate__ns1__setRobotJointPos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__setRobotJointPos(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__setRobotJointPos *p;
	size_t k = sizeof(_ns1__setRobotJointPos);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__setRobotJointPos);
		if (p)
			((_ns1__setRobotJointPos*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__setRobotJointPos, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__setRobotJointPos*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__setRobotJointPos location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__setRobotJointPos, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__setRobotJointPos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__setRobotJointPos(soap, tag ? tag : "ns1:setRobotJointPos", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__setRobotJointPos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__setRobotJointPos(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__setRobotJointPos * SOAP_FMAC4 soap_get__ns1__setRobotJointPos(struct soap *soap, _ns1__setRobotJointPos *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setRobotJointPos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__getRobotJntCartPosResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getRobotJntCartPosResponse::jntPos = NULL;
	this->_ns1__getRobotJntCartPosResponse::cartPos = NULL;
	/* transient soap skipped */
}

void _ns1__getRobotJntCartPosResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__JointPos(soap, &this->_ns1__getRobotJntCartPosResponse::jntPos);
	soap_serialize_PointerTons1__CartesianPos(soap, &this->_ns1__getRobotJntCartPosResponse::cartPos);
#endif
}

int _ns1__getRobotJntCartPosResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getRobotJntCartPosResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getRobotJntCartPosResponse(struct soap *soap, const char *tag, int id, const _ns1__getRobotJntCartPosResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getRobotJntCartPosResponse), type))
		return soap->error;
	if (!a->_ns1__getRobotJntCartPosResponse::jntPos)
	{	if (soap_element_empty(soap, "jntPos"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__JointPos(soap, "jntPos", -1, &a->_ns1__getRobotJntCartPosResponse::jntPos, ""))
		return soap->error;
	if (!a->_ns1__getRobotJntCartPosResponse::cartPos)
	{	if (soap_element_empty(soap, "cartPos"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__CartesianPos(soap, "cartPos", -1, &a->_ns1__getRobotJntCartPosResponse::cartPos, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__getRobotJntCartPosResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getRobotJntCartPosResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getRobotJntCartPosResponse * SOAP_FMAC4 soap_in__ns1__getRobotJntCartPosResponse(struct soap *soap, const char *tag, _ns1__getRobotJntCartPosResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getRobotJntCartPosResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getRobotJntCartPosResponse, sizeof(_ns1__getRobotJntCartPosResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__getRobotJntCartPosResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__getRobotJntCartPosResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_jntPos1 = 1;
	size_t soap_flag_cartPos1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jntPos1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__JointPos(soap, "jntPos", &a->_ns1__getRobotJntCartPosResponse::jntPos, "ns1:JointPos"))
				{	soap_flag_jntPos1--;
					continue;
				}
			}
			if (soap_flag_cartPos1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__CartesianPos(soap, "cartPos", &a->_ns1__getRobotJntCartPosResponse::cartPos, "ns1:CartesianPos"))
				{	soap_flag_cartPos1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns1__getRobotJntCartPosResponse::jntPos || !a->_ns1__getRobotJntCartPosResponse::cartPos))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__getRobotJntCartPosResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getRobotJntCartPosResponse, SOAP_TYPE__ns1__getRobotJntCartPosResponse, sizeof(_ns1__getRobotJntCartPosResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__getRobotJntCartPosResponse * SOAP_FMAC2 soap_instantiate__ns1__getRobotJntCartPosResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getRobotJntCartPosResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__getRobotJntCartPosResponse *p;
	size_t k = sizeof(_ns1__getRobotJntCartPosResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__getRobotJntCartPosResponse);
		if (p)
			((_ns1__getRobotJntCartPosResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__getRobotJntCartPosResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__getRobotJntCartPosResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__getRobotJntCartPosResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__getRobotJntCartPosResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__getRobotJntCartPosResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__getRobotJntCartPosResponse(soap, tag ? tag : "ns1:getRobotJntCartPosResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getRobotJntCartPosResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getRobotJntCartPosResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getRobotJntCartPosResponse * SOAP_FMAC4 soap_get__ns1__getRobotJntCartPosResponse(struct soap *soap, _ns1__getRobotJntCartPosResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getRobotJntCartPosResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__getRobotJntCartPos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__getRobotJntCartPos::robot);
	this->_ns1__getRobotJntCartPos::tool = NULL;
	this->_ns1__getRobotJntCartPos::frame = NULL;
	/* transient soap skipped */
}

void _ns1__getRobotJntCartPos::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__CartesianPos(soap, &this->_ns1__getRobotJntCartPos::tool);
	soap_serialize_PointerTons1__CartesianPos(soap, &this->_ns1__getRobotJntCartPos::frame);
#endif
}

int _ns1__getRobotJntCartPos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getRobotJntCartPos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getRobotJntCartPos(struct soap *soap, const char *tag, int id, const _ns1__getRobotJntCartPos *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getRobotJntCartPos), type))
		return soap->error;
	if (soap_out_int(soap, "robot", -1, &a->_ns1__getRobotJntCartPos::robot, ""))
		return soap->error;
	if (!a->_ns1__getRobotJntCartPos::tool)
	{	if (soap_element_empty(soap, "tool"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__CartesianPos(soap, "tool", -1, &a->_ns1__getRobotJntCartPos::tool, ""))
		return soap->error;
	if (!a->_ns1__getRobotJntCartPos::frame)
	{	if (soap_element_empty(soap, "frame"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__CartesianPos(soap, "frame", -1, &a->_ns1__getRobotJntCartPos::frame, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__getRobotJntCartPos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getRobotJntCartPos(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getRobotJntCartPos * SOAP_FMAC4 soap_in__ns1__getRobotJntCartPos(struct soap *soap, const char *tag, _ns1__getRobotJntCartPos *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getRobotJntCartPos *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getRobotJntCartPos, sizeof(_ns1__getRobotJntCartPos), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__getRobotJntCartPos)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__getRobotJntCartPos *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_robot1 = 1;
	size_t soap_flag_tool1 = 1;
	size_t soap_flag_frame1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_robot1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "robot", &a->_ns1__getRobotJntCartPos::robot, "xsd:int"))
				{	soap_flag_robot1--;
					continue;
				}
			}
			if (soap_flag_tool1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__CartesianPos(soap, "tool", &a->_ns1__getRobotJntCartPos::tool, "ns1:CartesianPos"))
				{	soap_flag_tool1--;
					continue;
				}
			}
			if (soap_flag_frame1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__CartesianPos(soap, "frame", &a->_ns1__getRobotJntCartPos::frame, "ns1:CartesianPos"))
				{	soap_flag_frame1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_robot1 > 0 || !a->_ns1__getRobotJntCartPos::tool || !a->_ns1__getRobotJntCartPos::frame))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__getRobotJntCartPos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getRobotJntCartPos, SOAP_TYPE__ns1__getRobotJntCartPos, sizeof(_ns1__getRobotJntCartPos), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__getRobotJntCartPos * SOAP_FMAC2 soap_instantiate__ns1__getRobotJntCartPos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getRobotJntCartPos(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__getRobotJntCartPos *p;
	size_t k = sizeof(_ns1__getRobotJntCartPos);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__getRobotJntCartPos);
		if (p)
			((_ns1__getRobotJntCartPos*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__getRobotJntCartPos, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__getRobotJntCartPos*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__getRobotJntCartPos location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__getRobotJntCartPos, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__getRobotJntCartPos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__getRobotJntCartPos(soap, tag ? tag : "ns1:getRobotJntCartPos", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getRobotJntCartPos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getRobotJntCartPos(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getRobotJntCartPos * SOAP_FMAC4 soap_get__ns1__getRobotJntCartPos(struct soap *soap, _ns1__getRobotJntCartPos *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getRobotJntCartPos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__getRobotJointPosResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getRobotJointPosResponse::pos = NULL;
	/* transient soap skipped */
}

void _ns1__getRobotJointPosResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__JointPos(soap, &this->_ns1__getRobotJointPosResponse::pos);
#endif
}

int _ns1__getRobotJointPosResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getRobotJointPosResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getRobotJointPosResponse(struct soap *soap, const char *tag, int id, const _ns1__getRobotJointPosResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getRobotJointPosResponse), type))
		return soap->error;
	if (!a->_ns1__getRobotJointPosResponse::pos)
	{	if (soap_element_empty(soap, "pos"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__JointPos(soap, "pos", -1, &a->_ns1__getRobotJointPosResponse::pos, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__getRobotJointPosResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getRobotJointPosResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getRobotJointPosResponse * SOAP_FMAC4 soap_in__ns1__getRobotJointPosResponse(struct soap *soap, const char *tag, _ns1__getRobotJointPosResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getRobotJointPosResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getRobotJointPosResponse, sizeof(_ns1__getRobotJointPosResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__getRobotJointPosResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__getRobotJointPosResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_pos1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pos1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__JointPos(soap, "pos", &a->_ns1__getRobotJointPosResponse::pos, "ns1:JointPos"))
				{	soap_flag_pos1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns1__getRobotJointPosResponse::pos))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__getRobotJointPosResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getRobotJointPosResponse, SOAP_TYPE__ns1__getRobotJointPosResponse, sizeof(_ns1__getRobotJointPosResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__getRobotJointPosResponse * SOAP_FMAC2 soap_instantiate__ns1__getRobotJointPosResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getRobotJointPosResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__getRobotJointPosResponse *p;
	size_t k = sizeof(_ns1__getRobotJointPosResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__getRobotJointPosResponse);
		if (p)
			((_ns1__getRobotJointPosResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__getRobotJointPosResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__getRobotJointPosResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__getRobotJointPosResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__getRobotJointPosResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__getRobotJointPosResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__getRobotJointPosResponse(soap, tag ? tag : "ns1:getRobotJointPosResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getRobotJointPosResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getRobotJointPosResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getRobotJointPosResponse * SOAP_FMAC4 soap_get__ns1__getRobotJointPosResponse(struct soap *soap, _ns1__getRobotJointPosResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getRobotJointPosResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__getRobotJointPos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__getRobotJointPos::robot);
	/* transient soap skipped */
}

void _ns1__getRobotJointPos::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__getRobotJointPos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getRobotJointPos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getRobotJointPos(struct soap *soap, const char *tag, int id, const _ns1__getRobotJointPos *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getRobotJointPos), type))
		return soap->error;
	if (soap_out_int(soap, "robot", -1, &a->_ns1__getRobotJointPos::robot, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__getRobotJointPos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getRobotJointPos(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getRobotJointPos * SOAP_FMAC4 soap_in__ns1__getRobotJointPos(struct soap *soap, const char *tag, _ns1__getRobotJointPos *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getRobotJointPos *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getRobotJointPos, sizeof(_ns1__getRobotJointPos), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__getRobotJointPos)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__getRobotJointPos *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_robot1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_robot1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "robot", &a->_ns1__getRobotJointPos::robot, "xsd:int"))
				{	soap_flag_robot1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_robot1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__getRobotJointPos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getRobotJointPos, SOAP_TYPE__ns1__getRobotJointPos, sizeof(_ns1__getRobotJointPos), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__getRobotJointPos * SOAP_FMAC2 soap_instantiate__ns1__getRobotJointPos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getRobotJointPos(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__getRobotJointPos *p;
	size_t k = sizeof(_ns1__getRobotJointPos);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__getRobotJointPos);
		if (p)
			((_ns1__getRobotJointPos*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__getRobotJointPos, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__getRobotJointPos*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__getRobotJointPos location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__getRobotJointPos, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__getRobotJointPos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__getRobotJointPos(soap, tag ? tag : "ns1:getRobotJointPos", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getRobotJointPos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getRobotJointPos(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getRobotJointPos * SOAP_FMAC4 soap_get__ns1__getRobotJointPos(struct soap *soap, _ns1__getRobotJointPos *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getRobotJointPos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__getRobotsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getRobotsResponse::out = NULL;
	/* transient soap skipped */
}

void _ns1__getRobotsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__Robots(soap, &this->_ns1__getRobotsResponse::out);
#endif
}

int _ns1__getRobotsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getRobotsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getRobotsResponse(struct soap *soap, const char *tag, int id, const _ns1__getRobotsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getRobotsResponse), type))
		return soap->error;
	if (!a->_ns1__getRobotsResponse::out)
	{	if (soap_element_empty(soap, "out"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__Robots(soap, "out", -1, &a->_ns1__getRobotsResponse::out, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__getRobotsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getRobotsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getRobotsResponse * SOAP_FMAC4 soap_in__ns1__getRobotsResponse(struct soap *soap, const char *tag, _ns1__getRobotsResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getRobotsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getRobotsResponse, sizeof(_ns1__getRobotsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__getRobotsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__getRobotsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_out1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Robots(soap, "out", &a->_ns1__getRobotsResponse::out, "ns1:Robots"))
				{	soap_flag_out1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns1__getRobotsResponse::out))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__getRobotsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getRobotsResponse, SOAP_TYPE__ns1__getRobotsResponse, sizeof(_ns1__getRobotsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__getRobotsResponse * SOAP_FMAC2 soap_instantiate__ns1__getRobotsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getRobotsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__getRobotsResponse *p;
	size_t k = sizeof(_ns1__getRobotsResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__getRobotsResponse);
		if (p)
			((_ns1__getRobotsResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__getRobotsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__getRobotsResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__getRobotsResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__getRobotsResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__getRobotsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__getRobotsResponse(soap, tag ? tag : "ns1:getRobotsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getRobotsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getRobotsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getRobotsResponse * SOAP_FMAC4 soap_get__ns1__getRobotsResponse(struct soap *soap, _ns1__getRobotsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getRobotsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__getRobots::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__getRobots::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__getRobots::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getRobots(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getRobots(struct soap *soap, const char *tag, int id, const _ns1__getRobots *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getRobots), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__getRobots::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getRobots(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getRobots * SOAP_FMAC4 soap_in__ns1__getRobots(struct soap *soap, const char *tag, _ns1__getRobots *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getRobots *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getRobots, sizeof(_ns1__getRobots), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__getRobots)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__getRobots *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getRobots *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getRobots, SOAP_TYPE__ns1__getRobots, sizeof(_ns1__getRobots), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__getRobots * SOAP_FMAC2 soap_instantiate__ns1__getRobots(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getRobots(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__getRobots *p;
	size_t k = sizeof(_ns1__getRobots);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__getRobots);
		if (p)
			((_ns1__getRobots*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__getRobots, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__getRobots*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__getRobots location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__getRobots, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__getRobots::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__getRobots(soap, tag ? tag : "ns1:getRobots", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getRobots::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getRobots(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getRobots * SOAP_FMAC4 soap_get__ns1__getRobots(struct soap *soap, _ns1__getRobots *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getRobots(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__logoutResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__logoutResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__logoutResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__logoutResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__logoutResponse(struct soap *soap, const char *tag, int id, const _ns1__logoutResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__logoutResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__logoutResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__logoutResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__logoutResponse * SOAP_FMAC4 soap_in__ns1__logoutResponse(struct soap *soap, const char *tag, _ns1__logoutResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__logoutResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__logoutResponse, sizeof(_ns1__logoutResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__logoutResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__logoutResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__logoutResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__logoutResponse, SOAP_TYPE__ns1__logoutResponse, sizeof(_ns1__logoutResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__logoutResponse * SOAP_FMAC2 soap_instantiate__ns1__logoutResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__logoutResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__logoutResponse *p;
	size_t k = sizeof(_ns1__logoutResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__logoutResponse);
		if (p)
			((_ns1__logoutResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__logoutResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__logoutResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__logoutResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__logoutResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__logoutResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__logoutResponse(soap, tag ? tag : "ns1:logoutResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__logoutResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__logoutResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__logoutResponse * SOAP_FMAC4 soap_get__ns1__logoutResponse(struct soap *soap, _ns1__logoutResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__logoutResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__logout::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__logout::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__logout::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__logout(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__logout(struct soap *soap, const char *tag, int id, const _ns1__logout *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__logout), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__logout::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__logout(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__logout * SOAP_FMAC4 soap_in__ns1__logout(struct soap *soap, const char *tag, _ns1__logout *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__logout *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__logout, sizeof(_ns1__logout), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__logout)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__logout *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__logout *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__logout, SOAP_TYPE__ns1__logout, sizeof(_ns1__logout), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__logout * SOAP_FMAC2 soap_instantiate__ns1__logout(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__logout(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__logout *p;
	size_t k = sizeof(_ns1__logout);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__logout);
		if (p)
			((_ns1__logout*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__logout, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__logout*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__logout location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__logout, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__logout::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__logout(soap, tag ? tag : "ns1:logout", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__logout::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__logout(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__logout * SOAP_FMAC4 soap_get__ns1__logout(struct soap *soap, _ns1__logout *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__logout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__loginResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__SessionId(soap, &this->_ns1__loginResponse::sid);
	/* transient soap skipped */
}

void _ns1__loginResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns1__loginResponse::sid, SOAP_TYPE_ns1__SessionId);
#endif
}

int _ns1__loginResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__loginResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__loginResponse(struct soap *soap, const char *tag, int id, const _ns1__loginResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__loginResponse), type))
		return soap->error;
	if (soap_out_ns1__SessionId(soap, "sid", -1, &a->_ns1__loginResponse::sid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__loginResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__loginResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__loginResponse * SOAP_FMAC4 soap_in__ns1__loginResponse(struct soap *soap, const char *tag, _ns1__loginResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__loginResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__loginResponse, sizeof(_ns1__loginResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__loginResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__loginResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_sid1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns1__SessionId(soap, "sid", &a->_ns1__loginResponse::sid, "ns1:SessionId"))
				{	soap_flag_sid1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sid1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__loginResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__loginResponse, SOAP_TYPE__ns1__loginResponse, sizeof(_ns1__loginResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__loginResponse * SOAP_FMAC2 soap_instantiate__ns1__loginResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__loginResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__loginResponse *p;
	size_t k = sizeof(_ns1__loginResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__loginResponse);
		if (p)
			((_ns1__loginResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__loginResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__loginResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__loginResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__loginResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__loginResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__loginResponse(soap, tag ? tag : "ns1:loginResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__loginResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__loginResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__loginResponse * SOAP_FMAC4 soap_get__ns1__loginResponse(struct soap *soap, _ns1__loginResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__loginResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__login::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__login::user = NULL;
	this->_ns1__login::pwd = NULL;
	/* transient soap skipped */
}

void _ns1__login::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__login::user);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__login::pwd);
#endif
}

int _ns1__login::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__login(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__login(struct soap *soap, const char *tag, int id, const _ns1__login *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__login), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "user", -1, &a->_ns1__login::user, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "pwd", -1, &a->_ns1__login::pwd, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__login::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__login(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__login * SOAP_FMAC4 soap_in__ns1__login(struct soap *soap, const char *tag, _ns1__login *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__login *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__login, sizeof(_ns1__login), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__login)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__login *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_user1 = 1;
	size_t soap_flag_pwd1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_user1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "user", &a->_ns1__login::user, "xsd:string"))
				{	soap_flag_user1--;
					continue;
				}
			}
			if (soap_flag_pwd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "pwd", &a->_ns1__login::pwd, "xsd:string"))
				{	soap_flag_pwd1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__login *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__login, SOAP_TYPE__ns1__login, sizeof(_ns1__login), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__login * SOAP_FMAC2 soap_instantiate__ns1__login(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__login(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__login *p;
	size_t k = sizeof(_ns1__login);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__login);
		if (p)
			((_ns1__login*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__login, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__login*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__login location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__login, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__login::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__login(soap, tag ? tag : "ns1:login", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__login::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__login(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__login * SOAP_FMAC4 soap_get__ns1__login(struct soap *soap, _ns1__login *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__getCS8CompatibilityResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getCS8CompatibilityResponse::compatibility = NULL;
	/* transient soap skipped */
}

void _ns1__getCS8CompatibilityResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__getCS8CompatibilityResponse::compatibility);
#endif
}

int _ns1__getCS8CompatibilityResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getCS8CompatibilityResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getCS8CompatibilityResponse(struct soap *soap, const char *tag, int id, const _ns1__getCS8CompatibilityResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getCS8CompatibilityResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "compatibility", -1, &a->_ns1__getCS8CompatibilityResponse::compatibility, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__getCS8CompatibilityResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getCS8CompatibilityResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getCS8CompatibilityResponse * SOAP_FMAC4 soap_in__ns1__getCS8CompatibilityResponse(struct soap *soap, const char *tag, _ns1__getCS8CompatibilityResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getCS8CompatibilityResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getCS8CompatibilityResponse, sizeof(_ns1__getCS8CompatibilityResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__getCS8CompatibilityResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__getCS8CompatibilityResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_compatibility1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_compatibility1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "compatibility", &a->_ns1__getCS8CompatibilityResponse::compatibility, "xsd:string"))
				{	soap_flag_compatibility1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getCS8CompatibilityResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getCS8CompatibilityResponse, SOAP_TYPE__ns1__getCS8CompatibilityResponse, sizeof(_ns1__getCS8CompatibilityResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__getCS8CompatibilityResponse * SOAP_FMAC2 soap_instantiate__ns1__getCS8CompatibilityResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getCS8CompatibilityResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__getCS8CompatibilityResponse *p;
	size_t k = sizeof(_ns1__getCS8CompatibilityResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__getCS8CompatibilityResponse);
		if (p)
			((_ns1__getCS8CompatibilityResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__getCS8CompatibilityResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__getCS8CompatibilityResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__getCS8CompatibilityResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__getCS8CompatibilityResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__getCS8CompatibilityResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__getCS8CompatibilityResponse(soap, tag ? tag : "ns1:getCS8CompatibilityResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getCS8CompatibilityResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getCS8CompatibilityResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getCS8CompatibilityResponse * SOAP_FMAC4 soap_get__ns1__getCS8CompatibilityResponse(struct soap *soap, _ns1__getCS8CompatibilityResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getCS8CompatibilityResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__getCS8Compatibility::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__getCS8Compatibility::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__getCS8Compatibility::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getCS8Compatibility(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getCS8Compatibility(struct soap *soap, const char *tag, int id, const _ns1__getCS8Compatibility *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getCS8Compatibility), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__getCS8Compatibility::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getCS8Compatibility(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getCS8Compatibility * SOAP_FMAC4 soap_in__ns1__getCS8Compatibility(struct soap *soap, const char *tag, _ns1__getCS8Compatibility *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getCS8Compatibility *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getCS8Compatibility, sizeof(_ns1__getCS8Compatibility), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__getCS8Compatibility)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__getCS8Compatibility *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getCS8Compatibility *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getCS8Compatibility, SOAP_TYPE__ns1__getCS8Compatibility, sizeof(_ns1__getCS8Compatibility), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__getCS8Compatibility * SOAP_FMAC2 soap_instantiate__ns1__getCS8Compatibility(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getCS8Compatibility(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__getCS8Compatibility *p;
	size_t k = sizeof(_ns1__getCS8Compatibility);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__getCS8Compatibility);
		if (p)
			((_ns1__getCS8Compatibility*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__getCS8Compatibility, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__getCS8Compatibility*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__getCS8Compatibility location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__getCS8Compatibility, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__getCS8Compatibility::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__getCS8Compatibility(soap, tag ? tag : "ns1:getCS8Compatibility", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getCS8Compatibility::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getCS8Compatibility(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getCS8Compatibility * SOAP_FMAC4 soap_get__ns1__getCS8Compatibility(struct soap *soap, _ns1__getCS8Compatibility *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getCS8Compatibility(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__getControllerParametersResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getControllerParametersResponse::out = NULL;
	/* transient soap skipped */
}

void _ns1__getControllerParametersResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__Parameters(soap, &this->_ns1__getControllerParametersResponse::out);
#endif
}

int _ns1__getControllerParametersResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getControllerParametersResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getControllerParametersResponse(struct soap *soap, const char *tag, int id, const _ns1__getControllerParametersResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getControllerParametersResponse), type))
		return soap->error;
	if (!a->_ns1__getControllerParametersResponse::out)
	{	if (soap_element_empty(soap, "out"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__Parameters(soap, "out", -1, &a->_ns1__getControllerParametersResponse::out, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__getControllerParametersResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getControllerParametersResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getControllerParametersResponse * SOAP_FMAC4 soap_in__ns1__getControllerParametersResponse(struct soap *soap, const char *tag, _ns1__getControllerParametersResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getControllerParametersResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getControllerParametersResponse, sizeof(_ns1__getControllerParametersResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__getControllerParametersResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__getControllerParametersResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_out1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Parameters(soap, "out", &a->_ns1__getControllerParametersResponse::out, "ns1:Parameters"))
				{	soap_flag_out1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns1__getControllerParametersResponse::out))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__getControllerParametersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getControllerParametersResponse, SOAP_TYPE__ns1__getControllerParametersResponse, sizeof(_ns1__getControllerParametersResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__getControllerParametersResponse * SOAP_FMAC2 soap_instantiate__ns1__getControllerParametersResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getControllerParametersResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__getControllerParametersResponse *p;
	size_t k = sizeof(_ns1__getControllerParametersResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__getControllerParametersResponse);
		if (p)
			((_ns1__getControllerParametersResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__getControllerParametersResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__getControllerParametersResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__getControllerParametersResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__getControllerParametersResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__getControllerParametersResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__getControllerParametersResponse(soap, tag ? tag : "ns1:getControllerParametersResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getControllerParametersResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getControllerParametersResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getControllerParametersResponse * SOAP_FMAC4 soap_get__ns1__getControllerParametersResponse(struct soap *soap, _ns1__getControllerParametersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getControllerParametersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__getControllerParameters::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__getControllerParameters::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__getControllerParameters::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getControllerParameters(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getControllerParameters(struct soap *soap, const char *tag, int id, const _ns1__getControllerParameters *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getControllerParameters), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__getControllerParameters::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getControllerParameters(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getControllerParameters * SOAP_FMAC4 soap_in__ns1__getControllerParameters(struct soap *soap, const char *tag, _ns1__getControllerParameters *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getControllerParameters *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getControllerParameters, sizeof(_ns1__getControllerParameters), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__getControllerParameters)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__getControllerParameters *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getControllerParameters *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getControllerParameters, SOAP_TYPE__ns1__getControllerParameters, sizeof(_ns1__getControllerParameters), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__getControllerParameters * SOAP_FMAC2 soap_instantiate__ns1__getControllerParameters(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getControllerParameters(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__getControllerParameters *p;
	size_t k = sizeof(_ns1__getControllerParameters);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__getControllerParameters);
		if (p)
			((_ns1__getControllerParameters*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__getControllerParameters, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__getControllerParameters*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__getControllerParameters location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__getControllerParameters, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__getControllerParameters::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__getControllerParameters(soap, tag ? tag : "ns1:getControllerParameters", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getControllerParameters::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getControllerParameters(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getControllerParameters * SOAP_FMAC4 soap_get__ns1__getControllerParameters(struct soap *soap, _ns1__getControllerParameters *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getControllerParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__getCS8VersionsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getCS8VersionsResponse::out = NULL;
	/* transient soap skipped */
}

void _ns1__getCS8VersionsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__Versions(soap, &this->_ns1__getCS8VersionsResponse::out);
#endif
}

int _ns1__getCS8VersionsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getCS8VersionsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getCS8VersionsResponse(struct soap *soap, const char *tag, int id, const _ns1__getCS8VersionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getCS8VersionsResponse), type))
		return soap->error;
	if (!a->_ns1__getCS8VersionsResponse::out)
	{	if (soap_element_empty(soap, "out"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__Versions(soap, "out", -1, &a->_ns1__getCS8VersionsResponse::out, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__getCS8VersionsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getCS8VersionsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getCS8VersionsResponse * SOAP_FMAC4 soap_in__ns1__getCS8VersionsResponse(struct soap *soap, const char *tag, _ns1__getCS8VersionsResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getCS8VersionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getCS8VersionsResponse, sizeof(_ns1__getCS8VersionsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__getCS8VersionsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__getCS8VersionsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_out1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Versions(soap, "out", &a->_ns1__getCS8VersionsResponse::out, "ns1:Versions"))
				{	soap_flag_out1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns1__getCS8VersionsResponse::out))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__getCS8VersionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getCS8VersionsResponse, SOAP_TYPE__ns1__getCS8VersionsResponse, sizeof(_ns1__getCS8VersionsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__getCS8VersionsResponse * SOAP_FMAC2 soap_instantiate__ns1__getCS8VersionsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getCS8VersionsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__getCS8VersionsResponse *p;
	size_t k = sizeof(_ns1__getCS8VersionsResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__getCS8VersionsResponse);
		if (p)
			((_ns1__getCS8VersionsResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__getCS8VersionsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__getCS8VersionsResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__getCS8VersionsResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__getCS8VersionsResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__getCS8VersionsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__getCS8VersionsResponse(soap, tag ? tag : "ns1:getCS8VersionsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getCS8VersionsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getCS8VersionsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getCS8VersionsResponse * SOAP_FMAC4 soap_get__ns1__getCS8VersionsResponse(struct soap *soap, _ns1__getCS8VersionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getCS8VersionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__getCS8Versions::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__getCS8Versions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__getCS8Versions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getCS8Versions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getCS8Versions(struct soap *soap, const char *tag, int id, const _ns1__getCS8Versions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getCS8Versions), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__getCS8Versions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getCS8Versions(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getCS8Versions * SOAP_FMAC4 soap_in__ns1__getCS8Versions(struct soap *soap, const char *tag, _ns1__getCS8Versions *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getCS8Versions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getCS8Versions, sizeof(_ns1__getCS8Versions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__getCS8Versions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__getCS8Versions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getCS8Versions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getCS8Versions, SOAP_TYPE__ns1__getCS8Versions, sizeof(_ns1__getCS8Versions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__getCS8Versions * SOAP_FMAC2 soap_instantiate__ns1__getCS8Versions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getCS8Versions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__getCS8Versions *p;
	size_t k = sizeof(_ns1__getCS8Versions);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__getCS8Versions);
		if (p)
			((_ns1__getCS8Versions*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__getCS8Versions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__getCS8Versions*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__getCS8Versions location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__getCS8Versions, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__getCS8Versions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__getCS8Versions(soap, tag ? tag : "ns1:getCS8Versions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getCS8Versions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getCS8Versions(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getCS8Versions * SOAP_FMAC4 soap_get__ns1__getCS8Versions(struct soap *soap, _ns1__getCS8Versions *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getCS8Versions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__pingResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__pingResponse::message = NULL;
	/* transient soap skipped */
}

void _ns1__pingResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__pingResponse::message);
#endif
}

int _ns1__pingResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__pingResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__pingResponse(struct soap *soap, const char *tag, int id, const _ns1__pingResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__pingResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "message", -1, &a->_ns1__pingResponse::message, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__pingResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__pingResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__pingResponse * SOAP_FMAC4 soap_in__ns1__pingResponse(struct soap *soap, const char *tag, _ns1__pingResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__pingResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__pingResponse, sizeof(_ns1__pingResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__pingResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__pingResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_message1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "message", &a->_ns1__pingResponse::message, "xsd:string"))
				{	soap_flag_message1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__pingResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__pingResponse, SOAP_TYPE__ns1__pingResponse, sizeof(_ns1__pingResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__pingResponse * SOAP_FMAC2 soap_instantiate__ns1__pingResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__pingResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__pingResponse *p;
	size_t k = sizeof(_ns1__pingResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__pingResponse);
		if (p)
			((_ns1__pingResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__pingResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__pingResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__pingResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__pingResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__pingResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__pingResponse(soap, tag ? tag : "ns1:pingResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__pingResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__pingResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__pingResponse * SOAP_FMAC4 soap_get__ns1__pingResponse(struct soap *soap, _ns1__pingResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__pingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ping::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__ping::message = NULL;
	/* transient soap skipped */
}

void _ns1__ping::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__ping::message);
#endif
}

int _ns1__ping::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ping(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ping(struct soap *soap, const char *tag, int id, const _ns1__ping *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ping), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "message", -1, &a->_ns1__ping::message, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ping::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ping(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ping * SOAP_FMAC4 soap_in__ns1__ping(struct soap *soap, const char *tag, _ns1__ping *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ping *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ping, sizeof(_ns1__ping), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__ping)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__ping *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_message1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "message", &a->_ns1__ping::message, "xsd:string"))
				{	soap_flag_message1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ping *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ping, SOAP_TYPE__ns1__ping, sizeof(_ns1__ping), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ping * SOAP_FMAC2 soap_instantiate__ns1__ping(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ping(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ping *p;
	size_t k = sizeof(_ns1__ping);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__ping);
		if (p)
			((_ns1__ping*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__ping, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__ping*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ping location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__ping, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__ping::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__ping(soap, tag ? tag : "ns1:ping", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ping::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ping(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ping * SOAP_FMAC4 soap_get__ns1__ping(struct soap *soap, _ns1__ping *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ping(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__findServerResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_ns1__findServerResponse::found);
	/* transient soap skipped */
}

void _ns1__findServerResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__findServerResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__findServerResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__findServerResponse(struct soap *soap, const char *tag, int id, const _ns1__findServerResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__findServerResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "found", -1, &a->_ns1__findServerResponse::found, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__findServerResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__findServerResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__findServerResponse * SOAP_FMAC4 soap_in__ns1__findServerResponse(struct soap *soap, const char *tag, _ns1__findServerResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__findServerResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__findServerResponse, sizeof(_ns1__findServerResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__findServerResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__findServerResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_found1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_found1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "found", &a->_ns1__findServerResponse::found, "xsd:boolean"))
				{	soap_flag_found1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_found1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__findServerResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__findServerResponse, SOAP_TYPE__ns1__findServerResponse, sizeof(_ns1__findServerResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__findServerResponse * SOAP_FMAC2 soap_instantiate__ns1__findServerResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__findServerResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__findServerResponse *p;
	size_t k = sizeof(_ns1__findServerResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__findServerResponse);
		if (p)
			((_ns1__findServerResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__findServerResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__findServerResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__findServerResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__findServerResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__findServerResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__findServerResponse(soap, tag ? tag : "ns1:findServerResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__findServerResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__findServerResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__findServerResponse * SOAP_FMAC4 soap_get__ns1__findServerResponse(struct soap *soap, _ns1__findServerResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__findServerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__findServer::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__findServer::serverName = NULL;
	/* transient soap skipped */
}

void _ns1__findServer::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__findServer::serverName);
#endif
}

int _ns1__findServer::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__findServer(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__findServer(struct soap *soap, const char *tag, int id, const _ns1__findServer *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__findServer), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "serverName", -1, &a->_ns1__findServer::serverName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__findServer::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__findServer(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__findServer * SOAP_FMAC4 soap_in__ns1__findServer(struct soap *soap, const char *tag, _ns1__findServer *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__findServer *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__findServer, sizeof(_ns1__findServer), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__findServer)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__findServer *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_serverName1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_serverName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "serverName", &a->_ns1__findServer::serverName, "xsd:string"))
				{	soap_flag_serverName1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__findServer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__findServer, SOAP_TYPE__ns1__findServer, sizeof(_ns1__findServer), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__findServer * SOAP_FMAC2 soap_instantiate__ns1__findServer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__findServer(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__findServer *p;
	size_t k = sizeof(_ns1__findServer);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__findServer);
		if (p)
			((_ns1__findServer*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__findServer, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__findServer*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__findServer location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__findServer, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__findServer::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__findServer(soap, tag ? tag : "ns1:findServer", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__findServer::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__findServer(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__findServer * SOAP_FMAC4 soap_get__ns1__findServer(struct soap *soap, _ns1__findServer *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__findServer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__getSoapServerVersionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getSoapServerVersionResponse::server = NULL;
	/* transient soap skipped */
}

void _ns1__getSoapServerVersionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SoapServerVersion(soap, &this->_ns1__getSoapServerVersionResponse::server);
#endif
}

int _ns1__getSoapServerVersionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getSoapServerVersionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getSoapServerVersionResponse(struct soap *soap, const char *tag, int id, const _ns1__getSoapServerVersionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getSoapServerVersionResponse), type))
		return soap->error;
	if (!a->_ns1__getSoapServerVersionResponse::server)
	{	if (soap_element_empty(soap, "server"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__SoapServerVersion(soap, "server", -1, &a->_ns1__getSoapServerVersionResponse::server, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__getSoapServerVersionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getSoapServerVersionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getSoapServerVersionResponse * SOAP_FMAC4 soap_in__ns1__getSoapServerVersionResponse(struct soap *soap, const char *tag, _ns1__getSoapServerVersionResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getSoapServerVersionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getSoapServerVersionResponse, sizeof(_ns1__getSoapServerVersionResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__getSoapServerVersionResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__getSoapServerVersionResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_server1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_server1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__SoapServerVersion(soap, "server", &a->_ns1__getSoapServerVersionResponse::server, "ns1:SoapServerVersion"))
				{	soap_flag_server1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns1__getSoapServerVersionResponse::server))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__getSoapServerVersionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getSoapServerVersionResponse, SOAP_TYPE__ns1__getSoapServerVersionResponse, sizeof(_ns1__getSoapServerVersionResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__getSoapServerVersionResponse * SOAP_FMAC2 soap_instantiate__ns1__getSoapServerVersionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getSoapServerVersionResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__getSoapServerVersionResponse *p;
	size_t k = sizeof(_ns1__getSoapServerVersionResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__getSoapServerVersionResponse);
		if (p)
			((_ns1__getSoapServerVersionResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__getSoapServerVersionResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__getSoapServerVersionResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__getSoapServerVersionResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__getSoapServerVersionResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__getSoapServerVersionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__getSoapServerVersionResponse(soap, tag ? tag : "ns1:getSoapServerVersionResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getSoapServerVersionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getSoapServerVersionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getSoapServerVersionResponse * SOAP_FMAC4 soap_get__ns1__getSoapServerVersionResponse(struct soap *soap, _ns1__getSoapServerVersionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getSoapServerVersionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__getSoapServerVersion::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getSoapServerVersion::cltName = NULL;
	this->_ns1__getSoapServerVersion::cltVersion = NULL;
	/* transient soap skipped */
}

void _ns1__getSoapServerVersion::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__getSoapServerVersion::cltName);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__getSoapServerVersion::cltVersion);
#endif
}

int _ns1__getSoapServerVersion::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getSoapServerVersion(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getSoapServerVersion(struct soap *soap, const char *tag, int id, const _ns1__getSoapServerVersion *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getSoapServerVersion), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "cltName", -1, &a->_ns1__getSoapServerVersion::cltName, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "cltVersion", -1, &a->_ns1__getSoapServerVersion::cltVersion, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__getSoapServerVersion::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getSoapServerVersion(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getSoapServerVersion * SOAP_FMAC4 soap_in__ns1__getSoapServerVersion(struct soap *soap, const char *tag, _ns1__getSoapServerVersion *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getSoapServerVersion *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getSoapServerVersion, sizeof(_ns1__getSoapServerVersion), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__getSoapServerVersion)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__getSoapServerVersion *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_cltName1 = 1;
	size_t soap_flag_cltVersion1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cltName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "cltName", &a->_ns1__getSoapServerVersion::cltName, "xsd:string"))
				{	soap_flag_cltName1--;
					continue;
				}
			}
			if (soap_flag_cltVersion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "cltVersion", &a->_ns1__getSoapServerVersion::cltVersion, "xsd:string"))
				{	soap_flag_cltVersion1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getSoapServerVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getSoapServerVersion, SOAP_TYPE__ns1__getSoapServerVersion, sizeof(_ns1__getSoapServerVersion), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__getSoapServerVersion * SOAP_FMAC2 soap_instantiate__ns1__getSoapServerVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getSoapServerVersion(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__getSoapServerVersion *p;
	size_t k = sizeof(_ns1__getSoapServerVersion);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__getSoapServerVersion);
		if (p)
			((_ns1__getSoapServerVersion*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__getSoapServerVersion, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__getSoapServerVersion*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__getSoapServerVersion location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__getSoapServerVersion, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__getSoapServerVersion::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__getSoapServerVersion(soap, tag ? tag : "ns1:getSoapServerVersion", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getSoapServerVersion::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getSoapServerVersion(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getSoapServerVersion * SOAP_FMAC4 soap_get__ns1__getSoapServerVersion(struct soap *soap, _ns1__getSoapServerVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getSoapServerVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__Robots::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__Robot(soap, &this->ns1__Robots::Robots);
	/* transient soap skipped */
}

void ns1__Robots::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__Robot(soap, &this->ns1__Robots::Robots);
#endif
}

int ns1__Robots::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Robots(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Robots(struct soap *soap, const char *tag, int id, const ns1__Robots *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Robots), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__Robot(soap, "Robots", -1, &a->ns1__Robots::Robots, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__Robots::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Robots(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Robots * SOAP_FMAC4 soap_in_ns1__Robots(struct soap *soap, const char *tag, ns1__Robots *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Robots *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Robots, sizeof(ns1__Robots), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__Robots)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__Robots *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__Robot(soap, "Robots", &a->ns1__Robots::Robots, "ns1:Robot"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Robots *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Robots, SOAP_TYPE_ns1__Robots, sizeof(ns1__Robots), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__Robots * SOAP_FMAC2 soap_instantiate_ns1__Robots(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Robots(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__Robots *p;
	size_t k = sizeof(ns1__Robots);
	if (n < 0)
	{	p = SOAP_NEW(ns1__Robots);
		if (p)
			((ns1__Robots*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__Robots, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__Robots*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__Robots location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__Robots, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__Robots::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__Robots(soap, tag ? tag : "ns1:Robots", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Robots::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Robots(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Robots * SOAP_FMAC4 soap_get_ns1__Robots(struct soap *soap, ns1__Robots *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Robots(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__SoapServerVersion::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__SoapServerVersion::version = NULL;
	/* transient soap skipped */
}

void ns1__SoapServerVersion::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns1__SoapServerVersion::version);
#endif
}

int ns1__SoapServerVersion::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SoapServerVersion(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SoapServerVersion(struct soap *soap, const char *tag, int id, const ns1__SoapServerVersion *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SoapServerVersion), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "version", -1, &a->ns1__SoapServerVersion::version, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SoapServerVersion::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SoapServerVersion(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SoapServerVersion * SOAP_FMAC4 soap_in_ns1__SoapServerVersion(struct soap *soap, const char *tag, ns1__SoapServerVersion *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SoapServerVersion *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SoapServerVersion, sizeof(ns1__SoapServerVersion), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__SoapServerVersion)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__SoapServerVersion *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_version1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_version1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "version", &a->ns1__SoapServerVersion::version, "xsd:string"))
				{	soap_flag_version1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SoapServerVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SoapServerVersion, SOAP_TYPE_ns1__SoapServerVersion, sizeof(ns1__SoapServerVersion), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__SoapServerVersion * SOAP_FMAC2 soap_instantiate_ns1__SoapServerVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SoapServerVersion(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__SoapServerVersion *p;
	size_t k = sizeof(ns1__SoapServerVersion);
	if (n < 0)
	{	p = SOAP_NEW(ns1__SoapServerVersion);
		if (p)
			((ns1__SoapServerVersion*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__SoapServerVersion, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__SoapServerVersion*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__SoapServerVersion location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__SoapServerVersion, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__SoapServerVersion::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__SoapServerVersion(soap, tag ? tag : "ns1:SoapServerVersion", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SoapServerVersion::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SoapServerVersion(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SoapServerVersion * SOAP_FMAC4 soap_get_ns1__SoapServerVersion(struct soap *soap, ns1__SoapServerVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SoapServerVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__Versions::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__Version(soap, &this->ns1__Versions::Versions);
	/* transient soap skipped */
}

void ns1__Versions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__Version(soap, &this->ns1__Versions::Versions);
#endif
}

int ns1__Versions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Versions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Versions(struct soap *soap, const char *tag, int id, const ns1__Versions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Versions), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__Version(soap, "Versions", -1, &a->ns1__Versions::Versions, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__Versions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Versions(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Versions * SOAP_FMAC4 soap_in_ns1__Versions(struct soap *soap, const char *tag, ns1__Versions *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Versions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Versions, sizeof(ns1__Versions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__Versions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__Versions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__Version(soap, "Versions", &a->ns1__Versions::Versions, "ns1:Version"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Versions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Versions, SOAP_TYPE_ns1__Versions, sizeof(ns1__Versions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__Versions * SOAP_FMAC2 soap_instantiate_ns1__Versions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Versions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__Versions *p;
	size_t k = sizeof(ns1__Versions);
	if (n < 0)
	{	p = SOAP_NEW(ns1__Versions);
		if (p)
			((ns1__Versions*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__Versions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__Versions*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__Versions location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__Versions, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__Versions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__Versions(soap, tag ? tag : "ns1:Versions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Versions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Versions(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Versions * SOAP_FMAC4 soap_get_ns1__Versions(struct soap *soap, ns1__Versions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Versions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__Parameters::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__Parameter(soap, &this->ns1__Parameters::Parameters);
	/* transient soap skipped */
}

void ns1__Parameters::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__Parameter(soap, &this->ns1__Parameters::Parameters);
#endif
}

int ns1__Parameters::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Parameters(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Parameters(struct soap *soap, const char *tag, int id, const ns1__Parameters *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Parameters), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__Parameter(soap, "Parameters", -1, &a->ns1__Parameters::Parameters, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__Parameters::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Parameters(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Parameters * SOAP_FMAC4 soap_in_ns1__Parameters(struct soap *soap, const char *tag, ns1__Parameters *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Parameters *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Parameters, sizeof(ns1__Parameters), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__Parameters)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__Parameters *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__Parameter(soap, "Parameters", &a->ns1__Parameters::Parameters, "ns1:Parameter"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Parameters *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Parameters, SOAP_TYPE_ns1__Parameters, sizeof(ns1__Parameters), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__Parameters * SOAP_FMAC2 soap_instantiate_ns1__Parameters(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Parameters(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__Parameters *p;
	size_t k = sizeof(ns1__Parameters);
	if (n < 0)
	{	p = SOAP_NEW(ns1__Parameters);
		if (p)
			((ns1__Parameters*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__Parameters, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__Parameters*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__Parameters location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__Parameters, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__Parameters::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__Parameters(soap, tag ? tag : "ns1:Parameters", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Parameters::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Parameters(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Parameters * SOAP_FMAC4 soap_get_ns1__Parameters(struct soap *soap, ns1__Parameters *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Parameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__Parameter::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__Parameter::key = NULL;
	this->ns1__Parameter::name = NULL;
	this->ns1__Parameter::value = NULL;
	/* transient soap skipped */
}

void ns1__Parameter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns1__Parameter::key);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Parameter::name);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Parameter::value);
#endif
}

int ns1__Parameter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Parameter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Parameter(struct soap *soap, const char *tag, int id, const ns1__Parameter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Parameter), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "key", -1, &a->ns1__Parameter::key, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "name", -1, &a->ns1__Parameter::name, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "value", -1, &a->ns1__Parameter::value, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__Parameter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Parameter(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Parameter * SOAP_FMAC4 soap_in_ns1__Parameter(struct soap *soap, const char *tag, ns1__Parameter *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Parameter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Parameter, sizeof(ns1__Parameter), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__Parameter)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__Parameter *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_key1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_value1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_key1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "key", &a->ns1__Parameter::key, "xsd:string"))
				{	soap_flag_key1--;
					continue;
				}
			}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "name", &a->ns1__Parameter::name, "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			}
			if (soap_flag_value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "value", &a->ns1__Parameter::value, "xsd:string"))
				{	soap_flag_value1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Parameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Parameter, SOAP_TYPE_ns1__Parameter, sizeof(ns1__Parameter), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__Parameter * SOAP_FMAC2 soap_instantiate_ns1__Parameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Parameter(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__Parameter *p;
	size_t k = sizeof(ns1__Parameter);
	if (n < 0)
	{	p = SOAP_NEW(ns1__Parameter);
		if (p)
			((ns1__Parameter*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__Parameter, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__Parameter*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__Parameter location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__Parameter, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__Parameter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__Parameter(soap, tag ? tag : "ns1:Parameter", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Parameter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Parameter(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Parameter * SOAP_FMAC4 soap_get_ns1__Parameter(struct soap *soap, ns1__Parameter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Parameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__Version::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__Version::name = NULL;
	this->ns1__Version::version = NULL;
	/* transient soap skipped */
}

void ns1__Version::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns1__Version::name);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Version::version);
#endif
}

int ns1__Version::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Version(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Version(struct soap *soap, const char *tag, int id, const ns1__Version *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Version), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "name", -1, &a->ns1__Version::name, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "version", -1, &a->ns1__Version::version, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__Version::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Version(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Version * SOAP_FMAC4 soap_in_ns1__Version(struct soap *soap, const char *tag, ns1__Version *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Version *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Version, sizeof(ns1__Version), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__Version)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__Version *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_name1 = 1;
	size_t soap_flag_version1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "name", &a->ns1__Version::name, "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			}
			if (soap_flag_version1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "version", &a->ns1__Version::version, "xsd:string"))
				{	soap_flag_version1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Version *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Version, SOAP_TYPE_ns1__Version, sizeof(ns1__Version), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__Version * SOAP_FMAC2 soap_instantiate_ns1__Version(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Version(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__Version *p;
	size_t k = sizeof(ns1__Version);
	if (n < 0)
	{	p = SOAP_NEW(ns1__Version);
		if (p)
			((ns1__Version*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__Version, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__Version*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__Version location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__Version, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__Version::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__Version(soap, tag ? tag : "ns1:Version", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Version::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Version(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Version * SOAP_FMAC4 soap_get_ns1__Version(struct soap *soap, ns1__Version *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Version(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__Robot::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__Kinematic(soap, &this->ns1__Robot::kinematic);
	this->ns1__Robot::arm = NULL;
	this->ns1__Robot::tuning = NULL;
	soap_default_ns1__MountType(soap, &this->ns1__Robot::mountType);
	soap_default_ns1__LengthAxis3(soap, &this->ns1__Robot::lengthAxis3);
	soap_default_ns1__DiameterAxis3(soap, &this->ns1__Robot::diameterAxis3);
	/* transient soap skipped */
}

void ns1__Robot::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns1__Robot::arm);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Robot::tuning);
#endif
}

int ns1__Robot::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Robot(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Robot(struct soap *soap, const char *tag, int id, const ns1__Robot *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Robot), type))
		return soap->error;
	if (soap_out_ns1__Kinematic(soap, "kinematic", -1, &a->ns1__Robot::kinematic, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arm", -1, &a->ns1__Robot::arm, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tuning", -1, &a->ns1__Robot::tuning, ""))
		return soap->error;
	if (soap_out_ns1__MountType(soap, "mountType", -1, &a->ns1__Robot::mountType, ""))
		return soap->error;
	if (soap_out_ns1__LengthAxis3(soap, "lengthAxis3", -1, &a->ns1__Robot::lengthAxis3, ""))
		return soap->error;
	if (soap_out_ns1__DiameterAxis3(soap, "diameterAxis3", -1, &a->ns1__Robot::diameterAxis3, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__Robot::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Robot(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Robot * SOAP_FMAC4 soap_in_ns1__Robot(struct soap *soap, const char *tag, ns1__Robot *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Robot *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Robot, sizeof(ns1__Robot), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__Robot)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__Robot *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_kinematic1 = 1;
	size_t soap_flag_arm1 = 1;
	size_t soap_flag_tuning1 = 1;
	size_t soap_flag_mountType1 = 1;
	size_t soap_flag_lengthAxis31 = 1;
	size_t soap_flag_diameterAxis31 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_kinematic1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns1__Kinematic(soap, "kinematic", &a->ns1__Robot::kinematic, "ns1:Kinematic"))
				{	soap_flag_kinematic1--;
					continue;
				}
			}
			if (soap_flag_arm1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "arm", &a->ns1__Robot::arm, "xsd:string"))
				{	soap_flag_arm1--;
					continue;
				}
			}
			if (soap_flag_tuning1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tuning", &a->ns1__Robot::tuning, "xsd:string"))
				{	soap_flag_tuning1--;
					continue;
				}
			}
			if (soap_flag_mountType1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns1__MountType(soap, "mountType", &a->ns1__Robot::mountType, "ns1:MountType"))
				{	soap_flag_mountType1--;
					continue;
				}
			}
			if (soap_flag_lengthAxis31 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns1__LengthAxis3(soap, "lengthAxis3", &a->ns1__Robot::lengthAxis3, "ns1:LengthAxis3"))
				{	soap_flag_lengthAxis31--;
					continue;
				}
			}
			if (soap_flag_diameterAxis31 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns1__DiameterAxis3(soap, "diameterAxis3", &a->ns1__Robot::diameterAxis3, "ns1:DiameterAxis3"))
				{	soap_flag_diameterAxis31--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_kinematic1 > 0 || soap_flag_mountType1 > 0 || soap_flag_lengthAxis31 > 0 || soap_flag_diameterAxis31 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__Robot *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Robot, SOAP_TYPE_ns1__Robot, sizeof(ns1__Robot), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__Robot * SOAP_FMAC2 soap_instantiate_ns1__Robot(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Robot(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__Robot *p;
	size_t k = sizeof(ns1__Robot);
	if (n < 0)
	{	p = SOAP_NEW(ns1__Robot);
		if (p)
			((ns1__Robot*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__Robot, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__Robot*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__Robot location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__Robot, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__Robot::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__Robot(soap, tag ? tag : "ns1:Robot", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Robot::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Robot(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Robot * SOAP_FMAC4 soap_get_ns1__Robot(struct soap *soap, ns1__Robot *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Robot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__CartesianPos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_double(soap, &this->ns1__CartesianPos::x);
	soap_default_double(soap, &this->ns1__CartesianPos::y);
	soap_default_double(soap, &this->ns1__CartesianPos::z);
	soap_default_double(soap, &this->ns1__CartesianPos::rx);
	soap_default_double(soap, &this->ns1__CartesianPos::ry);
	soap_default_double(soap, &this->ns1__CartesianPos::rz);
	/* transient soap skipped */
}

void ns1__CartesianPos::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns1__CartesianPos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CartesianPos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CartesianPos(struct soap *soap, const char *tag, int id, const ns1__CartesianPos *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CartesianPos), type))
		return soap->error;
	if (soap_out_double(soap, "x", -1, &a->ns1__CartesianPos::x, ""))
		return soap->error;
	if (soap_out_double(soap, "y", -1, &a->ns1__CartesianPos::y, ""))
		return soap->error;
	if (soap_out_double(soap, "z", -1, &a->ns1__CartesianPos::z, ""))
		return soap->error;
	if (soap_out_double(soap, "rx", -1, &a->ns1__CartesianPos::rx, ""))
		return soap->error;
	if (soap_out_double(soap, "ry", -1, &a->ns1__CartesianPos::ry, ""))
		return soap->error;
	if (soap_out_double(soap, "rz", -1, &a->ns1__CartesianPos::rz, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CartesianPos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CartesianPos(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CartesianPos * SOAP_FMAC4 soap_in_ns1__CartesianPos(struct soap *soap, const char *tag, ns1__CartesianPos *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CartesianPos *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CartesianPos, sizeof(ns1__CartesianPos), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__CartesianPos)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__CartesianPos *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_x1 = 1;
	size_t soap_flag_y1 = 1;
	size_t soap_flag_z1 = 1;
	size_t soap_flag_rx1 = 1;
	size_t soap_flag_ry1 = 1;
	size_t soap_flag_rz1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_x1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "x", &a->ns1__CartesianPos::x, "xsd:double"))
				{	soap_flag_x1--;
					continue;
				}
			}
			if (soap_flag_y1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "y", &a->ns1__CartesianPos::y, "xsd:double"))
				{	soap_flag_y1--;
					continue;
				}
			}
			if (soap_flag_z1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "z", &a->ns1__CartesianPos::z, "xsd:double"))
				{	soap_flag_z1--;
					continue;
				}
			}
			if (soap_flag_rx1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "rx", &a->ns1__CartesianPos::rx, "xsd:double"))
				{	soap_flag_rx1--;
					continue;
				}
			}
			if (soap_flag_ry1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "ry", &a->ns1__CartesianPos::ry, "xsd:double"))
				{	soap_flag_ry1--;
					continue;
				}
			}
			if (soap_flag_rz1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_double(soap, "rz", &a->ns1__CartesianPos::rz, "xsd:double"))
				{	soap_flag_rz1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_x1 > 0 || soap_flag_y1 > 0 || soap_flag_z1 > 0 || soap_flag_rx1 > 0 || soap_flag_ry1 > 0 || soap_flag_rz1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__CartesianPos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CartesianPos, SOAP_TYPE_ns1__CartesianPos, sizeof(ns1__CartesianPos), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__CartesianPos * SOAP_FMAC2 soap_instantiate_ns1__CartesianPos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CartesianPos(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__CartesianPos *p;
	size_t k = sizeof(ns1__CartesianPos);
	if (n < 0)
	{	p = SOAP_NEW(ns1__CartesianPos);
		if (p)
			((ns1__CartesianPos*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__CartesianPos, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__CartesianPos*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__CartesianPos location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__CartesianPos, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__CartesianPos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__CartesianPos(soap, tag ? tag : "ns1:CartesianPos", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CartesianPos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CartesianPos(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CartesianPos * SOAP_FMAC4 soap_get_ns1__CartesianPos(struct soap *soap, ns1__CartesianPos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CartesianPos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__JointPos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfdouble(soap, &this->ns1__JointPos::item);
	/* transient soap skipped */
}

void ns1__JointPos::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfdouble(soap, &this->ns1__JointPos::item);
#endif
}

int ns1__JointPos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__JointPos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__JointPos(struct soap *soap, const char *tag, int id, const ns1__JointPos *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__JointPos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfdouble(soap, "item", -1, &a->ns1__JointPos::item, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__JointPos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__JointPos(soap, tag, this, type);
}

SOAP_FMAC3 ns1__JointPos * SOAP_FMAC4 soap_in_ns1__JointPos(struct soap *soap, const char *tag, ns1__JointPos *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__JointPos *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__JointPos, sizeof(ns1__JointPos), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__JointPos)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__JointPos *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfdouble(soap, "item", &a->ns1__JointPos::item, "xsd:double"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->ns1__JointPos::item.size() < 1 || a->ns1__JointPos::item.size() > 100))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__JointPos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__JointPos, SOAP_TYPE_ns1__JointPos, sizeof(ns1__JointPos), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__JointPos * SOAP_FMAC2 soap_instantiate_ns1__JointPos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__JointPos(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__JointPos *p;
	size_t k = sizeof(ns1__JointPos);
	if (n < 0)
	{	p = SOAP_NEW(ns1__JointPos);
		if (p)
			((ns1__JointPos*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__JointPos, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__JointPos*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__JointPos location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__JointPos, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__JointPos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__JointPos(soap, tag ? tag : "ns1:JointPos", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__JointPos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__JointPos(soap, this, tag, type);
}

SOAP_FMAC3 ns1__JointPos * SOAP_FMAC4 soap_get_ns1__JointPos(struct soap *soap, ns1__JointPos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__JointPos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ServerException::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__ServerExceptionCode(soap, &this->ns1__ServerException::code);
	this->ns1__ServerException::description = NULL;
	/* transient soap skipped */
}

void ns1__ServerException::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns1__ServerException::description);
#endif
}

int ns1__ServerException::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ServerException(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ServerException(struct soap *soap, const char *tag, int id, const ns1__ServerException *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ServerException), type))
		return soap->error;
	if (soap_out_ns1__ServerExceptionCode(soap, "code", -1, &a->ns1__ServerException::code, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "description", -1, &a->ns1__ServerException::description, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ServerException::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ServerException(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ServerException * SOAP_FMAC4 soap_in_ns1__ServerException(struct soap *soap, const char *tag, ns1__ServerException *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ServerException *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ServerException, sizeof(ns1__ServerException), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ServerException)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ServerException *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_code1 = 1;
	size_t soap_flag_description1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_code1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns1__ServerExceptionCode(soap, "code", &a->ns1__ServerException::code, "ns1:ServerExceptionCode"))
				{	soap_flag_code1--;
					continue;
				}
			}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "description", &a->ns1__ServerException::description, "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_code1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__ServerException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ServerException, SOAP_TYPE_ns1__ServerException, sizeof(ns1__ServerException), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ServerException * SOAP_FMAC2 soap_instantiate_ns1__ServerException(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ServerException(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ServerException *p;
	size_t k = sizeof(ns1__ServerException);
	if (n < 0)
	{	p = SOAP_NEW(ns1__ServerException);
		if (p)
			((ns1__ServerException*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__ServerException, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__ServerException*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ServerException location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__ServerException, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__ServerException::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ServerException(soap, tag ? tag : "ns1:ServerException", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ServerException::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ServerException(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ServerException * SOAP_FMAC4 soap_get_ns1__ServerException(struct soap *soap, ns1__ServerException *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ServerException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__hexBinary::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__ptr = NULL;
	this->__size = 0;
}

void xsd__hexBinary::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr)
		(void)soap_array_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_xsd__hexBinary);
#endif
}

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xsd__hexBinary2s(struct soap *soap, xsd__hexBinary a)
{
	return soap_s2hex(soap, a.__ptr, NULL, a.__size);
}

int xsd__hexBinary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_xsd__hexBinary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__hexBinary(struct soap *soap, const char *tag, int id, const xsd__hexBinary *a, const char *type)
{
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_xsd__hexBinary, NULL);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_puthex(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__hexBinary(struct soap *soap, const char *s, xsd__hexBinary *a)
{
	a->__ptr = (unsigned char*)soap_hex2s(soap, s, NULL, 0, &a->__size);
	if (!a->__ptr)
		return soap->error;
	return SOAP_OK;
}

void *xsd__hexBinary::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__hexBinary(soap, tag, this, type);
}

SOAP_FMAC3 xsd__hexBinary * SOAP_FMAC4 soap_in_xsd__hexBinary(struct soap *soap, const char *tag, xsd__hexBinary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":hexBinary"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__hexBinary *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__hexBinary, sizeof(xsd__hexBinary), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		a->__ptr = soap_gethex(soap, &a->__size);
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (xsd__hexBinary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__hexBinary, SOAP_TYPE_xsd__hexBinary, sizeof(xsd__hexBinary), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 xsd__hexBinary * SOAP_FMAC2 soap_instantiate_xsd__hexBinary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__hexBinary(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__hexBinary *p;
	size_t k = sizeof(xsd__hexBinary);
	if (n < 0)
	{	p = SOAP_NEW(xsd__hexBinary);
	}
	else
	{	p = SOAP_NEW_ARRAY(xsd__hexBinary, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__hexBinary location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_xsd__hexBinary, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int xsd__hexBinary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__hexBinary(soap, tag ? tag : "xsd:hexBinary", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__hexBinary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__hexBinary(soap, this, tag, type);
}

SOAP_FMAC3 xsd__hexBinary * SOAP_FMAC4 soap_get_xsd__hexBinary(struct soap *soap, xsd__hexBinary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__hexBinary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__base64Binary::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__ptr = NULL;
	this->__size = 0;
	this->id = NULL;
	this->type = NULL;
	this->options = NULL;
}

void xsd__base64Binary::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr)
		(void)soap_attachment_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_xsd__base64Binary, this->id, this->type);
#endif
}

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xsd__base64Binary2s(struct soap *soap, xsd__base64Binary a)
{
	return soap_s2base64(soap, a.__ptr, NULL, a.__size);
}

int xsd__base64Binary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_xsd__base64Binary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary(struct soap *soap, const char *tag, int id, const xsd__base64Binary *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, a->__ptr, a->__size, a->id, a->type, a->options, type, SOAP_TYPE_xsd__base64Binary);
#else
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_xsd__base64Binary, NULL);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__base64Binary(struct soap *soap, const char *s, xsd__base64Binary *a)
{
	a->__ptr = (unsigned char*)soap_base642s(soap, s, NULL, 0, &a->__size);
	if (!a->__ptr)
		return soap->error;
	return SOAP_OK;
}

void *xsd__base64Binary::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__base64Binary(soap, tag, this, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_in_xsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__base64Binary *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_attachment_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__base64Binary, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 soap_instantiate_xsd__base64Binary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__base64Binary(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__base64Binary *p;
	size_t k = sizeof(xsd__base64Binary);
	if (n < 0)
	{	p = SOAP_NEW(xsd__base64Binary);
		if (p)
			((xsd__base64Binary*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(xsd__base64Binary, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((xsd__base64Binary*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__base64Binary location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_xsd__base64Binary, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int xsd__base64Binary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__base64Binary(soap, tag ? tag : "xsd:base64Binary", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__base64Binary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__base64Binary(soap, this, tag, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap *soap, xsd__base64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anyURI(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__anyURI), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__anyURI(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anyURI, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 4, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anyURI, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__anyURI, SOAP_TYPE_xsd__anyURI, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyURI(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__anyURI(soap, tag ? tag : "xsd:anyURI", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__anyURI(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_std__string, SOAP_TYPE_std__string, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::string *p;
	size_t k = sizeof(std::string);
	if (n < 0)
	{	p = SOAP_NEW(std::string);
	}
	else
	{	p = SOAP_NEW_ARRAY(std::string, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::string location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__string, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_std__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Fault *p;
	size_t k = sizeof(struct SOAP_ENV__Fault);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Fault);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Fault location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Reason *p;
	size_t k = sizeof(struct SOAP_ENV__Reason);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Reason);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Reason location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Code *p;
	size_t k = sizeof(struct SOAP_ENV__Code);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Code);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Code location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__getProject(struct soap *soap, struct __ns7__getProject *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns7__getProject = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__getProject(struct soap *soap, const struct __ns7__getProject *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns7__getProject(soap, &a->ns7__getProject);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__getProject(struct soap *soap, const char *tag, int id, const struct __ns7__getProject *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns7__getProject(soap, "ns7:getProject", -1, &a->ns7__getProject, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__getProject * SOAP_FMAC4 soap_in___ns7__getProject(struct soap *soap, const char *tag, struct __ns7__getProject *a, const char *type)
{
	size_t soap_flag_ns7__getProject = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns7__getProject *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__getProject, sizeof(struct __ns7__getProject), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__getProject(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns7__getProject && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns7__getProject(soap, "ns7:getProject", &a->ns7__getProject, ""))
				{	soap_flag_ns7__getProject--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns7__getProject * SOAP_FMAC2 soap_instantiate___ns7__getProject(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__getProject(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns7__getProject *p;
	size_t k = sizeof(struct __ns7__getProject);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns7__getProject);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns7__getProject, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns7__getProject location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns7__getProject, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__getProject(struct soap *soap, const struct __ns7__getProject *a, const char *tag, const char *type)
{
	if (soap_out___ns7__getProject(soap, tag ? tag : "-ns7:getProject", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__getProject * SOAP_FMAC4 soap_get___ns7__getProject(struct soap *soap, struct __ns7__getProject *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__getProject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__getRobotDhParameters(struct soap *soap, struct __ns7__getRobotDhParameters *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns7__getRobotDhParameters = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__getRobotDhParameters(struct soap *soap, const struct __ns7__getRobotDhParameters *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns7__getRobotDhParameters(soap, &a->ns7__getRobotDhParameters);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__getRobotDhParameters(struct soap *soap, const char *tag, int id, const struct __ns7__getRobotDhParameters *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns7__getRobotDhParameters(soap, "ns7:getRobotDhParameters", -1, &a->ns7__getRobotDhParameters, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__getRobotDhParameters * SOAP_FMAC4 soap_in___ns7__getRobotDhParameters(struct soap *soap, const char *tag, struct __ns7__getRobotDhParameters *a, const char *type)
{
	size_t soap_flag_ns7__getRobotDhParameters = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns7__getRobotDhParameters *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__getRobotDhParameters, sizeof(struct __ns7__getRobotDhParameters), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__getRobotDhParameters(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns7__getRobotDhParameters && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns7__getRobotDhParameters(soap, "ns7:getRobotDhParameters", &a->ns7__getRobotDhParameters, ""))
				{	soap_flag_ns7__getRobotDhParameters--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns7__getRobotDhParameters * SOAP_FMAC2 soap_instantiate___ns7__getRobotDhParameters(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__getRobotDhParameters(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns7__getRobotDhParameters *p;
	size_t k = sizeof(struct __ns7__getRobotDhParameters);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns7__getRobotDhParameters);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns7__getRobotDhParameters, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns7__getRobotDhParameters location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns7__getRobotDhParameters, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__getRobotDhParameters(struct soap *soap, const struct __ns7__getRobotDhParameters *a, const char *tag, const char *type)
{
	if (soap_out___ns7__getRobotDhParameters(soap, tag ? tag : "-ns7:getRobotDhParameters", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__getRobotDhParameters * SOAP_FMAC4 soap_get___ns7__getRobotDhParameters(struct soap *soap, struct __ns7__getRobotDhParameters *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__getRobotDhParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__getAllPhysicalIos(struct soap *soap, struct __ns7__getAllPhysicalIos *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns7__getAllPhysicalIos = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__getAllPhysicalIos(struct soap *soap, const struct __ns7__getAllPhysicalIos *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns7__getAllPhysicalIos(soap, &a->ns7__getAllPhysicalIos);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__getAllPhysicalIos(struct soap *soap, const char *tag, int id, const struct __ns7__getAllPhysicalIos *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns7__getAllPhysicalIos(soap, "ns7:getAllPhysicalIos", -1, &a->ns7__getAllPhysicalIos, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__getAllPhysicalIos * SOAP_FMAC4 soap_in___ns7__getAllPhysicalIos(struct soap *soap, const char *tag, struct __ns7__getAllPhysicalIos *a, const char *type)
{
	size_t soap_flag_ns7__getAllPhysicalIos = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns7__getAllPhysicalIos *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__getAllPhysicalIos, sizeof(struct __ns7__getAllPhysicalIos), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__getAllPhysicalIos(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns7__getAllPhysicalIos && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns7__getAllPhysicalIos(soap, "ns7:getAllPhysicalIos", &a->ns7__getAllPhysicalIos, ""))
				{	soap_flag_ns7__getAllPhysicalIos--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns7__getAllPhysicalIos * SOAP_FMAC2 soap_instantiate___ns7__getAllPhysicalIos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__getAllPhysicalIos(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns7__getAllPhysicalIos *p;
	size_t k = sizeof(struct __ns7__getAllPhysicalIos);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns7__getAllPhysicalIos);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns7__getAllPhysicalIos, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns7__getAllPhysicalIos location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns7__getAllPhysicalIos, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__getAllPhysicalIos(struct soap *soap, const struct __ns7__getAllPhysicalIos *a, const char *tag, const char *type)
{
	if (soap_out___ns7__getAllPhysicalIos(soap, tag ? tag : "-ns7:getAllPhysicalIos", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__getAllPhysicalIos * SOAP_FMAC4 soap_get___ns7__getAllPhysicalIos(struct soap *soap, struct __ns7__getAllPhysicalIos *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__getAllPhysicalIos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__unlockAllIos(struct soap *soap, struct __ns7__unlockAllIos *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns7__unlockAllIos = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__unlockAllIos(struct soap *soap, const struct __ns7__unlockAllIos *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns7__unlockAllIos(soap, &a->ns7__unlockAllIos);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__unlockAllIos(struct soap *soap, const char *tag, int id, const struct __ns7__unlockAllIos *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns7__unlockAllIos(soap, "ns7:unlockAllIos", -1, &a->ns7__unlockAllIos, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__unlockAllIos * SOAP_FMAC4 soap_in___ns7__unlockAllIos(struct soap *soap, const char *tag, struct __ns7__unlockAllIos *a, const char *type)
{
	size_t soap_flag_ns7__unlockAllIos = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns7__unlockAllIos *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__unlockAllIos, sizeof(struct __ns7__unlockAllIos), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__unlockAllIos(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns7__unlockAllIos && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns7__unlockAllIos(soap, "ns7:unlockAllIos", &a->ns7__unlockAllIos, ""))
				{	soap_flag_ns7__unlockAllIos--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns7__unlockAllIos * SOAP_FMAC2 soap_instantiate___ns7__unlockAllIos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__unlockAllIos(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns7__unlockAllIos *p;
	size_t k = sizeof(struct __ns7__unlockAllIos);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns7__unlockAllIos);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns7__unlockAllIos, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns7__unlockAllIos location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns7__unlockAllIos, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__unlockAllIos(struct soap *soap, const struct __ns7__unlockAllIos *a, const char *tag, const char *type)
{
	if (soap_out___ns7__unlockAllIos(soap, tag ? tag : "-ns7:unlockAllIos", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__unlockAllIos * SOAP_FMAC4 soap_get___ns7__unlockAllIos(struct soap *soap, struct __ns7__unlockAllIos *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__unlockAllIos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__lockAllIos(struct soap *soap, struct __ns7__lockAllIos *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns7__lockAllIos = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__lockAllIos(struct soap *soap, const struct __ns7__lockAllIos *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns7__lockAllIos(soap, &a->ns7__lockAllIos);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__lockAllIos(struct soap *soap, const char *tag, int id, const struct __ns7__lockAllIos *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns7__lockAllIos(soap, "ns7:lockAllIos", -1, &a->ns7__lockAllIos, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__lockAllIos * SOAP_FMAC4 soap_in___ns7__lockAllIos(struct soap *soap, const char *tag, struct __ns7__lockAllIos *a, const char *type)
{
	size_t soap_flag_ns7__lockAllIos = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns7__lockAllIos *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__lockAllIos, sizeof(struct __ns7__lockAllIos), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__lockAllIos(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns7__lockAllIos && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns7__lockAllIos(soap, "ns7:lockAllIos", &a->ns7__lockAllIos, ""))
				{	soap_flag_ns7__lockAllIos--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns7__lockAllIos * SOAP_FMAC2 soap_instantiate___ns7__lockAllIos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__lockAllIos(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns7__lockAllIos *p;
	size_t k = sizeof(struct __ns7__lockAllIos);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns7__lockAllIos);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns7__lockAllIos, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns7__lockAllIos location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns7__lockAllIos, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__lockAllIos(struct soap *soap, const struct __ns7__lockAllIos *a, const char *tag, const char *type)
{
	if (soap_out___ns7__lockAllIos(soap, tag ? tag : "-ns7:lockAllIos", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__lockAllIos * SOAP_FMAC4 soap_get___ns7__lockAllIos(struct soap *soap, struct __ns7__lockAllIos *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__lockAllIos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__unlockIos(struct soap *soap, struct __ns7__unlockIos *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns7__unlockIos = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__unlockIos(struct soap *soap, const struct __ns7__unlockIos *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns7__unlockIos(soap, &a->ns7__unlockIos);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__unlockIos(struct soap *soap, const char *tag, int id, const struct __ns7__unlockIos *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns7__unlockIos(soap, "ns7:unlockIos", -1, &a->ns7__unlockIos, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__unlockIos * SOAP_FMAC4 soap_in___ns7__unlockIos(struct soap *soap, const char *tag, struct __ns7__unlockIos *a, const char *type)
{
	size_t soap_flag_ns7__unlockIos = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns7__unlockIos *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__unlockIos, sizeof(struct __ns7__unlockIos), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__unlockIos(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns7__unlockIos && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns7__unlockIos(soap, "ns7:unlockIos", &a->ns7__unlockIos, ""))
				{	soap_flag_ns7__unlockIos--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns7__unlockIos * SOAP_FMAC2 soap_instantiate___ns7__unlockIos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__unlockIos(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns7__unlockIos *p;
	size_t k = sizeof(struct __ns7__unlockIos);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns7__unlockIos);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns7__unlockIos, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns7__unlockIos location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns7__unlockIos, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__unlockIos(struct soap *soap, const struct __ns7__unlockIos *a, const char *tag, const char *type)
{
	if (soap_out___ns7__unlockIos(soap, tag ? tag : "-ns7:unlockIos", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__unlockIos * SOAP_FMAC4 soap_get___ns7__unlockIos(struct soap *soap, struct __ns7__unlockIos *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__unlockIos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__lockIos(struct soap *soap, struct __ns7__lockIos *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns7__lockIos = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__lockIos(struct soap *soap, const struct __ns7__lockIos *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns7__lockIos(soap, &a->ns7__lockIos);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__lockIos(struct soap *soap, const char *tag, int id, const struct __ns7__lockIos *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns7__lockIos(soap, "ns7:lockIos", -1, &a->ns7__lockIos, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__lockIos * SOAP_FMAC4 soap_in___ns7__lockIos(struct soap *soap, const char *tag, struct __ns7__lockIos *a, const char *type)
{
	size_t soap_flag_ns7__lockIos = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns7__lockIos *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__lockIos, sizeof(struct __ns7__lockIos), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__lockIos(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns7__lockIos && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns7__lockIos(soap, "ns7:lockIos", &a->ns7__lockIos, ""))
				{	soap_flag_ns7__lockIos--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns7__lockIos * SOAP_FMAC2 soap_instantiate___ns7__lockIos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__lockIos(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns7__lockIos *p;
	size_t k = sizeof(struct __ns7__lockIos);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns7__lockIos);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns7__lockIos, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns7__lockIos location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns7__lockIos, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__lockIos(struct soap *soap, const struct __ns7__lockIos *a, const char *tag, const char *type)
{
	if (soap_out___ns7__lockIos(soap, tag ? tag : "-ns7:lockIos", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__lockIos * SOAP_FMAC4 soap_get___ns7__lockIos(struct soap *soap, struct __ns7__lockIos *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__lockIos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__writeIos(struct soap *soap, struct __ns7__writeIos *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns7__writeIos = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__writeIos(struct soap *soap, const struct __ns7__writeIos *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns7__writeIos(soap, &a->ns7__writeIos);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__writeIos(struct soap *soap, const char *tag, int id, const struct __ns7__writeIos *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns7__writeIos(soap, "ns7:writeIos", -1, &a->ns7__writeIos, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__writeIos * SOAP_FMAC4 soap_in___ns7__writeIos(struct soap *soap, const char *tag, struct __ns7__writeIos *a, const char *type)
{
	size_t soap_flag_ns7__writeIos = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns7__writeIos *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__writeIos, sizeof(struct __ns7__writeIos), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__writeIos(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns7__writeIos && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns7__writeIos(soap, "ns7:writeIos", &a->ns7__writeIos, ""))
				{	soap_flag_ns7__writeIos--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns7__writeIos * SOAP_FMAC2 soap_instantiate___ns7__writeIos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__writeIos(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns7__writeIos *p;
	size_t k = sizeof(struct __ns7__writeIos);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns7__writeIos);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns7__writeIos, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns7__writeIos location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns7__writeIos, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__writeIos(struct soap *soap, const struct __ns7__writeIos *a, const char *tag, const char *type)
{
	if (soap_out___ns7__writeIos(soap, tag ? tag : "-ns7:writeIos", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__writeIos * SOAP_FMAC4 soap_get___ns7__writeIos(struct soap *soap, struct __ns7__writeIos *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__writeIos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__readIos(struct soap *soap, struct __ns7__readIos *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns7__readIos = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__readIos(struct soap *soap, const struct __ns7__readIos *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns7__readIos(soap, &a->ns7__readIos);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__readIos(struct soap *soap, const char *tag, int id, const struct __ns7__readIos *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns7__readIos(soap, "ns7:readIos", -1, &a->ns7__readIos, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__readIos * SOAP_FMAC4 soap_in___ns7__readIos(struct soap *soap, const char *tag, struct __ns7__readIos *a, const char *type)
{
	size_t soap_flag_ns7__readIos = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns7__readIos *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__readIos, sizeof(struct __ns7__readIos), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__readIos(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns7__readIos && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns7__readIos(soap, "ns7:readIos", &a->ns7__readIos, ""))
				{	soap_flag_ns7__readIos--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns7__readIos * SOAP_FMAC2 soap_instantiate___ns7__readIos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__readIos(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns7__readIos *p;
	size_t k = sizeof(struct __ns7__readIos);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns7__readIos);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns7__readIos, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns7__readIos location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns7__readIos, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__readIos(struct soap *soap, const struct __ns7__readIos *a, const char *tag, const char *type)
{
	if (soap_out___ns7__readIos(soap, tag ? tag : "-ns7:readIos", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__readIos * SOAP_FMAC4 soap_get___ns7__readIos(struct soap *soap, struct __ns7__readIos *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__readIos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__replaceLine(struct soap *soap, struct __ns7__replaceLine *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns7__replaceLine = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__replaceLine(struct soap *soap, const struct __ns7__replaceLine *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns7__replaceLine(soap, &a->ns7__replaceLine);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__replaceLine(struct soap *soap, const char *tag, int id, const struct __ns7__replaceLine *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns7__replaceLine(soap, "ns7:replaceLine", -1, &a->ns7__replaceLine, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__replaceLine * SOAP_FMAC4 soap_in___ns7__replaceLine(struct soap *soap, const char *tag, struct __ns7__replaceLine *a, const char *type)
{
	size_t soap_flag_ns7__replaceLine = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns7__replaceLine *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__replaceLine, sizeof(struct __ns7__replaceLine), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__replaceLine(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns7__replaceLine && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns7__replaceLine(soap, "ns7:replaceLine", &a->ns7__replaceLine, ""))
				{	soap_flag_ns7__replaceLine--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns7__replaceLine * SOAP_FMAC2 soap_instantiate___ns7__replaceLine(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__replaceLine(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns7__replaceLine *p;
	size_t k = sizeof(struct __ns7__replaceLine);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns7__replaceLine);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns7__replaceLine, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns7__replaceLine location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns7__replaceLine, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__replaceLine(struct soap *soap, const struct __ns7__replaceLine *a, const char *tag, const char *type)
{
	if (soap_out___ns7__replaceLine(soap, tag ? tag : "-ns7:replaceLine", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__replaceLine * SOAP_FMAC4 soap_get___ns7__replaceLine(struct soap *soap, struct __ns7__replaceLine *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__replaceLine(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__setCurrentInstruction(struct soap *soap, struct __ns7__setCurrentInstruction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns7__setCurrentInstruction = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__setCurrentInstruction(struct soap *soap, const struct __ns7__setCurrentInstruction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns7__setCurrentInstruction(soap, &a->ns7__setCurrentInstruction);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__setCurrentInstruction(struct soap *soap, const char *tag, int id, const struct __ns7__setCurrentInstruction *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns7__setCurrentInstruction(soap, "ns7:setCurrentInstruction", -1, &a->ns7__setCurrentInstruction, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__setCurrentInstruction * SOAP_FMAC4 soap_in___ns7__setCurrentInstruction(struct soap *soap, const char *tag, struct __ns7__setCurrentInstruction *a, const char *type)
{
	size_t soap_flag_ns7__setCurrentInstruction = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns7__setCurrentInstruction *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__setCurrentInstruction, sizeof(struct __ns7__setCurrentInstruction), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__setCurrentInstruction(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns7__setCurrentInstruction && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns7__setCurrentInstruction(soap, "ns7:setCurrentInstruction", &a->ns7__setCurrentInstruction, ""))
				{	soap_flag_ns7__setCurrentInstruction--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns7__setCurrentInstruction * SOAP_FMAC2 soap_instantiate___ns7__setCurrentInstruction(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__setCurrentInstruction(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns7__setCurrentInstruction *p;
	size_t k = sizeof(struct __ns7__setCurrentInstruction);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns7__setCurrentInstruction);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns7__setCurrentInstruction, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns7__setCurrentInstruction location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns7__setCurrentInstruction, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__setCurrentInstruction(struct soap *soap, const struct __ns7__setCurrentInstruction *a, const char *tag, const char *type)
{
	if (soap_out___ns7__setCurrentInstruction(soap, tag ? tag : "-ns7:setCurrentInstruction", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__setCurrentInstruction * SOAP_FMAC4 soap_get___ns7__setCurrentInstruction(struct soap *soap, struct __ns7__setCurrentInstruction *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__setCurrentInstruction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__setProjectAsModified(struct soap *soap, struct __ns7__setProjectAsModified *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns7__setProjectAsModified = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__setProjectAsModified(struct soap *soap, const struct __ns7__setProjectAsModified *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns7__setProjectAsModified(soap, &a->ns7__setProjectAsModified);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__setProjectAsModified(struct soap *soap, const char *tag, int id, const struct __ns7__setProjectAsModified *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns7__setProjectAsModified(soap, "ns7:setProjectAsModified", -1, &a->ns7__setProjectAsModified, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__setProjectAsModified * SOAP_FMAC4 soap_in___ns7__setProjectAsModified(struct soap *soap, const char *tag, struct __ns7__setProjectAsModified *a, const char *type)
{
	size_t soap_flag_ns7__setProjectAsModified = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns7__setProjectAsModified *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__setProjectAsModified, sizeof(struct __ns7__setProjectAsModified), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__setProjectAsModified(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns7__setProjectAsModified && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns7__setProjectAsModified(soap, "ns7:setProjectAsModified", &a->ns7__setProjectAsModified, ""))
				{	soap_flag_ns7__setProjectAsModified--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns7__setProjectAsModified * SOAP_FMAC2 soap_instantiate___ns7__setProjectAsModified(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__setProjectAsModified(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns7__setProjectAsModified *p;
	size_t k = sizeof(struct __ns7__setProjectAsModified);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns7__setProjectAsModified);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns7__setProjectAsModified, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns7__setProjectAsModified location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns7__setProjectAsModified, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__setProjectAsModified(struct soap *soap, const struct __ns7__setProjectAsModified *a, const char *tag, const char *type)
{
	if (soap_out___ns7__setProjectAsModified(soap, tag ? tag : "-ns7:setProjectAsModified", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__setProjectAsModified * SOAP_FMAC4 soap_get___ns7__setProjectAsModified(struct soap *soap, struct __ns7__setProjectAsModified *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__setProjectAsModified(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__execVal3(struct soap *soap, struct __ns7__execVal3 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns7__execVal3 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__execVal3(struct soap *soap, const struct __ns7__execVal3 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns7__execVal3(soap, &a->ns7__execVal3);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__execVal3(struct soap *soap, const char *tag, int id, const struct __ns7__execVal3 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns7__execVal3(soap, "ns7:execVal3", -1, &a->ns7__execVal3, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__execVal3 * SOAP_FMAC4 soap_in___ns7__execVal3(struct soap *soap, const char *tag, struct __ns7__execVal3 *a, const char *type)
{
	size_t soap_flag_ns7__execVal3 = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns7__execVal3 *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__execVal3, sizeof(struct __ns7__execVal3), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__execVal3(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns7__execVal3 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns7__execVal3(soap, "ns7:execVal3", &a->ns7__execVal3, ""))
				{	soap_flag_ns7__execVal3--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns7__execVal3 * SOAP_FMAC2 soap_instantiate___ns7__execVal3(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__execVal3(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns7__execVal3 *p;
	size_t k = sizeof(struct __ns7__execVal3);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns7__execVal3);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns7__execVal3, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns7__execVal3 location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns7__execVal3, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__execVal3(struct soap *soap, const struct __ns7__execVal3 *a, const char *tag, const char *type)
{
	if (soap_out___ns7__execVal3(soap, tag ? tag : "-ns7:execVal3", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__execVal3 * SOAP_FMAC4 soap_get___ns7__execVal3(struct soap *soap, struct __ns7__execVal3 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__execVal3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__getWatches(struct soap *soap, struct __ns7__getWatches *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns7__getWatches = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__getWatches(struct soap *soap, const struct __ns7__getWatches *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns7__getWatches(soap, &a->ns7__getWatches);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__getWatches(struct soap *soap, const char *tag, int id, const struct __ns7__getWatches *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns7__getWatches(soap, "ns7:getWatches", -1, &a->ns7__getWatches, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__getWatches * SOAP_FMAC4 soap_in___ns7__getWatches(struct soap *soap, const char *tag, struct __ns7__getWatches *a, const char *type)
{
	size_t soap_flag_ns7__getWatches = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns7__getWatches *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__getWatches, sizeof(struct __ns7__getWatches), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__getWatches(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns7__getWatches && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns7__getWatches(soap, "ns7:getWatches", &a->ns7__getWatches, ""))
				{	soap_flag_ns7__getWatches--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns7__getWatches * SOAP_FMAC2 soap_instantiate___ns7__getWatches(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__getWatches(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns7__getWatches *p;
	size_t k = sizeof(struct __ns7__getWatches);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns7__getWatches);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns7__getWatches, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns7__getWatches location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns7__getWatches, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__getWatches(struct soap *soap, const struct __ns7__getWatches *a, const char *tag, const char *type)
{
	if (soap_out___ns7__getWatches(soap, tag ? tag : "-ns7:getWatches", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__getWatches * SOAP_FMAC4 soap_get___ns7__getWatches(struct soap *soap, struct __ns7__getWatches *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__getWatches(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__getStackFrame(struct soap *soap, struct __ns7__getStackFrame *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns7__getStackFrame = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__getStackFrame(struct soap *soap, const struct __ns7__getStackFrame *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns7__getStackFrame(soap, &a->ns7__getStackFrame);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__getStackFrame(struct soap *soap, const char *tag, int id, const struct __ns7__getStackFrame *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns7__getStackFrame(soap, "ns7:getStackFrame", -1, &a->ns7__getStackFrame, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__getStackFrame * SOAP_FMAC4 soap_in___ns7__getStackFrame(struct soap *soap, const char *tag, struct __ns7__getStackFrame *a, const char *type)
{
	size_t soap_flag_ns7__getStackFrame = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns7__getStackFrame *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__getStackFrame, sizeof(struct __ns7__getStackFrame), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__getStackFrame(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns7__getStackFrame && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns7__getStackFrame(soap, "ns7:getStackFrame", &a->ns7__getStackFrame, ""))
				{	soap_flag_ns7__getStackFrame--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns7__getStackFrame * SOAP_FMAC2 soap_instantiate___ns7__getStackFrame(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__getStackFrame(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns7__getStackFrame *p;
	size_t k = sizeof(struct __ns7__getStackFrame);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns7__getStackFrame);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns7__getStackFrame, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns7__getStackFrame location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns7__getStackFrame, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__getStackFrame(struct soap *soap, const struct __ns7__getStackFrame *a, const char *tag, const char *type)
{
	if (soap_out___ns7__getStackFrame(soap, tag ? tag : "-ns7:getStackFrame", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__getStackFrame * SOAP_FMAC4 soap_get___ns7__getStackFrame(struct soap *soap, struct __ns7__getStackFrame *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__getStackFrame(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__getCallStack(struct soap *soap, struct __ns7__getCallStack *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns7__getCallStack = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__getCallStack(struct soap *soap, const struct __ns7__getCallStack *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns7__getCallStack(soap, &a->ns7__getCallStack);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__getCallStack(struct soap *soap, const char *tag, int id, const struct __ns7__getCallStack *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns7__getCallStack(soap, "ns7:getCallStack", -1, &a->ns7__getCallStack, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__getCallStack * SOAP_FMAC4 soap_in___ns7__getCallStack(struct soap *soap, const char *tag, struct __ns7__getCallStack *a, const char *type)
{
	size_t soap_flag_ns7__getCallStack = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns7__getCallStack *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__getCallStack, sizeof(struct __ns7__getCallStack), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__getCallStack(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns7__getCallStack && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns7__getCallStack(soap, "ns7:getCallStack", &a->ns7__getCallStack, ""))
				{	soap_flag_ns7__getCallStack--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns7__getCallStack * SOAP_FMAC2 soap_instantiate___ns7__getCallStack(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__getCallStack(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns7__getCallStack *p;
	size_t k = sizeof(struct __ns7__getCallStack);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns7__getCallStack);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns7__getCallStack, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns7__getCallStack location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns7__getCallStack, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__getCallStack(struct soap *soap, const struct __ns7__getCallStack *a, const char *tag, const char *type)
{
	if (soap_out___ns7__getCallStack(soap, tag ? tag : "-ns7:getCallStack", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__getCallStack * SOAP_FMAC4 soap_get___ns7__getCallStack(struct soap *soap, struct __ns7__getCallStack *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__getCallStack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__unsubscribeToControllerEvents(struct soap *soap, struct __ns7__unsubscribeToControllerEvents *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns7__unsubscribeToControllerEvents = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__unsubscribeToControllerEvents(struct soap *soap, const struct __ns7__unsubscribeToControllerEvents *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns7__unsubscribeToControllerEvents(soap, &a->ns7__unsubscribeToControllerEvents);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__unsubscribeToControllerEvents(struct soap *soap, const char *tag, int id, const struct __ns7__unsubscribeToControllerEvents *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns7__unsubscribeToControllerEvents(soap, "ns7:unsubscribeToControllerEvents", -1, &a->ns7__unsubscribeToControllerEvents, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__unsubscribeToControllerEvents * SOAP_FMAC4 soap_in___ns7__unsubscribeToControllerEvents(struct soap *soap, const char *tag, struct __ns7__unsubscribeToControllerEvents *a, const char *type)
{
	size_t soap_flag_ns7__unsubscribeToControllerEvents = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns7__unsubscribeToControllerEvents *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__unsubscribeToControllerEvents, sizeof(struct __ns7__unsubscribeToControllerEvents), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__unsubscribeToControllerEvents(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns7__unsubscribeToControllerEvents && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns7__unsubscribeToControllerEvents(soap, "ns7:unsubscribeToControllerEvents", &a->ns7__unsubscribeToControllerEvents, ""))
				{	soap_flag_ns7__unsubscribeToControllerEvents--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns7__unsubscribeToControllerEvents * SOAP_FMAC2 soap_instantiate___ns7__unsubscribeToControllerEvents(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__unsubscribeToControllerEvents(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns7__unsubscribeToControllerEvents *p;
	size_t k = sizeof(struct __ns7__unsubscribeToControllerEvents);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns7__unsubscribeToControllerEvents);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns7__unsubscribeToControllerEvents, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns7__unsubscribeToControllerEvents location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns7__unsubscribeToControllerEvents, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__unsubscribeToControllerEvents(struct soap *soap, const struct __ns7__unsubscribeToControllerEvents *a, const char *tag, const char *type)
{
	if (soap_out___ns7__unsubscribeToControllerEvents(soap, tag ? tag : "-ns7:unsubscribeToControllerEvents", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__unsubscribeToControllerEvents * SOAP_FMAC4 soap_get___ns7__unsubscribeToControllerEvents(struct soap *soap, struct __ns7__unsubscribeToControllerEvents *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__unsubscribeToControllerEvents(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__subscribeToControllerEvents(struct soap *soap, struct __ns7__subscribeToControllerEvents *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns7__subscribeToControllerEvents = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__subscribeToControllerEvents(struct soap *soap, const struct __ns7__subscribeToControllerEvents *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns7__subscribeToControllerEvents(soap, &a->ns7__subscribeToControllerEvents);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__subscribeToControllerEvents(struct soap *soap, const char *tag, int id, const struct __ns7__subscribeToControllerEvents *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns7__subscribeToControllerEvents(soap, "ns7:subscribeToControllerEvents", -1, &a->ns7__subscribeToControllerEvents, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__subscribeToControllerEvents * SOAP_FMAC4 soap_in___ns7__subscribeToControllerEvents(struct soap *soap, const char *tag, struct __ns7__subscribeToControllerEvents *a, const char *type)
{
	size_t soap_flag_ns7__subscribeToControllerEvents = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns7__subscribeToControllerEvents *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__subscribeToControllerEvents, sizeof(struct __ns7__subscribeToControllerEvents), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__subscribeToControllerEvents(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns7__subscribeToControllerEvents && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns7__subscribeToControllerEvents(soap, "ns7:subscribeToControllerEvents", &a->ns7__subscribeToControllerEvents, ""))
				{	soap_flag_ns7__subscribeToControllerEvents--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns7__subscribeToControllerEvents * SOAP_FMAC2 soap_instantiate___ns7__subscribeToControllerEvents(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__subscribeToControllerEvents(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns7__subscribeToControllerEvents *p;
	size_t k = sizeof(struct __ns7__subscribeToControllerEvents);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns7__subscribeToControllerEvents);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns7__subscribeToControllerEvents, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns7__subscribeToControllerEvents location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns7__subscribeToControllerEvents, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__subscribeToControllerEvents(struct soap *soap, const struct __ns7__subscribeToControllerEvents *a, const char *tag, const char *type)
{
	if (soap_out___ns7__subscribeToControllerEvents(soap, tag ? tag : "-ns7:subscribeToControllerEvents", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__subscribeToControllerEvents * SOAP_FMAC4 soap_get___ns7__subscribeToControllerEvents(struct soap *soap, struct __ns7__subscribeToControllerEvents *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__subscribeToControllerEvents(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__taskStep(struct soap *soap, struct __ns7__taskStep *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns7__taskStep = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__taskStep(struct soap *soap, const struct __ns7__taskStep *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns7__taskStep(soap, &a->ns7__taskStep);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__taskStep(struct soap *soap, const char *tag, int id, const struct __ns7__taskStep *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns7__taskStep(soap, "ns7:taskStep", -1, &a->ns7__taskStep, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__taskStep * SOAP_FMAC4 soap_in___ns7__taskStep(struct soap *soap, const char *tag, struct __ns7__taskStep *a, const char *type)
{
	size_t soap_flag_ns7__taskStep = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns7__taskStep *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__taskStep, sizeof(struct __ns7__taskStep), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__taskStep(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns7__taskStep && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns7__taskStep(soap, "ns7:taskStep", &a->ns7__taskStep, ""))
				{	soap_flag_ns7__taskStep--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns7__taskStep * SOAP_FMAC2 soap_instantiate___ns7__taskStep(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__taskStep(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns7__taskStep *p;
	size_t k = sizeof(struct __ns7__taskStep);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns7__taskStep);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns7__taskStep, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns7__taskStep location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns7__taskStep, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__taskStep(struct soap *soap, const struct __ns7__taskStep *a, const char *tag, const char *type)
{
	if (soap_out___ns7__taskStep(soap, tag ? tag : "-ns7:taskStep", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__taskStep * SOAP_FMAC4 soap_get___ns7__taskStep(struct soap *soap, struct __ns7__taskStep *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__taskStep(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__taskKill(struct soap *soap, struct __ns7__taskKill *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns7__taskKill = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__taskKill(struct soap *soap, const struct __ns7__taskKill *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns7__taskKill(soap, &a->ns7__taskKill);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__taskKill(struct soap *soap, const char *tag, int id, const struct __ns7__taskKill *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns7__taskKill(soap, "ns7:taskKill", -1, &a->ns7__taskKill, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__taskKill * SOAP_FMAC4 soap_in___ns7__taskKill(struct soap *soap, const char *tag, struct __ns7__taskKill *a, const char *type)
{
	size_t soap_flag_ns7__taskKill = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns7__taskKill *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__taskKill, sizeof(struct __ns7__taskKill), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__taskKill(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns7__taskKill && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns7__taskKill(soap, "ns7:taskKill", &a->ns7__taskKill, ""))
				{	soap_flag_ns7__taskKill--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns7__taskKill * SOAP_FMAC2 soap_instantiate___ns7__taskKill(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__taskKill(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns7__taskKill *p;
	size_t k = sizeof(struct __ns7__taskKill);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns7__taskKill);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns7__taskKill, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns7__taskKill location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns7__taskKill, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__taskKill(struct soap *soap, const struct __ns7__taskKill *a, const char *tag, const char *type)
{
	if (soap_out___ns7__taskKill(soap, tag ? tag : "-ns7:taskKill", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__taskKill * SOAP_FMAC4 soap_get___ns7__taskKill(struct soap *soap, struct __ns7__taskKill *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__taskKill(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__taskResume(struct soap *soap, struct __ns7__taskResume *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns7__taskResume = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__taskResume(struct soap *soap, const struct __ns7__taskResume *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns7__taskResume(soap, &a->ns7__taskResume);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__taskResume(struct soap *soap, const char *tag, int id, const struct __ns7__taskResume *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns7__taskResume(soap, "ns7:taskResume", -1, &a->ns7__taskResume, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__taskResume * SOAP_FMAC4 soap_in___ns7__taskResume(struct soap *soap, const char *tag, struct __ns7__taskResume *a, const char *type)
{
	size_t soap_flag_ns7__taskResume = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns7__taskResume *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__taskResume, sizeof(struct __ns7__taskResume), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__taskResume(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns7__taskResume && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns7__taskResume(soap, "ns7:taskResume", &a->ns7__taskResume, ""))
				{	soap_flag_ns7__taskResume--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns7__taskResume * SOAP_FMAC2 soap_instantiate___ns7__taskResume(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__taskResume(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns7__taskResume *p;
	size_t k = sizeof(struct __ns7__taskResume);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns7__taskResume);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns7__taskResume, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns7__taskResume location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns7__taskResume, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__taskResume(struct soap *soap, const struct __ns7__taskResume *a, const char *tag, const char *type)
{
	if (soap_out___ns7__taskResume(soap, tag ? tag : "-ns7:taskResume", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__taskResume * SOAP_FMAC4 soap_get___ns7__taskResume(struct soap *soap, struct __ns7__taskResume *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__taskResume(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__taskSuspend(struct soap *soap, struct __ns7__taskSuspend *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns7__taskSuspend = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__taskSuspend(struct soap *soap, const struct __ns7__taskSuspend *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns7__taskSuspend(soap, &a->ns7__taskSuspend);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__taskSuspend(struct soap *soap, const char *tag, int id, const struct __ns7__taskSuspend *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns7__taskSuspend(soap, "ns7:taskSuspend", -1, &a->ns7__taskSuspend, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__taskSuspend * SOAP_FMAC4 soap_in___ns7__taskSuspend(struct soap *soap, const char *tag, struct __ns7__taskSuspend *a, const char *type)
{
	size_t soap_flag_ns7__taskSuspend = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns7__taskSuspend *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__taskSuspend, sizeof(struct __ns7__taskSuspend), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__taskSuspend(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns7__taskSuspend && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns7__taskSuspend(soap, "ns7:taskSuspend", &a->ns7__taskSuspend, ""))
				{	soap_flag_ns7__taskSuspend--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns7__taskSuspend * SOAP_FMAC2 soap_instantiate___ns7__taskSuspend(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__taskSuspend(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns7__taskSuspend *p;
	size_t k = sizeof(struct __ns7__taskSuspend);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns7__taskSuspend);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns7__taskSuspend, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns7__taskSuspend location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns7__taskSuspend, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__taskSuspend(struct soap *soap, const struct __ns7__taskSuspend *a, const char *tag, const char *type)
{
	if (soap_out___ns7__taskSuspend(soap, tag ? tag : "-ns7:taskSuspend", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__taskSuspend * SOAP_FMAC4 soap_get___ns7__taskSuspend(struct soap *soap, struct __ns7__taskSuspend *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__taskSuspend(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__getTasks(struct soap *soap, struct __ns7__getTasks *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns7__getTasks = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__getTasks(struct soap *soap, const struct __ns7__getTasks *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns7__getTasks(soap, &a->ns7__getTasks);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__getTasks(struct soap *soap, const char *tag, int id, const struct __ns7__getTasks *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns7__getTasks(soap, "ns7:getTasks", -1, &a->ns7__getTasks, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__getTasks * SOAP_FMAC4 soap_in___ns7__getTasks(struct soap *soap, const char *tag, struct __ns7__getTasks *a, const char *type)
{
	size_t soap_flag_ns7__getTasks = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns7__getTasks *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__getTasks, sizeof(struct __ns7__getTasks), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__getTasks(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns7__getTasks && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns7__getTasks(soap, "ns7:getTasks", &a->ns7__getTasks, ""))
				{	soap_flag_ns7__getTasks--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns7__getTasks * SOAP_FMAC2 soap_instantiate___ns7__getTasks(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__getTasks(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns7__getTasks *p;
	size_t k = sizeof(struct __ns7__getTasks);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns7__getTasks);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns7__getTasks, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns7__getTasks location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns7__getTasks, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__getTasks(struct soap *soap, const struct __ns7__getTasks *a, const char *tag, const char *type)
{
	if (soap_out___ns7__getTasks(soap, tag ? tag : "-ns7:getTasks", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__getTasks * SOAP_FMAC4 soap_get___ns7__getTasks(struct soap *soap, struct __ns7__getTasks *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__getTasks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__clearAllBreakpoints(struct soap *soap, struct __ns7__clearAllBreakpoints *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns7__clearAllBreakpoints = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__clearAllBreakpoints(struct soap *soap, const struct __ns7__clearAllBreakpoints *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns7__clearAllBreakpoints(soap, &a->ns7__clearAllBreakpoints);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__clearAllBreakpoints(struct soap *soap, const char *tag, int id, const struct __ns7__clearAllBreakpoints *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns7__clearAllBreakpoints(soap, "ns7:clearAllBreakpoints", -1, &a->ns7__clearAllBreakpoints, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__clearAllBreakpoints * SOAP_FMAC4 soap_in___ns7__clearAllBreakpoints(struct soap *soap, const char *tag, struct __ns7__clearAllBreakpoints *a, const char *type)
{
	size_t soap_flag_ns7__clearAllBreakpoints = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns7__clearAllBreakpoints *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__clearAllBreakpoints, sizeof(struct __ns7__clearAllBreakpoints), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__clearAllBreakpoints(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns7__clearAllBreakpoints && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns7__clearAllBreakpoints(soap, "ns7:clearAllBreakpoints", &a->ns7__clearAllBreakpoints, ""))
				{	soap_flag_ns7__clearAllBreakpoints--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns7__clearAllBreakpoints * SOAP_FMAC2 soap_instantiate___ns7__clearAllBreakpoints(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__clearAllBreakpoints(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns7__clearAllBreakpoints *p;
	size_t k = sizeof(struct __ns7__clearAllBreakpoints);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns7__clearAllBreakpoints);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns7__clearAllBreakpoints, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns7__clearAllBreakpoints location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns7__clearAllBreakpoints, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__clearAllBreakpoints(struct soap *soap, const struct __ns7__clearAllBreakpoints *a, const char *tag, const char *type)
{
	if (soap_out___ns7__clearAllBreakpoints(soap, tag ? tag : "-ns7:clearAllBreakpoints", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__clearAllBreakpoints * SOAP_FMAC4 soap_get___ns7__clearAllBreakpoints(struct soap *soap, struct __ns7__clearAllBreakpoints *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__clearAllBreakpoints(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__clearBreakpoints(struct soap *soap, struct __ns7__clearBreakpoints *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns7__clearBreakpoints = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__clearBreakpoints(struct soap *soap, const struct __ns7__clearBreakpoints *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns7__clearBreakpoints(soap, &a->ns7__clearBreakpoints);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__clearBreakpoints(struct soap *soap, const char *tag, int id, const struct __ns7__clearBreakpoints *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns7__clearBreakpoints(soap, "ns7:clearBreakpoints", -1, &a->ns7__clearBreakpoints, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__clearBreakpoints * SOAP_FMAC4 soap_in___ns7__clearBreakpoints(struct soap *soap, const char *tag, struct __ns7__clearBreakpoints *a, const char *type)
{
	size_t soap_flag_ns7__clearBreakpoints = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns7__clearBreakpoints *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__clearBreakpoints, sizeof(struct __ns7__clearBreakpoints), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__clearBreakpoints(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns7__clearBreakpoints && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns7__clearBreakpoints(soap, "ns7:clearBreakpoints", &a->ns7__clearBreakpoints, ""))
				{	soap_flag_ns7__clearBreakpoints--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns7__clearBreakpoints * SOAP_FMAC2 soap_instantiate___ns7__clearBreakpoints(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__clearBreakpoints(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns7__clearBreakpoints *p;
	size_t k = sizeof(struct __ns7__clearBreakpoints);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns7__clearBreakpoints);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns7__clearBreakpoints, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns7__clearBreakpoints location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns7__clearBreakpoints, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__clearBreakpoints(struct soap *soap, const struct __ns7__clearBreakpoints *a, const char *tag, const char *type)
{
	if (soap_out___ns7__clearBreakpoints(soap, tag ? tag : "-ns7:clearBreakpoints", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__clearBreakpoints * SOAP_FMAC4 soap_get___ns7__clearBreakpoints(struct soap *soap, struct __ns7__clearBreakpoints *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__clearBreakpoints(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__getBreakpoints(struct soap *soap, struct __ns7__getBreakpoints *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns7__getBreakpoints = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__getBreakpoints(struct soap *soap, const struct __ns7__getBreakpoints *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns7__getBreakpoints(soap, &a->ns7__getBreakpoints);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__getBreakpoints(struct soap *soap, const char *tag, int id, const struct __ns7__getBreakpoints *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns7__getBreakpoints(soap, "ns7:getBreakpoints", -1, &a->ns7__getBreakpoints, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__getBreakpoints * SOAP_FMAC4 soap_in___ns7__getBreakpoints(struct soap *soap, const char *tag, struct __ns7__getBreakpoints *a, const char *type)
{
	size_t soap_flag_ns7__getBreakpoints = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns7__getBreakpoints *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__getBreakpoints, sizeof(struct __ns7__getBreakpoints), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__getBreakpoints(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns7__getBreakpoints && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns7__getBreakpoints(soap, "ns7:getBreakpoints", &a->ns7__getBreakpoints, ""))
				{	soap_flag_ns7__getBreakpoints--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns7__getBreakpoints * SOAP_FMAC2 soap_instantiate___ns7__getBreakpoints(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__getBreakpoints(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns7__getBreakpoints *p;
	size_t k = sizeof(struct __ns7__getBreakpoints);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns7__getBreakpoints);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns7__getBreakpoints, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns7__getBreakpoints location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns7__getBreakpoints, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__getBreakpoints(struct soap *soap, const struct __ns7__getBreakpoints *a, const char *tag, const char *type)
{
	if (soap_out___ns7__getBreakpoints(soap, tag ? tag : "-ns7:getBreakpoints", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__getBreakpoints * SOAP_FMAC4 soap_get___ns7__getBreakpoints(struct soap *soap, struct __ns7__getBreakpoints *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__getBreakpoints(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__setBreakpoints(struct soap *soap, struct __ns7__setBreakpoints *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns7__setBreakpoints = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__setBreakpoints(struct soap *soap, const struct __ns7__setBreakpoints *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns7__setBreakpoints(soap, &a->ns7__setBreakpoints);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__setBreakpoints(struct soap *soap, const char *tag, int id, const struct __ns7__setBreakpoints *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns7__setBreakpoints(soap, "ns7:setBreakpoints", -1, &a->ns7__setBreakpoints, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__setBreakpoints * SOAP_FMAC4 soap_in___ns7__setBreakpoints(struct soap *soap, const char *tag, struct __ns7__setBreakpoints *a, const char *type)
{
	size_t soap_flag_ns7__setBreakpoints = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns7__setBreakpoints *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__setBreakpoints, sizeof(struct __ns7__setBreakpoints), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__setBreakpoints(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns7__setBreakpoints && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns7__setBreakpoints(soap, "ns7:setBreakpoints", &a->ns7__setBreakpoints, ""))
				{	soap_flag_ns7__setBreakpoints--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns7__setBreakpoints * SOAP_FMAC2 soap_instantiate___ns7__setBreakpoints(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__setBreakpoints(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns7__setBreakpoints *p;
	size_t k = sizeof(struct __ns7__setBreakpoints);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns7__setBreakpoints);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns7__setBreakpoints, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns7__setBreakpoints location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns7__setBreakpoints, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__setBreakpoints(struct soap *soap, const struct __ns7__setBreakpoints *a, const char *tag, const char *type)
{
	if (soap_out___ns7__setBreakpoints(soap, tag ? tag : "-ns7:setBreakpoints", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__setBreakpoints * SOAP_FMAC4 soap_get___ns7__setBreakpoints(struct soap *soap, struct __ns7__setBreakpoints *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__setBreakpoints(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setRobotJointPos(struct soap *soap, struct __ns1__setRobotJointPos *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__setRobotJointPos = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setRobotJointPos(struct soap *soap, const struct __ns1__setRobotJointPos *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__setRobotJointPos(soap, &a->ns1__setRobotJointPos);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setRobotJointPos(struct soap *soap, const char *tag, int id, const struct __ns1__setRobotJointPos *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__setRobotJointPos(soap, "ns1:setRobotJointPos", -1, &a->ns1__setRobotJointPos, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setRobotJointPos * SOAP_FMAC4 soap_in___ns1__setRobotJointPos(struct soap *soap, const char *tag, struct __ns1__setRobotJointPos *a, const char *type)
{
	size_t soap_flag_ns1__setRobotJointPos = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__setRobotJointPos *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setRobotJointPos, sizeof(struct __ns1__setRobotJointPos), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setRobotJointPos(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__setRobotJointPos && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__setRobotJointPos(soap, "ns1:setRobotJointPos", &a->ns1__setRobotJointPos, ""))
				{	soap_flag_ns1__setRobotJointPos--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__setRobotJointPos * SOAP_FMAC2 soap_instantiate___ns1__setRobotJointPos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__setRobotJointPos(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__setRobotJointPos *p;
	size_t k = sizeof(struct __ns1__setRobotJointPos);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__setRobotJointPos);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__setRobotJointPos, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__setRobotJointPos location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__setRobotJointPos, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setRobotJointPos(struct soap *soap, const struct __ns1__setRobotJointPos *a, const char *tag, const char *type)
{
	if (soap_out___ns1__setRobotJointPos(soap, tag ? tag : "-ns1:setRobotJointPos", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setRobotJointPos * SOAP_FMAC4 soap_get___ns1__setRobotJointPos(struct soap *soap, struct __ns1__setRobotJointPos *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setRobotJointPos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getRobotJntCartPos(struct soap *soap, struct __ns1__getRobotJntCartPos *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getRobotJntCartPos = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getRobotJntCartPos(struct soap *soap, const struct __ns1__getRobotJntCartPos *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__getRobotJntCartPos(soap, &a->ns1__getRobotJntCartPos);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getRobotJntCartPos(struct soap *soap, const char *tag, int id, const struct __ns1__getRobotJntCartPos *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__getRobotJntCartPos(soap, "ns1:getRobotJntCartPos", -1, &a->ns1__getRobotJntCartPos, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getRobotJntCartPos * SOAP_FMAC4 soap_in___ns1__getRobotJntCartPos(struct soap *soap, const char *tag, struct __ns1__getRobotJntCartPos *a, const char *type)
{
	size_t soap_flag_ns1__getRobotJntCartPos = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getRobotJntCartPos *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getRobotJntCartPos, sizeof(struct __ns1__getRobotJntCartPos), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getRobotJntCartPos(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getRobotJntCartPos && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__getRobotJntCartPos(soap, "ns1:getRobotJntCartPos", &a->ns1__getRobotJntCartPos, ""))
				{	soap_flag_ns1__getRobotJntCartPos--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getRobotJntCartPos * SOAP_FMAC2 soap_instantiate___ns1__getRobotJntCartPos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getRobotJntCartPos(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getRobotJntCartPos *p;
	size_t k = sizeof(struct __ns1__getRobotJntCartPos);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getRobotJntCartPos);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getRobotJntCartPos, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getRobotJntCartPos location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getRobotJntCartPos, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getRobotJntCartPos(struct soap *soap, const struct __ns1__getRobotJntCartPos *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getRobotJntCartPos(soap, tag ? tag : "-ns1:getRobotJntCartPos", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getRobotJntCartPos * SOAP_FMAC4 soap_get___ns1__getRobotJntCartPos(struct soap *soap, struct __ns1__getRobotJntCartPos *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getRobotJntCartPos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getRobotJointPos(struct soap *soap, struct __ns1__getRobotJointPos *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getRobotJointPos = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getRobotJointPos(struct soap *soap, const struct __ns1__getRobotJointPos *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__getRobotJointPos(soap, &a->ns1__getRobotJointPos);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getRobotJointPos(struct soap *soap, const char *tag, int id, const struct __ns1__getRobotJointPos *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__getRobotJointPos(soap, "ns1:getRobotJointPos", -1, &a->ns1__getRobotJointPos, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getRobotJointPos * SOAP_FMAC4 soap_in___ns1__getRobotJointPos(struct soap *soap, const char *tag, struct __ns1__getRobotJointPos *a, const char *type)
{
	size_t soap_flag_ns1__getRobotJointPos = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getRobotJointPos *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getRobotJointPos, sizeof(struct __ns1__getRobotJointPos), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getRobotJointPos(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getRobotJointPos && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__getRobotJointPos(soap, "ns1:getRobotJointPos", &a->ns1__getRobotJointPos, ""))
				{	soap_flag_ns1__getRobotJointPos--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getRobotJointPos * SOAP_FMAC2 soap_instantiate___ns1__getRobotJointPos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getRobotJointPos(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getRobotJointPos *p;
	size_t k = sizeof(struct __ns1__getRobotJointPos);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getRobotJointPos);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getRobotJointPos, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getRobotJointPos location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getRobotJointPos, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getRobotJointPos(struct soap *soap, const struct __ns1__getRobotJointPos *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getRobotJointPos(soap, tag ? tag : "-ns1:getRobotJointPos", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getRobotJointPos * SOAP_FMAC4 soap_get___ns1__getRobotJointPos(struct soap *soap, struct __ns1__getRobotJointPos *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getRobotJointPos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getRobots(struct soap *soap, struct __ns1__getRobots *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getRobots = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getRobots(struct soap *soap, const struct __ns1__getRobots *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__getRobots(soap, &a->ns1__getRobots);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getRobots(struct soap *soap, const char *tag, int id, const struct __ns1__getRobots *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__getRobots(soap, "ns1:getRobots", -1, &a->ns1__getRobots, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getRobots * SOAP_FMAC4 soap_in___ns1__getRobots(struct soap *soap, const char *tag, struct __ns1__getRobots *a, const char *type)
{
	size_t soap_flag_ns1__getRobots = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getRobots *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getRobots, sizeof(struct __ns1__getRobots), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getRobots(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getRobots && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__getRobots(soap, "ns1:getRobots", &a->ns1__getRobots, ""))
				{	soap_flag_ns1__getRobots--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getRobots * SOAP_FMAC2 soap_instantiate___ns1__getRobots(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getRobots(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getRobots *p;
	size_t k = sizeof(struct __ns1__getRobots);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getRobots);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getRobots, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getRobots location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getRobots, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getRobots(struct soap *soap, const struct __ns1__getRobots *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getRobots(soap, tag ? tag : "-ns1:getRobots", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getRobots * SOAP_FMAC4 soap_get___ns1__getRobots(struct soap *soap, struct __ns1__getRobots *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getRobots(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__logout(struct soap *soap, struct __ns1__logout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__logout = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__logout(struct soap *soap, const struct __ns1__logout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__logout(soap, &a->ns1__logout);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__logout(struct soap *soap, const char *tag, int id, const struct __ns1__logout *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__logout(soap, "ns1:logout", -1, &a->ns1__logout, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__logout * SOAP_FMAC4 soap_in___ns1__logout(struct soap *soap, const char *tag, struct __ns1__logout *a, const char *type)
{
	size_t soap_flag_ns1__logout = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__logout *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__logout, sizeof(struct __ns1__logout), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__logout(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__logout && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__logout(soap, "ns1:logout", &a->ns1__logout, ""))
				{	soap_flag_ns1__logout--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__logout * SOAP_FMAC2 soap_instantiate___ns1__logout(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__logout(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__logout *p;
	size_t k = sizeof(struct __ns1__logout);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__logout);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__logout, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__logout location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__logout, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__logout(struct soap *soap, const struct __ns1__logout *a, const char *tag, const char *type)
{
	if (soap_out___ns1__logout(soap, tag ? tag : "-ns1:logout", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__logout * SOAP_FMAC4 soap_get___ns1__logout(struct soap *soap, struct __ns1__logout *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__logout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__login(struct soap *soap, struct __ns1__login *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__login = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__login(struct soap *soap, const struct __ns1__login *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__login(soap, &a->ns1__login);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__login(struct soap *soap, const char *tag, int id, const struct __ns1__login *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__login(soap, "ns1:login", -1, &a->ns1__login, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__login * SOAP_FMAC4 soap_in___ns1__login(struct soap *soap, const char *tag, struct __ns1__login *a, const char *type)
{
	size_t soap_flag_ns1__login = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__login *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__login, sizeof(struct __ns1__login), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__login(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__login && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__login(soap, "ns1:login", &a->ns1__login, ""))
				{	soap_flag_ns1__login--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__login * SOAP_FMAC2 soap_instantiate___ns1__login(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__login(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__login *p;
	size_t k = sizeof(struct __ns1__login);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__login);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__login, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__login location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__login, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__login(struct soap *soap, const struct __ns1__login *a, const char *tag, const char *type)
{
	if (soap_out___ns1__login(soap, tag ? tag : "-ns1:login", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__login * SOAP_FMAC4 soap_get___ns1__login(struct soap *soap, struct __ns1__login *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getCS8Compatibility(struct soap *soap, struct __ns1__getCS8Compatibility *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getCS8Compatibility = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getCS8Compatibility(struct soap *soap, const struct __ns1__getCS8Compatibility *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__getCS8Compatibility(soap, &a->ns1__getCS8Compatibility);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getCS8Compatibility(struct soap *soap, const char *tag, int id, const struct __ns1__getCS8Compatibility *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__getCS8Compatibility(soap, "ns1:getCS8Compatibility", -1, &a->ns1__getCS8Compatibility, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getCS8Compatibility * SOAP_FMAC4 soap_in___ns1__getCS8Compatibility(struct soap *soap, const char *tag, struct __ns1__getCS8Compatibility *a, const char *type)
{
	size_t soap_flag_ns1__getCS8Compatibility = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getCS8Compatibility *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getCS8Compatibility, sizeof(struct __ns1__getCS8Compatibility), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getCS8Compatibility(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getCS8Compatibility && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__getCS8Compatibility(soap, "ns1:getCS8Compatibility", &a->ns1__getCS8Compatibility, ""))
				{	soap_flag_ns1__getCS8Compatibility--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getCS8Compatibility * SOAP_FMAC2 soap_instantiate___ns1__getCS8Compatibility(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getCS8Compatibility(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getCS8Compatibility *p;
	size_t k = sizeof(struct __ns1__getCS8Compatibility);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getCS8Compatibility);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getCS8Compatibility, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getCS8Compatibility location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getCS8Compatibility, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getCS8Compatibility(struct soap *soap, const struct __ns1__getCS8Compatibility *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getCS8Compatibility(soap, tag ? tag : "-ns1:getCS8Compatibility", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getCS8Compatibility * SOAP_FMAC4 soap_get___ns1__getCS8Compatibility(struct soap *soap, struct __ns1__getCS8Compatibility *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getCS8Compatibility(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getControllerParameters(struct soap *soap, struct __ns1__getControllerParameters *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getControllerParameters = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getControllerParameters(struct soap *soap, const struct __ns1__getControllerParameters *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__getControllerParameters(soap, &a->ns1__getControllerParameters);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getControllerParameters(struct soap *soap, const char *tag, int id, const struct __ns1__getControllerParameters *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__getControllerParameters(soap, "ns1:getControllerParameters", -1, &a->ns1__getControllerParameters, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getControllerParameters * SOAP_FMAC4 soap_in___ns1__getControllerParameters(struct soap *soap, const char *tag, struct __ns1__getControllerParameters *a, const char *type)
{
	size_t soap_flag_ns1__getControllerParameters = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getControllerParameters *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getControllerParameters, sizeof(struct __ns1__getControllerParameters), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getControllerParameters(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getControllerParameters && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__getControllerParameters(soap, "ns1:getControllerParameters", &a->ns1__getControllerParameters, ""))
				{	soap_flag_ns1__getControllerParameters--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getControllerParameters * SOAP_FMAC2 soap_instantiate___ns1__getControllerParameters(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getControllerParameters(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getControllerParameters *p;
	size_t k = sizeof(struct __ns1__getControllerParameters);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getControllerParameters);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getControllerParameters, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getControllerParameters location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getControllerParameters, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getControllerParameters(struct soap *soap, const struct __ns1__getControllerParameters *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getControllerParameters(soap, tag ? tag : "-ns1:getControllerParameters", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getControllerParameters * SOAP_FMAC4 soap_get___ns1__getControllerParameters(struct soap *soap, struct __ns1__getControllerParameters *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getControllerParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getCS8Versions(struct soap *soap, struct __ns1__getCS8Versions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getCS8Versions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getCS8Versions(struct soap *soap, const struct __ns1__getCS8Versions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__getCS8Versions(soap, &a->ns1__getCS8Versions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getCS8Versions(struct soap *soap, const char *tag, int id, const struct __ns1__getCS8Versions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__getCS8Versions(soap, "ns1:getCS8Versions", -1, &a->ns1__getCS8Versions, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getCS8Versions * SOAP_FMAC4 soap_in___ns1__getCS8Versions(struct soap *soap, const char *tag, struct __ns1__getCS8Versions *a, const char *type)
{
	size_t soap_flag_ns1__getCS8Versions = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getCS8Versions *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getCS8Versions, sizeof(struct __ns1__getCS8Versions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getCS8Versions(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getCS8Versions && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__getCS8Versions(soap, "ns1:getCS8Versions", &a->ns1__getCS8Versions, ""))
				{	soap_flag_ns1__getCS8Versions--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getCS8Versions * SOAP_FMAC2 soap_instantiate___ns1__getCS8Versions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getCS8Versions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getCS8Versions *p;
	size_t k = sizeof(struct __ns1__getCS8Versions);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getCS8Versions);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getCS8Versions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getCS8Versions location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getCS8Versions, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getCS8Versions(struct soap *soap, const struct __ns1__getCS8Versions *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getCS8Versions(soap, tag ? tag : "-ns1:getCS8Versions", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getCS8Versions * SOAP_FMAC4 soap_get___ns1__getCS8Versions(struct soap *soap, struct __ns1__getCS8Versions *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getCS8Versions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ping(struct soap *soap, struct __ns1__ping *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ping = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ping(struct soap *soap, const struct __ns1__ping *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ping(soap, &a->ns1__ping);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ping(struct soap *soap, const char *tag, int id, const struct __ns1__ping *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ping(soap, "ns1:ping", -1, &a->ns1__ping, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ping * SOAP_FMAC4 soap_in___ns1__ping(struct soap *soap, const char *tag, struct __ns1__ping *a, const char *type)
{
	size_t soap_flag_ns1__ping = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ping *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ping, sizeof(struct __ns1__ping), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ping(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ping && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__ping(soap, "ns1:ping", &a->ns1__ping, ""))
				{	soap_flag_ns1__ping--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ping * SOAP_FMAC2 soap_instantiate___ns1__ping(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ping(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ping *p;
	size_t k = sizeof(struct __ns1__ping);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__ping);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__ping, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ping location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__ping, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ping(struct soap *soap, const struct __ns1__ping *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ping(soap, tag ? tag : "-ns1:ping", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ping * SOAP_FMAC4 soap_get___ns1__ping(struct soap *soap, struct __ns1__ping *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ping(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__findServer(struct soap *soap, struct __ns1__findServer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__findServer = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__findServer(struct soap *soap, const struct __ns1__findServer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__findServer(soap, &a->ns1__findServer);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__findServer(struct soap *soap, const char *tag, int id, const struct __ns1__findServer *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__findServer(soap, "ns1:findServer", -1, &a->ns1__findServer, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__findServer * SOAP_FMAC4 soap_in___ns1__findServer(struct soap *soap, const char *tag, struct __ns1__findServer *a, const char *type)
{
	size_t soap_flag_ns1__findServer = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__findServer *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__findServer, sizeof(struct __ns1__findServer), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__findServer(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__findServer && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__findServer(soap, "ns1:findServer", &a->ns1__findServer, ""))
				{	soap_flag_ns1__findServer--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__findServer * SOAP_FMAC2 soap_instantiate___ns1__findServer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__findServer(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__findServer *p;
	size_t k = sizeof(struct __ns1__findServer);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__findServer);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__findServer, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__findServer location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__findServer, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__findServer(struct soap *soap, const struct __ns1__findServer *a, const char *tag, const char *type)
{
	if (soap_out___ns1__findServer(soap, tag ? tag : "-ns1:findServer", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__findServer * SOAP_FMAC4 soap_get___ns1__findServer(struct soap *soap, struct __ns1__findServer *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__findServer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getSoapServerVersion(struct soap *soap, struct __ns1__getSoapServerVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getSoapServerVersion = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getSoapServerVersion(struct soap *soap, const struct __ns1__getSoapServerVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__getSoapServerVersion(soap, &a->ns1__getSoapServerVersion);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getSoapServerVersion(struct soap *soap, const char *tag, int id, const struct __ns1__getSoapServerVersion *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__getSoapServerVersion(soap, "ns1:getSoapServerVersion", -1, &a->ns1__getSoapServerVersion, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getSoapServerVersion * SOAP_FMAC4 soap_in___ns1__getSoapServerVersion(struct soap *soap, const char *tag, struct __ns1__getSoapServerVersion *a, const char *type)
{
	size_t soap_flag_ns1__getSoapServerVersion = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getSoapServerVersion *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getSoapServerVersion, sizeof(struct __ns1__getSoapServerVersion), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getSoapServerVersion(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getSoapServerVersion && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__getSoapServerVersion(soap, "ns1:getSoapServerVersion", &a->ns1__getSoapServerVersion, ""))
				{	soap_flag_ns1__getSoapServerVersion--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getSoapServerVersion * SOAP_FMAC2 soap_instantiate___ns1__getSoapServerVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getSoapServerVersion(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getSoapServerVersion *p;
	size_t k = sizeof(struct __ns1__getSoapServerVersion);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getSoapServerVersion);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getSoapServerVersion, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getSoapServerVersion location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getSoapServerVersion, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getSoapServerVersion(struct soap *soap, const struct __ns1__getSoapServerVersion *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getSoapServerVersion(soap, tag ? tag : "-ns1:getSoapServerVersion", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getSoapServerVersion * SOAP_FMAC4 soap_get___ns1__getSoapServerVersion(struct soap *soap, struct __ns1__getSoapServerVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getSoapServerVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ServerException_ = NULL;
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ServerException(soap, &a->ns1__ServerException_);
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_out_PointerTons1__ServerException(soap, "ns1:ServerException", -1, &a->ns1__ServerException_, ""))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag_ns1__ServerException_ = 1;
	size_t soap_flag_fault = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ServerException_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ServerException(soap, "ns1:ServerException", &a->ns1__ServerException_, "ns1:ServerException"))
				{	soap_flag_ns1__ServerException_--;
					continue;
				}
			}
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Detail *p;
	size_t k = sizeof(struct SOAP_ENV__Detail);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Detail);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Detail location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__sessionId = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SessionId(soap, &a->ns1__sessionId);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTons1__SessionId(soap, "ns1:sessionId", -1, &a->ns1__sessionId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	size_t soap_flag_ns1__sessionId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__sessionId && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__SessionId(soap, "ns1:sessionId", &a->ns1__sessionId, "ns1:SessionId"))
				{	soap_flag_ns1__sessionId--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Header *p;
	size_t k = sizeof(struct SOAP_ENV__Header);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Header);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Header location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns7__union_SoapPhysicalIoAttrib(struct soap *soap, int choice, const union _ns7__union_SoapPhysicalIoAttrib *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__ns7__union_SoapPhysicalIoAttrib_dioAttrib:
		soap_serialize_PointerTons7__SoapPhysicalDioAttrib(soap, &a->dioAttrib);
		break;
	case SOAP_UNION__ns7__union_SoapPhysicalIoAttrib_aioAttrib:
		soap_serialize_PointerTons7__SoapPhysicalAioAttrib(soap, &a->aioAttrib);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__union_SoapPhysicalIoAttrib(struct soap *soap, int choice, const union _ns7__union_SoapPhysicalIoAttrib *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns7__union_SoapPhysicalIoAttrib_dioAttrib:
		return soap_out_PointerTons7__SoapPhysicalDioAttrib(soap, "dioAttrib", -1, &a->dioAttrib, "");
	case SOAP_UNION__ns7__union_SoapPhysicalIoAttrib_aioAttrib:
		return soap_out_PointerTons7__SoapPhysicalAioAttrib(soap, "aioAttrib", -1, &a->aioAttrib, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns7__union_SoapPhysicalIoAttrib * SOAP_FMAC4 soap_in__ns7__union_SoapPhysicalIoAttrib(struct soap *soap, int *choice, union _ns7__union_SoapPhysicalIoAttrib *a)
{
	(void)a; /* appease -Wall -Werror */	soap->error = SOAP_TAG_MISMATCH;
	a->dioAttrib = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons7__SoapPhysicalDioAttrib(soap, "dioAttrib", &a->dioAttrib, "ns7:SoapPhysicalDioAttrib"))
	{	*choice = SOAP_UNION__ns7__union_SoapPhysicalIoAttrib_dioAttrib;
		return a;
	}
	a->aioAttrib = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons7__SoapPhysicalAioAttrib(soap, "aioAttrib", &a->aioAttrib, "ns7:SoapPhysicalAioAttrib"))
	{	*choice = SOAP_UNION__ns7__union_SoapPhysicalIoAttrib_aioAttrib;
		return a;
	}
	*choice = -1;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__getProjectResponse(struct soap *soap, _ns7__getProjectResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__getProjectResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__getProjectResponse(struct soap *soap, const char *tag, int id, _ns7__getProjectResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__getProjectResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__getProjectResponse ? type : NULL);
}

SOAP_FMAC3 _ns7__getProjectResponse ** SOAP_FMAC4 soap_in_PointerTo_ns7__getProjectResponse(struct soap *soap, const char *tag, _ns7__getProjectResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__getProjectResponse **)soap_malloc(soap, sizeof(_ns7__getProjectResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__getProjectResponse *)soap_instantiate__ns7__getProjectResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__getProjectResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__getProjectResponse, sizeof(_ns7__getProjectResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__getProjectResponse(struct soap *soap, _ns7__getProjectResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__getProjectResponse(soap, tag ? tag : "ns7:getProjectResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__getProjectResponse ** SOAP_FMAC4 soap_get_PointerTo_ns7__getProjectResponse(struct soap *soap, _ns7__getProjectResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__getProjectResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__getProject(struct soap *soap, _ns7__getProject *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__getProject))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__getProject(struct soap *soap, const char *tag, int id, _ns7__getProject *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__getProject, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__getProject ? type : NULL);
}

SOAP_FMAC3 _ns7__getProject ** SOAP_FMAC4 soap_in_PointerTo_ns7__getProject(struct soap *soap, const char *tag, _ns7__getProject **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__getProject **)soap_malloc(soap, sizeof(_ns7__getProject *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__getProject *)soap_instantiate__ns7__getProject(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__getProject **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__getProject, sizeof(_ns7__getProject), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__getProject(struct soap *soap, _ns7__getProject *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__getProject(soap, tag ? tag : "ns7:getProject", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__getProject ** SOAP_FMAC4 soap_get_PointerTo_ns7__getProject(struct soap *soap, _ns7__getProject **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__getProject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__SoapRobotDhParameters(struct soap *soap, _ns7__SoapRobotDhParameters *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__SoapRobotDhParameters))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__SoapRobotDhParameters(struct soap *soap, const char *tag, int id, _ns7__SoapRobotDhParameters *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__SoapRobotDhParameters, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__SoapRobotDhParameters ? type : NULL);
}

SOAP_FMAC3 _ns7__SoapRobotDhParameters ** SOAP_FMAC4 soap_in_PointerTo_ns7__SoapRobotDhParameters(struct soap *soap, const char *tag, _ns7__SoapRobotDhParameters **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__SoapRobotDhParameters **)soap_malloc(soap, sizeof(_ns7__SoapRobotDhParameters *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__SoapRobotDhParameters *)soap_instantiate__ns7__SoapRobotDhParameters(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__SoapRobotDhParameters **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__SoapRobotDhParameters, sizeof(_ns7__SoapRobotDhParameters), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__SoapRobotDhParameters(struct soap *soap, _ns7__SoapRobotDhParameters *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__SoapRobotDhParameters(soap, tag ? tag : "ns7:SoapRobotDhParameters", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__SoapRobotDhParameters ** SOAP_FMAC4 soap_get_PointerTo_ns7__SoapRobotDhParameters(struct soap *soap, _ns7__SoapRobotDhParameters **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__SoapRobotDhParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__getRobotDhParameters(struct soap *soap, _ns7__getRobotDhParameters *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__getRobotDhParameters))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__getRobotDhParameters(struct soap *soap, const char *tag, int id, _ns7__getRobotDhParameters *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__getRobotDhParameters, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__getRobotDhParameters ? type : NULL);
}

SOAP_FMAC3 _ns7__getRobotDhParameters ** SOAP_FMAC4 soap_in_PointerTo_ns7__getRobotDhParameters(struct soap *soap, const char *tag, _ns7__getRobotDhParameters **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__getRobotDhParameters **)soap_malloc(soap, sizeof(_ns7__getRobotDhParameters *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__getRobotDhParameters *)soap_instantiate__ns7__getRobotDhParameters(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__getRobotDhParameters **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__getRobotDhParameters, sizeof(_ns7__getRobotDhParameters), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__getRobotDhParameters(struct soap *soap, _ns7__getRobotDhParameters *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__getRobotDhParameters(soap, tag ? tag : "ns7:getRobotDhParameters", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__getRobotDhParameters ** SOAP_FMAC4 soap_get_PointerTo_ns7__getRobotDhParameters(struct soap *soap, _ns7__getRobotDhParameters **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__getRobotDhParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__getAllPhysicalIosResponse(struct soap *soap, _ns7__getAllPhysicalIosResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__getAllPhysicalIosResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__getAllPhysicalIosResponse(struct soap *soap, const char *tag, int id, _ns7__getAllPhysicalIosResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__getAllPhysicalIosResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__getAllPhysicalIosResponse ? type : NULL);
}

SOAP_FMAC3 _ns7__getAllPhysicalIosResponse ** SOAP_FMAC4 soap_in_PointerTo_ns7__getAllPhysicalIosResponse(struct soap *soap, const char *tag, _ns7__getAllPhysicalIosResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__getAllPhysicalIosResponse **)soap_malloc(soap, sizeof(_ns7__getAllPhysicalIosResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__getAllPhysicalIosResponse *)soap_instantiate__ns7__getAllPhysicalIosResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__getAllPhysicalIosResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__getAllPhysicalIosResponse, sizeof(_ns7__getAllPhysicalIosResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__getAllPhysicalIosResponse(struct soap *soap, _ns7__getAllPhysicalIosResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__getAllPhysicalIosResponse(soap, tag ? tag : "ns7:getAllPhysicalIosResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__getAllPhysicalIosResponse ** SOAP_FMAC4 soap_get_PointerTo_ns7__getAllPhysicalIosResponse(struct soap *soap, _ns7__getAllPhysicalIosResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__getAllPhysicalIosResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__getAllPhysicalIos(struct soap *soap, _ns7__getAllPhysicalIos *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__getAllPhysicalIos))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__getAllPhysicalIos(struct soap *soap, const char *tag, int id, _ns7__getAllPhysicalIos *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__getAllPhysicalIos, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__getAllPhysicalIos ? type : NULL);
}

SOAP_FMAC3 _ns7__getAllPhysicalIos ** SOAP_FMAC4 soap_in_PointerTo_ns7__getAllPhysicalIos(struct soap *soap, const char *tag, _ns7__getAllPhysicalIos **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__getAllPhysicalIos **)soap_malloc(soap, sizeof(_ns7__getAllPhysicalIos *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__getAllPhysicalIos *)soap_instantiate__ns7__getAllPhysicalIos(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__getAllPhysicalIos **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__getAllPhysicalIos, sizeof(_ns7__getAllPhysicalIos), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__getAllPhysicalIos(struct soap *soap, _ns7__getAllPhysicalIos *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__getAllPhysicalIos(soap, tag ? tag : "ns7:getAllPhysicalIos", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__getAllPhysicalIos ** SOAP_FMAC4 soap_get_PointerTo_ns7__getAllPhysicalIos(struct soap *soap, _ns7__getAllPhysicalIos **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__getAllPhysicalIos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__unlockAllIos(struct soap *soap, _ns7__unlockAllIos *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__unlockAllIos))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__unlockAllIos(struct soap *soap, const char *tag, int id, _ns7__unlockAllIos *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__unlockAllIos, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__unlockAllIos ? type : NULL);
}

SOAP_FMAC3 _ns7__unlockAllIos ** SOAP_FMAC4 soap_in_PointerTo_ns7__unlockAllIos(struct soap *soap, const char *tag, _ns7__unlockAllIos **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__unlockAllIos **)soap_malloc(soap, sizeof(_ns7__unlockAllIos *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__unlockAllIos *)soap_instantiate__ns7__unlockAllIos(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__unlockAllIos **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__unlockAllIos, sizeof(_ns7__unlockAllIos), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__unlockAllIos(struct soap *soap, _ns7__unlockAllIos *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__unlockAllIos(soap, tag ? tag : "ns7:unlockAllIos", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__unlockAllIos ** SOAP_FMAC4 soap_get_PointerTo_ns7__unlockAllIos(struct soap *soap, _ns7__unlockAllIos **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__unlockAllIos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__SoapAllPhysicalIoResponse(struct soap *soap, _ns7__SoapAllPhysicalIoResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__SoapAllPhysicalIoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__SoapAllPhysicalIoResponse(struct soap *soap, const char *tag, int id, _ns7__SoapAllPhysicalIoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__SoapAllPhysicalIoResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__SoapAllPhysicalIoResponse ? type : NULL);
}

SOAP_FMAC3 _ns7__SoapAllPhysicalIoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns7__SoapAllPhysicalIoResponse(struct soap *soap, const char *tag, _ns7__SoapAllPhysicalIoResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__SoapAllPhysicalIoResponse **)soap_malloc(soap, sizeof(_ns7__SoapAllPhysicalIoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__SoapAllPhysicalIoResponse *)soap_instantiate__ns7__SoapAllPhysicalIoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__SoapAllPhysicalIoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__SoapAllPhysicalIoResponse, sizeof(_ns7__SoapAllPhysicalIoResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__SoapAllPhysicalIoResponse(struct soap *soap, _ns7__SoapAllPhysicalIoResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__SoapAllPhysicalIoResponse(soap, tag ? tag : "ns7:SoapAllPhysicalIoResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__SoapAllPhysicalIoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns7__SoapAllPhysicalIoResponse(struct soap *soap, _ns7__SoapAllPhysicalIoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__SoapAllPhysicalIoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__lockAllIos(struct soap *soap, _ns7__lockAllIos *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__lockAllIos))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__lockAllIos(struct soap *soap, const char *tag, int id, _ns7__lockAllIos *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__lockAllIos, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__lockAllIos ? type : NULL);
}

SOAP_FMAC3 _ns7__lockAllIos ** SOAP_FMAC4 soap_in_PointerTo_ns7__lockAllIos(struct soap *soap, const char *tag, _ns7__lockAllIos **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__lockAllIos **)soap_malloc(soap, sizeof(_ns7__lockAllIos *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__lockAllIos *)soap_instantiate__ns7__lockAllIos(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__lockAllIos **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__lockAllIos, sizeof(_ns7__lockAllIos), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__lockAllIos(struct soap *soap, _ns7__lockAllIos *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__lockAllIos(soap, tag ? tag : "ns7:lockAllIos", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__lockAllIos ** SOAP_FMAC4 soap_get_PointerTo_ns7__lockAllIos(struct soap *soap, _ns7__lockAllIos **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__lockAllIos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__unlockIosResponse(struct soap *soap, _ns7__unlockIosResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__unlockIosResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__unlockIosResponse(struct soap *soap, const char *tag, int id, _ns7__unlockIosResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__unlockIosResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__unlockIosResponse ? type : NULL);
}

SOAP_FMAC3 _ns7__unlockIosResponse ** SOAP_FMAC4 soap_in_PointerTo_ns7__unlockIosResponse(struct soap *soap, const char *tag, _ns7__unlockIosResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__unlockIosResponse **)soap_malloc(soap, sizeof(_ns7__unlockIosResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__unlockIosResponse *)soap_instantiate__ns7__unlockIosResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__unlockIosResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__unlockIosResponse, sizeof(_ns7__unlockIosResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__unlockIosResponse(struct soap *soap, _ns7__unlockIosResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__unlockIosResponse(soap, tag ? tag : "ns7:unlockIosResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__unlockIosResponse ** SOAP_FMAC4 soap_get_PointerTo_ns7__unlockIosResponse(struct soap *soap, _ns7__unlockIosResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__unlockIosResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__unlockIos(struct soap *soap, _ns7__unlockIos *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__unlockIos))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__unlockIos(struct soap *soap, const char *tag, int id, _ns7__unlockIos *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__unlockIos, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__unlockIos ? type : NULL);
}

SOAP_FMAC3 _ns7__unlockIos ** SOAP_FMAC4 soap_in_PointerTo_ns7__unlockIos(struct soap *soap, const char *tag, _ns7__unlockIos **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__unlockIos **)soap_malloc(soap, sizeof(_ns7__unlockIos *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__unlockIos *)soap_instantiate__ns7__unlockIos(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__unlockIos **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__unlockIos, sizeof(_ns7__unlockIos), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__unlockIos(struct soap *soap, _ns7__unlockIos *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__unlockIos(soap, tag ? tag : "ns7:unlockIos", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__unlockIos ** SOAP_FMAC4 soap_get_PointerTo_ns7__unlockIos(struct soap *soap, _ns7__unlockIos **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__unlockIos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__lockIosResponse(struct soap *soap, _ns7__lockIosResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__lockIosResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__lockIosResponse(struct soap *soap, const char *tag, int id, _ns7__lockIosResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__lockIosResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__lockIosResponse ? type : NULL);
}

SOAP_FMAC3 _ns7__lockIosResponse ** SOAP_FMAC4 soap_in_PointerTo_ns7__lockIosResponse(struct soap *soap, const char *tag, _ns7__lockIosResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__lockIosResponse **)soap_malloc(soap, sizeof(_ns7__lockIosResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__lockIosResponse *)soap_instantiate__ns7__lockIosResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__lockIosResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__lockIosResponse, sizeof(_ns7__lockIosResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__lockIosResponse(struct soap *soap, _ns7__lockIosResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__lockIosResponse(soap, tag ? tag : "ns7:lockIosResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__lockIosResponse ** SOAP_FMAC4 soap_get_PointerTo_ns7__lockIosResponse(struct soap *soap, _ns7__lockIosResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__lockIosResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__lockIos(struct soap *soap, _ns7__lockIos *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__lockIos))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__lockIos(struct soap *soap, const char *tag, int id, _ns7__lockIos *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__lockIos, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__lockIos ? type : NULL);
}

SOAP_FMAC3 _ns7__lockIos ** SOAP_FMAC4 soap_in_PointerTo_ns7__lockIos(struct soap *soap, const char *tag, _ns7__lockIos **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__lockIos **)soap_malloc(soap, sizeof(_ns7__lockIos *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__lockIos *)soap_instantiate__ns7__lockIos(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__lockIos **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__lockIos, sizeof(_ns7__lockIos), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__lockIos(struct soap *soap, _ns7__lockIos *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__lockIos(soap, tag ? tag : "ns7:lockIos", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__lockIos ** SOAP_FMAC4 soap_get_PointerTo_ns7__lockIos(struct soap *soap, _ns7__lockIos **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__lockIos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__writeIosResponse(struct soap *soap, _ns7__writeIosResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__writeIosResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__writeIosResponse(struct soap *soap, const char *tag, int id, _ns7__writeIosResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__writeIosResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__writeIosResponse ? type : NULL);
}

SOAP_FMAC3 _ns7__writeIosResponse ** SOAP_FMAC4 soap_in_PointerTo_ns7__writeIosResponse(struct soap *soap, const char *tag, _ns7__writeIosResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__writeIosResponse **)soap_malloc(soap, sizeof(_ns7__writeIosResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__writeIosResponse *)soap_instantiate__ns7__writeIosResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__writeIosResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__writeIosResponse, sizeof(_ns7__writeIosResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__writeIosResponse(struct soap *soap, _ns7__writeIosResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__writeIosResponse(soap, tag ? tag : "ns7:writeIosResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__writeIosResponse ** SOAP_FMAC4 soap_get_PointerTo_ns7__writeIosResponse(struct soap *soap, _ns7__writeIosResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__writeIosResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__writeIos(struct soap *soap, _ns7__writeIos *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__writeIos))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__writeIos(struct soap *soap, const char *tag, int id, _ns7__writeIos *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__writeIos, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__writeIos ? type : NULL);
}

SOAP_FMAC3 _ns7__writeIos ** SOAP_FMAC4 soap_in_PointerTo_ns7__writeIos(struct soap *soap, const char *tag, _ns7__writeIos **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__writeIos **)soap_malloc(soap, sizeof(_ns7__writeIos *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__writeIos *)soap_instantiate__ns7__writeIos(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__writeIos **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__writeIos, sizeof(_ns7__writeIos), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__writeIos(struct soap *soap, _ns7__writeIos *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__writeIos(soap, tag ? tag : "ns7:writeIos", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__writeIos ** SOAP_FMAC4 soap_get_PointerTo_ns7__writeIos(struct soap *soap, _ns7__writeIos **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__writeIos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__readIosResponse(struct soap *soap, _ns7__readIosResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__readIosResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__readIosResponse(struct soap *soap, const char *tag, int id, _ns7__readIosResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__readIosResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__readIosResponse ? type : NULL);
}

SOAP_FMAC3 _ns7__readIosResponse ** SOAP_FMAC4 soap_in_PointerTo_ns7__readIosResponse(struct soap *soap, const char *tag, _ns7__readIosResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__readIosResponse **)soap_malloc(soap, sizeof(_ns7__readIosResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__readIosResponse *)soap_instantiate__ns7__readIosResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__readIosResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__readIosResponse, sizeof(_ns7__readIosResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__readIosResponse(struct soap *soap, _ns7__readIosResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__readIosResponse(soap, tag ? tag : "ns7:readIosResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__readIosResponse ** SOAP_FMAC4 soap_get_PointerTo_ns7__readIosResponse(struct soap *soap, _ns7__readIosResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__readIosResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__readIos(struct soap *soap, _ns7__readIos *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__readIos))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__readIos(struct soap *soap, const char *tag, int id, _ns7__readIos *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__readIos, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__readIos ? type : NULL);
}

SOAP_FMAC3 _ns7__readIos ** SOAP_FMAC4 soap_in_PointerTo_ns7__readIos(struct soap *soap, const char *tag, _ns7__readIos **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__readIos **)soap_malloc(soap, sizeof(_ns7__readIos *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__readIos *)soap_instantiate__ns7__readIos(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__readIos **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__readIos, sizeof(_ns7__readIos), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__readIos(struct soap *soap, _ns7__readIos *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__readIos(soap, tag ? tag : "ns7:readIos", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__readIos ** SOAP_FMAC4 soap_get_PointerTo_ns7__readIos(struct soap *soap, _ns7__readIos **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__readIos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__replaceLineResponse(struct soap *soap, _ns7__replaceLineResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__replaceLineResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__replaceLineResponse(struct soap *soap, const char *tag, int id, _ns7__replaceLineResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__replaceLineResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__replaceLineResponse ? type : NULL);
}

SOAP_FMAC3 _ns7__replaceLineResponse ** SOAP_FMAC4 soap_in_PointerTo_ns7__replaceLineResponse(struct soap *soap, const char *tag, _ns7__replaceLineResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__replaceLineResponse **)soap_malloc(soap, sizeof(_ns7__replaceLineResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__replaceLineResponse *)soap_instantiate__ns7__replaceLineResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__replaceLineResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__replaceLineResponse, sizeof(_ns7__replaceLineResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__replaceLineResponse(struct soap *soap, _ns7__replaceLineResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__replaceLineResponse(soap, tag ? tag : "ns7:replaceLineResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__replaceLineResponse ** SOAP_FMAC4 soap_get_PointerTo_ns7__replaceLineResponse(struct soap *soap, _ns7__replaceLineResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__replaceLineResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__replaceLine(struct soap *soap, _ns7__replaceLine *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__replaceLine))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__replaceLine(struct soap *soap, const char *tag, int id, _ns7__replaceLine *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__replaceLine, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__replaceLine ? type : NULL);
}

SOAP_FMAC3 _ns7__replaceLine ** SOAP_FMAC4 soap_in_PointerTo_ns7__replaceLine(struct soap *soap, const char *tag, _ns7__replaceLine **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__replaceLine **)soap_malloc(soap, sizeof(_ns7__replaceLine *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__replaceLine *)soap_instantiate__ns7__replaceLine(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__replaceLine **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__replaceLine, sizeof(_ns7__replaceLine), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__replaceLine(struct soap *soap, _ns7__replaceLine *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__replaceLine(soap, tag ? tag : "ns7:replaceLine", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__replaceLine ** SOAP_FMAC4 soap_get_PointerTo_ns7__replaceLine(struct soap *soap, _ns7__replaceLine **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__replaceLine(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__setCurrentInstructionResponse(struct soap *soap, _ns7__setCurrentInstructionResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__setCurrentInstructionResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__setCurrentInstructionResponse(struct soap *soap, const char *tag, int id, _ns7__setCurrentInstructionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__setCurrentInstructionResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__setCurrentInstructionResponse ? type : NULL);
}

SOAP_FMAC3 _ns7__setCurrentInstructionResponse ** SOAP_FMAC4 soap_in_PointerTo_ns7__setCurrentInstructionResponse(struct soap *soap, const char *tag, _ns7__setCurrentInstructionResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__setCurrentInstructionResponse **)soap_malloc(soap, sizeof(_ns7__setCurrentInstructionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__setCurrentInstructionResponse *)soap_instantiate__ns7__setCurrentInstructionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__setCurrentInstructionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__setCurrentInstructionResponse, sizeof(_ns7__setCurrentInstructionResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__setCurrentInstructionResponse(struct soap *soap, _ns7__setCurrentInstructionResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__setCurrentInstructionResponse(soap, tag ? tag : "ns7:setCurrentInstructionResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__setCurrentInstructionResponse ** SOAP_FMAC4 soap_get_PointerTo_ns7__setCurrentInstructionResponse(struct soap *soap, _ns7__setCurrentInstructionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__setCurrentInstructionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__setCurrentInstruction(struct soap *soap, _ns7__setCurrentInstruction *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__setCurrentInstruction))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__setCurrentInstruction(struct soap *soap, const char *tag, int id, _ns7__setCurrentInstruction *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__setCurrentInstruction, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__setCurrentInstruction ? type : NULL);
}

SOAP_FMAC3 _ns7__setCurrentInstruction ** SOAP_FMAC4 soap_in_PointerTo_ns7__setCurrentInstruction(struct soap *soap, const char *tag, _ns7__setCurrentInstruction **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__setCurrentInstruction **)soap_malloc(soap, sizeof(_ns7__setCurrentInstruction *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__setCurrentInstruction *)soap_instantiate__ns7__setCurrentInstruction(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__setCurrentInstruction **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__setCurrentInstruction, sizeof(_ns7__setCurrentInstruction), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__setCurrentInstruction(struct soap *soap, _ns7__setCurrentInstruction *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__setCurrentInstruction(soap, tag ? tag : "ns7:setCurrentInstruction", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__setCurrentInstruction ** SOAP_FMAC4 soap_get_PointerTo_ns7__setCurrentInstruction(struct soap *soap, _ns7__setCurrentInstruction **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__setCurrentInstruction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__setProjectAsModifiedResponse(struct soap *soap, _ns7__setProjectAsModifiedResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__setProjectAsModifiedResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__setProjectAsModifiedResponse(struct soap *soap, const char *tag, int id, _ns7__setProjectAsModifiedResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__setProjectAsModifiedResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__setProjectAsModifiedResponse ? type : NULL);
}

SOAP_FMAC3 _ns7__setProjectAsModifiedResponse ** SOAP_FMAC4 soap_in_PointerTo_ns7__setProjectAsModifiedResponse(struct soap *soap, const char *tag, _ns7__setProjectAsModifiedResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__setProjectAsModifiedResponse **)soap_malloc(soap, sizeof(_ns7__setProjectAsModifiedResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__setProjectAsModifiedResponse *)soap_instantiate__ns7__setProjectAsModifiedResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__setProjectAsModifiedResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__setProjectAsModifiedResponse, sizeof(_ns7__setProjectAsModifiedResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__setProjectAsModifiedResponse(struct soap *soap, _ns7__setProjectAsModifiedResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__setProjectAsModifiedResponse(soap, tag ? tag : "ns7:setProjectAsModifiedResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__setProjectAsModifiedResponse ** SOAP_FMAC4 soap_get_PointerTo_ns7__setProjectAsModifiedResponse(struct soap *soap, _ns7__setProjectAsModifiedResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__setProjectAsModifiedResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__setProjectAsModified(struct soap *soap, _ns7__setProjectAsModified *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__setProjectAsModified))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__setProjectAsModified(struct soap *soap, const char *tag, int id, _ns7__setProjectAsModified *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__setProjectAsModified, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__setProjectAsModified ? type : NULL);
}

SOAP_FMAC3 _ns7__setProjectAsModified ** SOAP_FMAC4 soap_in_PointerTo_ns7__setProjectAsModified(struct soap *soap, const char *tag, _ns7__setProjectAsModified **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__setProjectAsModified **)soap_malloc(soap, sizeof(_ns7__setProjectAsModified *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__setProjectAsModified *)soap_instantiate__ns7__setProjectAsModified(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__setProjectAsModified **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__setProjectAsModified, sizeof(_ns7__setProjectAsModified), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__setProjectAsModified(struct soap *soap, _ns7__setProjectAsModified *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__setProjectAsModified(soap, tag ? tag : "ns7:setProjectAsModified", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__setProjectAsModified ** SOAP_FMAC4 soap_get_PointerTo_ns7__setProjectAsModified(struct soap *soap, _ns7__setProjectAsModified **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__setProjectAsModified(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__execVal3Response(struct soap *soap, _ns7__execVal3Response *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__execVal3Response))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__execVal3Response(struct soap *soap, const char *tag, int id, _ns7__execVal3Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__execVal3Response, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__execVal3Response ? type : NULL);
}

SOAP_FMAC3 _ns7__execVal3Response ** SOAP_FMAC4 soap_in_PointerTo_ns7__execVal3Response(struct soap *soap, const char *tag, _ns7__execVal3Response **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__execVal3Response **)soap_malloc(soap, sizeof(_ns7__execVal3Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__execVal3Response *)soap_instantiate__ns7__execVal3Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__execVal3Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__execVal3Response, sizeof(_ns7__execVal3Response), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__execVal3Response(struct soap *soap, _ns7__execVal3Response *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__execVal3Response(soap, tag ? tag : "ns7:execVal3Response", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__execVal3Response ** SOAP_FMAC4 soap_get_PointerTo_ns7__execVal3Response(struct soap *soap, _ns7__execVal3Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__execVal3Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__execVal3(struct soap *soap, _ns7__execVal3 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__execVal3))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__execVal3(struct soap *soap, const char *tag, int id, _ns7__execVal3 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__execVal3, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__execVal3 ? type : NULL);
}

SOAP_FMAC3 _ns7__execVal3 ** SOAP_FMAC4 soap_in_PointerTo_ns7__execVal3(struct soap *soap, const char *tag, _ns7__execVal3 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__execVal3 **)soap_malloc(soap, sizeof(_ns7__execVal3 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__execVal3 *)soap_instantiate__ns7__execVal3(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__execVal3 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__execVal3, sizeof(_ns7__execVal3), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__execVal3(struct soap *soap, _ns7__execVal3 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__execVal3(soap, tag ? tag : "ns7:execVal3", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__execVal3 ** SOAP_FMAC4 soap_get_PointerTo_ns7__execVal3(struct soap *soap, _ns7__execVal3 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__execVal3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__getWatchResponse(struct soap *soap, _ns7__getWatchResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__getWatchResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__getWatchResponse(struct soap *soap, const char *tag, int id, _ns7__getWatchResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__getWatchResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__getWatchResponse ? type : NULL);
}

SOAP_FMAC3 _ns7__getWatchResponse ** SOAP_FMAC4 soap_in_PointerTo_ns7__getWatchResponse(struct soap *soap, const char *tag, _ns7__getWatchResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__getWatchResponse **)soap_malloc(soap, sizeof(_ns7__getWatchResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__getWatchResponse *)soap_instantiate__ns7__getWatchResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__getWatchResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__getWatchResponse, sizeof(_ns7__getWatchResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__getWatchResponse(struct soap *soap, _ns7__getWatchResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__getWatchResponse(soap, tag ? tag : "ns7:getWatchResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__getWatchResponse ** SOAP_FMAC4 soap_get_PointerTo_ns7__getWatchResponse(struct soap *soap, _ns7__getWatchResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__getWatchResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__getWatches(struct soap *soap, _ns7__getWatches *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__getWatches))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__getWatches(struct soap *soap, const char *tag, int id, _ns7__getWatches *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__getWatches, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__getWatches ? type : NULL);
}

SOAP_FMAC3 _ns7__getWatches ** SOAP_FMAC4 soap_in_PointerTo_ns7__getWatches(struct soap *soap, const char *tag, _ns7__getWatches **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__getWatches **)soap_malloc(soap, sizeof(_ns7__getWatches *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__getWatches *)soap_instantiate__ns7__getWatches(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__getWatches **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__getWatches, sizeof(_ns7__getWatches), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__getWatches(struct soap *soap, _ns7__getWatches *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__getWatches(soap, tag ? tag : "ns7:getWatches", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__getWatches ** SOAP_FMAC4 soap_get_PointerTo_ns7__getWatches(struct soap *soap, _ns7__getWatches **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__getWatches(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__getStackFrameResponse(struct soap *soap, _ns7__getStackFrameResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__getStackFrameResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__getStackFrameResponse(struct soap *soap, const char *tag, int id, _ns7__getStackFrameResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__getStackFrameResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__getStackFrameResponse ? type : NULL);
}

SOAP_FMAC3 _ns7__getStackFrameResponse ** SOAP_FMAC4 soap_in_PointerTo_ns7__getStackFrameResponse(struct soap *soap, const char *tag, _ns7__getStackFrameResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__getStackFrameResponse **)soap_malloc(soap, sizeof(_ns7__getStackFrameResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__getStackFrameResponse *)soap_instantiate__ns7__getStackFrameResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__getStackFrameResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__getStackFrameResponse, sizeof(_ns7__getStackFrameResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__getStackFrameResponse(struct soap *soap, _ns7__getStackFrameResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__getStackFrameResponse(soap, tag ? tag : "ns7:getStackFrameResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__getStackFrameResponse ** SOAP_FMAC4 soap_get_PointerTo_ns7__getStackFrameResponse(struct soap *soap, _ns7__getStackFrameResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__getStackFrameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__getStackFrame(struct soap *soap, _ns7__getStackFrame *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__getStackFrame))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__getStackFrame(struct soap *soap, const char *tag, int id, _ns7__getStackFrame *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__getStackFrame, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__getStackFrame ? type : NULL);
}

SOAP_FMAC3 _ns7__getStackFrame ** SOAP_FMAC4 soap_in_PointerTo_ns7__getStackFrame(struct soap *soap, const char *tag, _ns7__getStackFrame **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__getStackFrame **)soap_malloc(soap, sizeof(_ns7__getStackFrame *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__getStackFrame *)soap_instantiate__ns7__getStackFrame(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__getStackFrame **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__getStackFrame, sizeof(_ns7__getStackFrame), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__getStackFrame(struct soap *soap, _ns7__getStackFrame *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__getStackFrame(soap, tag ? tag : "ns7:getStackFrame", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__getStackFrame ** SOAP_FMAC4 soap_get_PointerTo_ns7__getStackFrame(struct soap *soap, _ns7__getStackFrame **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__getStackFrame(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__getCallStackResponse(struct soap *soap, _ns7__getCallStackResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__getCallStackResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__getCallStackResponse(struct soap *soap, const char *tag, int id, _ns7__getCallStackResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__getCallStackResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__getCallStackResponse ? type : NULL);
}

SOAP_FMAC3 _ns7__getCallStackResponse ** SOAP_FMAC4 soap_in_PointerTo_ns7__getCallStackResponse(struct soap *soap, const char *tag, _ns7__getCallStackResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__getCallStackResponse **)soap_malloc(soap, sizeof(_ns7__getCallStackResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__getCallStackResponse *)soap_instantiate__ns7__getCallStackResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__getCallStackResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__getCallStackResponse, sizeof(_ns7__getCallStackResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__getCallStackResponse(struct soap *soap, _ns7__getCallStackResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__getCallStackResponse(soap, tag ? tag : "ns7:getCallStackResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__getCallStackResponse ** SOAP_FMAC4 soap_get_PointerTo_ns7__getCallStackResponse(struct soap *soap, _ns7__getCallStackResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__getCallStackResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__getCallStack(struct soap *soap, _ns7__getCallStack *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__getCallStack))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__getCallStack(struct soap *soap, const char *tag, int id, _ns7__getCallStack *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__getCallStack, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__getCallStack ? type : NULL);
}

SOAP_FMAC3 _ns7__getCallStack ** SOAP_FMAC4 soap_in_PointerTo_ns7__getCallStack(struct soap *soap, const char *tag, _ns7__getCallStack **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__getCallStack **)soap_malloc(soap, sizeof(_ns7__getCallStack *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__getCallStack *)soap_instantiate__ns7__getCallStack(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__getCallStack **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__getCallStack, sizeof(_ns7__getCallStack), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__getCallStack(struct soap *soap, _ns7__getCallStack *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__getCallStack(soap, tag ? tag : "ns7:getCallStack", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__getCallStack ** SOAP_FMAC4 soap_get_PointerTo_ns7__getCallStack(struct soap *soap, _ns7__getCallStack **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__getCallStack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__unsubscribeResponse(struct soap *soap, _ns7__unsubscribeResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__unsubscribeResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__unsubscribeResponse(struct soap *soap, const char *tag, int id, _ns7__unsubscribeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__unsubscribeResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__unsubscribeResponse ? type : NULL);
}

SOAP_FMAC3 _ns7__unsubscribeResponse ** SOAP_FMAC4 soap_in_PointerTo_ns7__unsubscribeResponse(struct soap *soap, const char *tag, _ns7__unsubscribeResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__unsubscribeResponse **)soap_malloc(soap, sizeof(_ns7__unsubscribeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__unsubscribeResponse *)soap_instantiate__ns7__unsubscribeResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__unsubscribeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__unsubscribeResponse, sizeof(_ns7__unsubscribeResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__unsubscribeResponse(struct soap *soap, _ns7__unsubscribeResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__unsubscribeResponse(soap, tag ? tag : "ns7:unsubscribeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__unsubscribeResponse ** SOAP_FMAC4 soap_get_PointerTo_ns7__unsubscribeResponse(struct soap *soap, _ns7__unsubscribeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__unsubscribeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__unsubscribeToControllerEvents(struct soap *soap, _ns7__unsubscribeToControllerEvents *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__unsubscribeToControllerEvents))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__unsubscribeToControllerEvents(struct soap *soap, const char *tag, int id, _ns7__unsubscribeToControllerEvents *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__unsubscribeToControllerEvents, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__unsubscribeToControllerEvents ? type : NULL);
}

SOAP_FMAC3 _ns7__unsubscribeToControllerEvents ** SOAP_FMAC4 soap_in_PointerTo_ns7__unsubscribeToControllerEvents(struct soap *soap, const char *tag, _ns7__unsubscribeToControllerEvents **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__unsubscribeToControllerEvents **)soap_malloc(soap, sizeof(_ns7__unsubscribeToControllerEvents *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__unsubscribeToControllerEvents *)soap_instantiate__ns7__unsubscribeToControllerEvents(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__unsubscribeToControllerEvents **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__unsubscribeToControllerEvents, sizeof(_ns7__unsubscribeToControllerEvents), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__unsubscribeToControllerEvents(struct soap *soap, _ns7__unsubscribeToControllerEvents *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__unsubscribeToControllerEvents(soap, tag ? tag : "ns7:unsubscribeToControllerEvents", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__unsubscribeToControllerEvents ** SOAP_FMAC4 soap_get_PointerTo_ns7__unsubscribeToControllerEvents(struct soap *soap, _ns7__unsubscribeToControllerEvents **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__unsubscribeToControllerEvents(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__subscribeResponse(struct soap *soap, _ns7__subscribeResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__subscribeResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__subscribeResponse(struct soap *soap, const char *tag, int id, _ns7__subscribeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__subscribeResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__subscribeResponse ? type : NULL);
}

SOAP_FMAC3 _ns7__subscribeResponse ** SOAP_FMAC4 soap_in_PointerTo_ns7__subscribeResponse(struct soap *soap, const char *tag, _ns7__subscribeResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__subscribeResponse **)soap_malloc(soap, sizeof(_ns7__subscribeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__subscribeResponse *)soap_instantiate__ns7__subscribeResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__subscribeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__subscribeResponse, sizeof(_ns7__subscribeResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__subscribeResponse(struct soap *soap, _ns7__subscribeResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__subscribeResponse(soap, tag ? tag : "ns7:subscribeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__subscribeResponse ** SOAP_FMAC4 soap_get_PointerTo_ns7__subscribeResponse(struct soap *soap, _ns7__subscribeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__subscribeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__subscribeToControllerEvents(struct soap *soap, _ns7__subscribeToControllerEvents *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__subscribeToControllerEvents))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__subscribeToControllerEvents(struct soap *soap, const char *tag, int id, _ns7__subscribeToControllerEvents *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__subscribeToControllerEvents, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__subscribeToControllerEvents ? type : NULL);
}

SOAP_FMAC3 _ns7__subscribeToControllerEvents ** SOAP_FMAC4 soap_in_PointerTo_ns7__subscribeToControllerEvents(struct soap *soap, const char *tag, _ns7__subscribeToControllerEvents **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__subscribeToControllerEvents **)soap_malloc(soap, sizeof(_ns7__subscribeToControllerEvents *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__subscribeToControllerEvents *)soap_instantiate__ns7__subscribeToControllerEvents(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__subscribeToControllerEvents **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__subscribeToControllerEvents, sizeof(_ns7__subscribeToControllerEvents), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__subscribeToControllerEvents(struct soap *soap, _ns7__subscribeToControllerEvents *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__subscribeToControllerEvents(soap, tag ? tag : "ns7:subscribeToControllerEvents", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__subscribeToControllerEvents ** SOAP_FMAC4 soap_get_PointerTo_ns7__subscribeToControllerEvents(struct soap *soap, _ns7__subscribeToControllerEvents **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__subscribeToControllerEvents(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__taskStepResponse(struct soap *soap, _ns7__taskStepResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__taskStepResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__taskStepResponse(struct soap *soap, const char *tag, int id, _ns7__taskStepResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__taskStepResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__taskStepResponse ? type : NULL);
}

SOAP_FMAC3 _ns7__taskStepResponse ** SOAP_FMAC4 soap_in_PointerTo_ns7__taskStepResponse(struct soap *soap, const char *tag, _ns7__taskStepResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__taskStepResponse **)soap_malloc(soap, sizeof(_ns7__taskStepResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__taskStepResponse *)soap_instantiate__ns7__taskStepResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__taskStepResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__taskStepResponse, sizeof(_ns7__taskStepResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__taskStepResponse(struct soap *soap, _ns7__taskStepResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__taskStepResponse(soap, tag ? tag : "ns7:taskStepResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__taskStepResponse ** SOAP_FMAC4 soap_get_PointerTo_ns7__taskStepResponse(struct soap *soap, _ns7__taskStepResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__taskStepResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__taskStep(struct soap *soap, _ns7__taskStep *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__taskStep))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__taskStep(struct soap *soap, const char *tag, int id, _ns7__taskStep *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__taskStep, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__taskStep ? type : NULL);
}

SOAP_FMAC3 _ns7__taskStep ** SOAP_FMAC4 soap_in_PointerTo_ns7__taskStep(struct soap *soap, const char *tag, _ns7__taskStep **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__taskStep **)soap_malloc(soap, sizeof(_ns7__taskStep *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__taskStep *)soap_instantiate__ns7__taskStep(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__taskStep **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__taskStep, sizeof(_ns7__taskStep), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__taskStep(struct soap *soap, _ns7__taskStep *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__taskStep(soap, tag ? tag : "ns7:taskStep", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__taskStep ** SOAP_FMAC4 soap_get_PointerTo_ns7__taskStep(struct soap *soap, _ns7__taskStep **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__taskStep(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__taskKillResponse(struct soap *soap, _ns7__taskKillResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__taskKillResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__taskKillResponse(struct soap *soap, const char *tag, int id, _ns7__taskKillResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__taskKillResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__taskKillResponse ? type : NULL);
}

SOAP_FMAC3 _ns7__taskKillResponse ** SOAP_FMAC4 soap_in_PointerTo_ns7__taskKillResponse(struct soap *soap, const char *tag, _ns7__taskKillResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__taskKillResponse **)soap_malloc(soap, sizeof(_ns7__taskKillResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__taskKillResponse *)soap_instantiate__ns7__taskKillResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__taskKillResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__taskKillResponse, sizeof(_ns7__taskKillResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__taskKillResponse(struct soap *soap, _ns7__taskKillResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__taskKillResponse(soap, tag ? tag : "ns7:taskKillResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__taskKillResponse ** SOAP_FMAC4 soap_get_PointerTo_ns7__taskKillResponse(struct soap *soap, _ns7__taskKillResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__taskKillResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__taskKill(struct soap *soap, _ns7__taskKill *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__taskKill))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__taskKill(struct soap *soap, const char *tag, int id, _ns7__taskKill *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__taskKill, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__taskKill ? type : NULL);
}

SOAP_FMAC3 _ns7__taskKill ** SOAP_FMAC4 soap_in_PointerTo_ns7__taskKill(struct soap *soap, const char *tag, _ns7__taskKill **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__taskKill **)soap_malloc(soap, sizeof(_ns7__taskKill *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__taskKill *)soap_instantiate__ns7__taskKill(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__taskKill **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__taskKill, sizeof(_ns7__taskKill), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__taskKill(struct soap *soap, _ns7__taskKill *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__taskKill(soap, tag ? tag : "ns7:taskKill", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__taskKill ** SOAP_FMAC4 soap_get_PointerTo_ns7__taskKill(struct soap *soap, _ns7__taskKill **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__taskKill(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__taskResumeResponse(struct soap *soap, _ns7__taskResumeResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__taskResumeResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__taskResumeResponse(struct soap *soap, const char *tag, int id, _ns7__taskResumeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__taskResumeResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__taskResumeResponse ? type : NULL);
}

SOAP_FMAC3 _ns7__taskResumeResponse ** SOAP_FMAC4 soap_in_PointerTo_ns7__taskResumeResponse(struct soap *soap, const char *tag, _ns7__taskResumeResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__taskResumeResponse **)soap_malloc(soap, sizeof(_ns7__taskResumeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__taskResumeResponse *)soap_instantiate__ns7__taskResumeResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__taskResumeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__taskResumeResponse, sizeof(_ns7__taskResumeResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__taskResumeResponse(struct soap *soap, _ns7__taskResumeResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__taskResumeResponse(soap, tag ? tag : "ns7:taskResumeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__taskResumeResponse ** SOAP_FMAC4 soap_get_PointerTo_ns7__taskResumeResponse(struct soap *soap, _ns7__taskResumeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__taskResumeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__taskResume(struct soap *soap, _ns7__taskResume *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__taskResume))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__taskResume(struct soap *soap, const char *tag, int id, _ns7__taskResume *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__taskResume, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__taskResume ? type : NULL);
}

SOAP_FMAC3 _ns7__taskResume ** SOAP_FMAC4 soap_in_PointerTo_ns7__taskResume(struct soap *soap, const char *tag, _ns7__taskResume **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__taskResume **)soap_malloc(soap, sizeof(_ns7__taskResume *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__taskResume *)soap_instantiate__ns7__taskResume(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__taskResume **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__taskResume, sizeof(_ns7__taskResume), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__taskResume(struct soap *soap, _ns7__taskResume *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__taskResume(soap, tag ? tag : "ns7:taskResume", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__taskResume ** SOAP_FMAC4 soap_get_PointerTo_ns7__taskResume(struct soap *soap, _ns7__taskResume **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__taskResume(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__taskSuspendResponse(struct soap *soap, _ns7__taskSuspendResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__taskSuspendResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__taskSuspendResponse(struct soap *soap, const char *tag, int id, _ns7__taskSuspendResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__taskSuspendResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__taskSuspendResponse ? type : NULL);
}

SOAP_FMAC3 _ns7__taskSuspendResponse ** SOAP_FMAC4 soap_in_PointerTo_ns7__taskSuspendResponse(struct soap *soap, const char *tag, _ns7__taskSuspendResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__taskSuspendResponse **)soap_malloc(soap, sizeof(_ns7__taskSuspendResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__taskSuspendResponse *)soap_instantiate__ns7__taskSuspendResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__taskSuspendResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__taskSuspendResponse, sizeof(_ns7__taskSuspendResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__taskSuspendResponse(struct soap *soap, _ns7__taskSuspendResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__taskSuspendResponse(soap, tag ? tag : "ns7:taskSuspendResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__taskSuspendResponse ** SOAP_FMAC4 soap_get_PointerTo_ns7__taskSuspendResponse(struct soap *soap, _ns7__taskSuspendResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__taskSuspendResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__taskSuspend(struct soap *soap, _ns7__taskSuspend *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__taskSuspend))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__taskSuspend(struct soap *soap, const char *tag, int id, _ns7__taskSuspend *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__taskSuspend, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__taskSuspend ? type : NULL);
}

SOAP_FMAC3 _ns7__taskSuspend ** SOAP_FMAC4 soap_in_PointerTo_ns7__taskSuspend(struct soap *soap, const char *tag, _ns7__taskSuspend **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__taskSuspend **)soap_malloc(soap, sizeof(_ns7__taskSuspend *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__taskSuspend *)soap_instantiate__ns7__taskSuspend(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__taskSuspend **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__taskSuspend, sizeof(_ns7__taskSuspend), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__taskSuspend(struct soap *soap, _ns7__taskSuspend *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__taskSuspend(soap, tag ? tag : "ns7:taskSuspend", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__taskSuspend ** SOAP_FMAC4 soap_get_PointerTo_ns7__taskSuspend(struct soap *soap, _ns7__taskSuspend **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__taskSuspend(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__getTasksResponse(struct soap *soap, _ns7__getTasksResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__getTasksResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__getTasksResponse(struct soap *soap, const char *tag, int id, _ns7__getTasksResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__getTasksResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__getTasksResponse ? type : NULL);
}

SOAP_FMAC3 _ns7__getTasksResponse ** SOAP_FMAC4 soap_in_PointerTo_ns7__getTasksResponse(struct soap *soap, const char *tag, _ns7__getTasksResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__getTasksResponse **)soap_malloc(soap, sizeof(_ns7__getTasksResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__getTasksResponse *)soap_instantiate__ns7__getTasksResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__getTasksResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__getTasksResponse, sizeof(_ns7__getTasksResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__getTasksResponse(struct soap *soap, _ns7__getTasksResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__getTasksResponse(soap, tag ? tag : "ns7:getTasksResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__getTasksResponse ** SOAP_FMAC4 soap_get_PointerTo_ns7__getTasksResponse(struct soap *soap, _ns7__getTasksResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__getTasksResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__getTasks(struct soap *soap, _ns7__getTasks *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__getTasks))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__getTasks(struct soap *soap, const char *tag, int id, _ns7__getTasks *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__getTasks, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__getTasks ? type : NULL);
}

SOAP_FMAC3 _ns7__getTasks ** SOAP_FMAC4 soap_in_PointerTo_ns7__getTasks(struct soap *soap, const char *tag, _ns7__getTasks **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__getTasks **)soap_malloc(soap, sizeof(_ns7__getTasks *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__getTasks *)soap_instantiate__ns7__getTasks(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__getTasks **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__getTasks, sizeof(_ns7__getTasks), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__getTasks(struct soap *soap, _ns7__getTasks *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__getTasks(soap, tag ? tag : "ns7:getTasks", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__getTasks ** SOAP_FMAC4 soap_get_PointerTo_ns7__getTasks(struct soap *soap, _ns7__getTasks **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__getTasks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__clearAllBreakpointsResponse(struct soap *soap, _ns7__clearAllBreakpointsResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__clearAllBreakpointsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__clearAllBreakpointsResponse(struct soap *soap, const char *tag, int id, _ns7__clearAllBreakpointsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__clearAllBreakpointsResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__clearAllBreakpointsResponse ? type : NULL);
}

SOAP_FMAC3 _ns7__clearAllBreakpointsResponse ** SOAP_FMAC4 soap_in_PointerTo_ns7__clearAllBreakpointsResponse(struct soap *soap, const char *tag, _ns7__clearAllBreakpointsResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__clearAllBreakpointsResponse **)soap_malloc(soap, sizeof(_ns7__clearAllBreakpointsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__clearAllBreakpointsResponse *)soap_instantiate__ns7__clearAllBreakpointsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__clearAllBreakpointsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__clearAllBreakpointsResponse, sizeof(_ns7__clearAllBreakpointsResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__clearAllBreakpointsResponse(struct soap *soap, _ns7__clearAllBreakpointsResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__clearAllBreakpointsResponse(soap, tag ? tag : "ns7:clearAllBreakpointsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__clearAllBreakpointsResponse ** SOAP_FMAC4 soap_get_PointerTo_ns7__clearAllBreakpointsResponse(struct soap *soap, _ns7__clearAllBreakpointsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__clearAllBreakpointsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__clearAllBreakpoints(struct soap *soap, _ns7__clearAllBreakpoints *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__clearAllBreakpoints))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__clearAllBreakpoints(struct soap *soap, const char *tag, int id, _ns7__clearAllBreakpoints *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__clearAllBreakpoints, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__clearAllBreakpoints ? type : NULL);
}

SOAP_FMAC3 _ns7__clearAllBreakpoints ** SOAP_FMAC4 soap_in_PointerTo_ns7__clearAllBreakpoints(struct soap *soap, const char *tag, _ns7__clearAllBreakpoints **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__clearAllBreakpoints **)soap_malloc(soap, sizeof(_ns7__clearAllBreakpoints *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__clearAllBreakpoints *)soap_instantiate__ns7__clearAllBreakpoints(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__clearAllBreakpoints **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__clearAllBreakpoints, sizeof(_ns7__clearAllBreakpoints), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__clearAllBreakpoints(struct soap *soap, _ns7__clearAllBreakpoints *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__clearAllBreakpoints(soap, tag ? tag : "ns7:clearAllBreakpoints", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__clearAllBreakpoints ** SOAP_FMAC4 soap_get_PointerTo_ns7__clearAllBreakpoints(struct soap *soap, _ns7__clearAllBreakpoints **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__clearAllBreakpoints(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__clearBreakpointsResponse(struct soap *soap, _ns7__clearBreakpointsResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__clearBreakpointsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__clearBreakpointsResponse(struct soap *soap, const char *tag, int id, _ns7__clearBreakpointsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__clearBreakpointsResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__clearBreakpointsResponse ? type : NULL);
}

SOAP_FMAC3 _ns7__clearBreakpointsResponse ** SOAP_FMAC4 soap_in_PointerTo_ns7__clearBreakpointsResponse(struct soap *soap, const char *tag, _ns7__clearBreakpointsResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__clearBreakpointsResponse **)soap_malloc(soap, sizeof(_ns7__clearBreakpointsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__clearBreakpointsResponse *)soap_instantiate__ns7__clearBreakpointsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__clearBreakpointsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__clearBreakpointsResponse, sizeof(_ns7__clearBreakpointsResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__clearBreakpointsResponse(struct soap *soap, _ns7__clearBreakpointsResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__clearBreakpointsResponse(soap, tag ? tag : "ns7:clearBreakpointsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__clearBreakpointsResponse ** SOAP_FMAC4 soap_get_PointerTo_ns7__clearBreakpointsResponse(struct soap *soap, _ns7__clearBreakpointsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__clearBreakpointsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__clearBreakpoints(struct soap *soap, _ns7__clearBreakpoints *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__clearBreakpoints))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__clearBreakpoints(struct soap *soap, const char *tag, int id, _ns7__clearBreakpoints *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__clearBreakpoints, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__clearBreakpoints ? type : NULL);
}

SOAP_FMAC3 _ns7__clearBreakpoints ** SOAP_FMAC4 soap_in_PointerTo_ns7__clearBreakpoints(struct soap *soap, const char *tag, _ns7__clearBreakpoints **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__clearBreakpoints **)soap_malloc(soap, sizeof(_ns7__clearBreakpoints *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__clearBreakpoints *)soap_instantiate__ns7__clearBreakpoints(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__clearBreakpoints **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__clearBreakpoints, sizeof(_ns7__clearBreakpoints), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__clearBreakpoints(struct soap *soap, _ns7__clearBreakpoints *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__clearBreakpoints(soap, tag ? tag : "ns7:clearBreakpoints", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__clearBreakpoints ** SOAP_FMAC4 soap_get_PointerTo_ns7__clearBreakpoints(struct soap *soap, _ns7__clearBreakpoints **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__clearBreakpoints(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__getBreakpointsResponse(struct soap *soap, _ns7__getBreakpointsResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__getBreakpointsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__getBreakpointsResponse(struct soap *soap, const char *tag, int id, _ns7__getBreakpointsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__getBreakpointsResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__getBreakpointsResponse ? type : NULL);
}

SOAP_FMAC3 _ns7__getBreakpointsResponse ** SOAP_FMAC4 soap_in_PointerTo_ns7__getBreakpointsResponse(struct soap *soap, const char *tag, _ns7__getBreakpointsResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__getBreakpointsResponse **)soap_malloc(soap, sizeof(_ns7__getBreakpointsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__getBreakpointsResponse *)soap_instantiate__ns7__getBreakpointsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__getBreakpointsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__getBreakpointsResponse, sizeof(_ns7__getBreakpointsResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__getBreakpointsResponse(struct soap *soap, _ns7__getBreakpointsResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__getBreakpointsResponse(soap, tag ? tag : "ns7:getBreakpointsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__getBreakpointsResponse ** SOAP_FMAC4 soap_get_PointerTo_ns7__getBreakpointsResponse(struct soap *soap, _ns7__getBreakpointsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__getBreakpointsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__getBreakpoints(struct soap *soap, _ns7__getBreakpoints *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__getBreakpoints))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__getBreakpoints(struct soap *soap, const char *tag, int id, _ns7__getBreakpoints *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__getBreakpoints, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__getBreakpoints ? type : NULL);
}

SOAP_FMAC3 _ns7__getBreakpoints ** SOAP_FMAC4 soap_in_PointerTo_ns7__getBreakpoints(struct soap *soap, const char *tag, _ns7__getBreakpoints **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__getBreakpoints **)soap_malloc(soap, sizeof(_ns7__getBreakpoints *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__getBreakpoints *)soap_instantiate__ns7__getBreakpoints(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__getBreakpoints **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__getBreakpoints, sizeof(_ns7__getBreakpoints), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__getBreakpoints(struct soap *soap, _ns7__getBreakpoints *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__getBreakpoints(soap, tag ? tag : "ns7:getBreakpoints", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__getBreakpoints ** SOAP_FMAC4 soap_get_PointerTo_ns7__getBreakpoints(struct soap *soap, _ns7__getBreakpoints **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__getBreakpoints(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__setBreakpointsResponse(struct soap *soap, _ns7__setBreakpointsResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__setBreakpointsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__setBreakpointsResponse(struct soap *soap, const char *tag, int id, _ns7__setBreakpointsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__setBreakpointsResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__setBreakpointsResponse ? type : NULL);
}

SOAP_FMAC3 _ns7__setBreakpointsResponse ** SOAP_FMAC4 soap_in_PointerTo_ns7__setBreakpointsResponse(struct soap *soap, const char *tag, _ns7__setBreakpointsResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__setBreakpointsResponse **)soap_malloc(soap, sizeof(_ns7__setBreakpointsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__setBreakpointsResponse *)soap_instantiate__ns7__setBreakpointsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__setBreakpointsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__setBreakpointsResponse, sizeof(_ns7__setBreakpointsResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__setBreakpointsResponse(struct soap *soap, _ns7__setBreakpointsResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__setBreakpointsResponse(soap, tag ? tag : "ns7:setBreakpointsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__setBreakpointsResponse ** SOAP_FMAC4 soap_get_PointerTo_ns7__setBreakpointsResponse(struct soap *soap, _ns7__setBreakpointsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__setBreakpointsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__setBreakpoints(struct soap *soap, _ns7__setBreakpoints *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__setBreakpoints))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__setBreakpoints(struct soap *soap, const char *tag, int id, _ns7__setBreakpoints *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__setBreakpoints, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns7__setBreakpoints ? type : NULL);
}

SOAP_FMAC3 _ns7__setBreakpoints ** SOAP_FMAC4 soap_in_PointerTo_ns7__setBreakpoints(struct soap *soap, const char *tag, _ns7__setBreakpoints **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__setBreakpoints **)soap_malloc(soap, sizeof(_ns7__setBreakpoints *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__setBreakpoints *)soap_instantiate__ns7__setBreakpoints(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns7__setBreakpoints **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__setBreakpoints, sizeof(_ns7__setBreakpoints), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__setBreakpoints(struct soap *soap, _ns7__setBreakpoints *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns7__setBreakpoints(soap, tag ? tag : "ns7:setBreakpoints", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__setBreakpoints ** SOAP_FMAC4 soap_get_PointerTo_ns7__setBreakpoints(struct soap *soap, _ns7__setBreakpoints **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__setBreakpoints(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setRobotPosResponse(struct soap *soap, _ns1__setRobotPosResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setRobotPosResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setRobotPosResponse(struct soap *soap, const char *tag, int id, _ns1__setRobotPosResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setRobotPosResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__setRobotPosResponse ? type : NULL);
}

SOAP_FMAC3 _ns1__setRobotPosResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__setRobotPosResponse(struct soap *soap, const char *tag, _ns1__setRobotPosResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__setRobotPosResponse **)soap_malloc(soap, sizeof(_ns1__setRobotPosResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__setRobotPosResponse *)soap_instantiate__ns1__setRobotPosResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__setRobotPosResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setRobotPosResponse, sizeof(_ns1__setRobotPosResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setRobotPosResponse(struct soap *soap, _ns1__setRobotPosResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__setRobotPosResponse(soap, tag ? tag : "ns1:setRobotPosResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__setRobotPosResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__setRobotPosResponse(struct soap *soap, _ns1__setRobotPosResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setRobotPosResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setRobotJointPos(struct soap *soap, _ns1__setRobotJointPos *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setRobotJointPos))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setRobotJointPos(struct soap *soap, const char *tag, int id, _ns1__setRobotJointPos *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setRobotJointPos, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__setRobotJointPos ? type : NULL);
}

SOAP_FMAC3 _ns1__setRobotJointPos ** SOAP_FMAC4 soap_in_PointerTo_ns1__setRobotJointPos(struct soap *soap, const char *tag, _ns1__setRobotJointPos **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__setRobotJointPos **)soap_malloc(soap, sizeof(_ns1__setRobotJointPos *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__setRobotJointPos *)soap_instantiate__ns1__setRobotJointPos(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__setRobotJointPos **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setRobotJointPos, sizeof(_ns1__setRobotJointPos), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setRobotJointPos(struct soap *soap, _ns1__setRobotJointPos *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__setRobotJointPos(soap, tag ? tag : "ns1:setRobotJointPos", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__setRobotJointPos ** SOAP_FMAC4 soap_get_PointerTo_ns1__setRobotJointPos(struct soap *soap, _ns1__setRobotJointPos **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setRobotJointPos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getRobotJntCartPosResponse(struct soap *soap, _ns1__getRobotJntCartPosResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getRobotJntCartPosResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getRobotJntCartPosResponse(struct soap *soap, const char *tag, int id, _ns1__getRobotJntCartPosResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getRobotJntCartPosResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__getRobotJntCartPosResponse ? type : NULL);
}

SOAP_FMAC3 _ns1__getRobotJntCartPosResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getRobotJntCartPosResponse(struct soap *soap, const char *tag, _ns1__getRobotJntCartPosResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getRobotJntCartPosResponse **)soap_malloc(soap, sizeof(_ns1__getRobotJntCartPosResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getRobotJntCartPosResponse *)soap_instantiate__ns1__getRobotJntCartPosResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__getRobotJntCartPosResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getRobotJntCartPosResponse, sizeof(_ns1__getRobotJntCartPosResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getRobotJntCartPosResponse(struct soap *soap, _ns1__getRobotJntCartPosResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__getRobotJntCartPosResponse(soap, tag ? tag : "ns1:getRobotJntCartPosResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getRobotJntCartPosResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getRobotJntCartPosResponse(struct soap *soap, _ns1__getRobotJntCartPosResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getRobotJntCartPosResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getRobotJntCartPos(struct soap *soap, _ns1__getRobotJntCartPos *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getRobotJntCartPos))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getRobotJntCartPos(struct soap *soap, const char *tag, int id, _ns1__getRobotJntCartPos *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getRobotJntCartPos, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__getRobotJntCartPos ? type : NULL);
}

SOAP_FMAC3 _ns1__getRobotJntCartPos ** SOAP_FMAC4 soap_in_PointerTo_ns1__getRobotJntCartPos(struct soap *soap, const char *tag, _ns1__getRobotJntCartPos **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getRobotJntCartPos **)soap_malloc(soap, sizeof(_ns1__getRobotJntCartPos *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getRobotJntCartPos *)soap_instantiate__ns1__getRobotJntCartPos(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__getRobotJntCartPos **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getRobotJntCartPos, sizeof(_ns1__getRobotJntCartPos), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getRobotJntCartPos(struct soap *soap, _ns1__getRobotJntCartPos *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__getRobotJntCartPos(soap, tag ? tag : "ns1:getRobotJntCartPos", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getRobotJntCartPos ** SOAP_FMAC4 soap_get_PointerTo_ns1__getRobotJntCartPos(struct soap *soap, _ns1__getRobotJntCartPos **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getRobotJntCartPos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getRobotJointPosResponse(struct soap *soap, _ns1__getRobotJointPosResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getRobotJointPosResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getRobotJointPosResponse(struct soap *soap, const char *tag, int id, _ns1__getRobotJointPosResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getRobotJointPosResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__getRobotJointPosResponse ? type : NULL);
}

SOAP_FMAC3 _ns1__getRobotJointPosResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getRobotJointPosResponse(struct soap *soap, const char *tag, _ns1__getRobotJointPosResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getRobotJointPosResponse **)soap_malloc(soap, sizeof(_ns1__getRobotJointPosResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getRobotJointPosResponse *)soap_instantiate__ns1__getRobotJointPosResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__getRobotJointPosResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getRobotJointPosResponse, sizeof(_ns1__getRobotJointPosResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getRobotJointPosResponse(struct soap *soap, _ns1__getRobotJointPosResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__getRobotJointPosResponse(soap, tag ? tag : "ns1:getRobotJointPosResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getRobotJointPosResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getRobotJointPosResponse(struct soap *soap, _ns1__getRobotJointPosResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getRobotJointPosResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getRobotJointPos(struct soap *soap, _ns1__getRobotJointPos *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getRobotJointPos))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getRobotJointPos(struct soap *soap, const char *tag, int id, _ns1__getRobotJointPos *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getRobotJointPos, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__getRobotJointPos ? type : NULL);
}

SOAP_FMAC3 _ns1__getRobotJointPos ** SOAP_FMAC4 soap_in_PointerTo_ns1__getRobotJointPos(struct soap *soap, const char *tag, _ns1__getRobotJointPos **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getRobotJointPos **)soap_malloc(soap, sizeof(_ns1__getRobotJointPos *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getRobotJointPos *)soap_instantiate__ns1__getRobotJointPos(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__getRobotJointPos **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getRobotJointPos, sizeof(_ns1__getRobotJointPos), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getRobotJointPos(struct soap *soap, _ns1__getRobotJointPos *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__getRobotJointPos(soap, tag ? tag : "ns1:getRobotJointPos", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getRobotJointPos ** SOAP_FMAC4 soap_get_PointerTo_ns1__getRobotJointPos(struct soap *soap, _ns1__getRobotJointPos **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getRobotJointPos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getRobotsResponse(struct soap *soap, _ns1__getRobotsResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getRobotsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getRobotsResponse(struct soap *soap, const char *tag, int id, _ns1__getRobotsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getRobotsResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__getRobotsResponse ? type : NULL);
}

SOAP_FMAC3 _ns1__getRobotsResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getRobotsResponse(struct soap *soap, const char *tag, _ns1__getRobotsResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getRobotsResponse **)soap_malloc(soap, sizeof(_ns1__getRobotsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getRobotsResponse *)soap_instantiate__ns1__getRobotsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__getRobotsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getRobotsResponse, sizeof(_ns1__getRobotsResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getRobotsResponse(struct soap *soap, _ns1__getRobotsResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__getRobotsResponse(soap, tag ? tag : "ns1:getRobotsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getRobotsResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getRobotsResponse(struct soap *soap, _ns1__getRobotsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getRobotsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getRobots(struct soap *soap, _ns1__getRobots *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getRobots))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getRobots(struct soap *soap, const char *tag, int id, _ns1__getRobots *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getRobots, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__getRobots ? type : NULL);
}

SOAP_FMAC3 _ns1__getRobots ** SOAP_FMAC4 soap_in_PointerTo_ns1__getRobots(struct soap *soap, const char *tag, _ns1__getRobots **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getRobots **)soap_malloc(soap, sizeof(_ns1__getRobots *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getRobots *)soap_instantiate__ns1__getRobots(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__getRobots **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getRobots, sizeof(_ns1__getRobots), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getRobots(struct soap *soap, _ns1__getRobots *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__getRobots(soap, tag ? tag : "ns1:getRobots", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getRobots ** SOAP_FMAC4 soap_get_PointerTo_ns1__getRobots(struct soap *soap, _ns1__getRobots **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getRobots(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__logoutResponse(struct soap *soap, _ns1__logoutResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__logoutResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__logoutResponse(struct soap *soap, const char *tag, int id, _ns1__logoutResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__logoutResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__logoutResponse ? type : NULL);
}

SOAP_FMAC3 _ns1__logoutResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__logoutResponse(struct soap *soap, const char *tag, _ns1__logoutResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__logoutResponse **)soap_malloc(soap, sizeof(_ns1__logoutResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__logoutResponse *)soap_instantiate__ns1__logoutResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__logoutResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__logoutResponse, sizeof(_ns1__logoutResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__logoutResponse(struct soap *soap, _ns1__logoutResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__logoutResponse(soap, tag ? tag : "ns1:logoutResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__logoutResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__logoutResponse(struct soap *soap, _ns1__logoutResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__logoutResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__logout(struct soap *soap, _ns1__logout *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__logout))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__logout(struct soap *soap, const char *tag, int id, _ns1__logout *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__logout, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__logout ? type : NULL);
}

SOAP_FMAC3 _ns1__logout ** SOAP_FMAC4 soap_in_PointerTo_ns1__logout(struct soap *soap, const char *tag, _ns1__logout **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__logout **)soap_malloc(soap, sizeof(_ns1__logout *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__logout *)soap_instantiate__ns1__logout(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__logout **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__logout, sizeof(_ns1__logout), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__logout(struct soap *soap, _ns1__logout *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__logout(soap, tag ? tag : "ns1:logout", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__logout ** SOAP_FMAC4 soap_get_PointerTo_ns1__logout(struct soap *soap, _ns1__logout **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__logout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__loginResponse(struct soap *soap, _ns1__loginResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__loginResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__loginResponse(struct soap *soap, const char *tag, int id, _ns1__loginResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__loginResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__loginResponse ? type : NULL);
}

SOAP_FMAC3 _ns1__loginResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__loginResponse(struct soap *soap, const char *tag, _ns1__loginResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__loginResponse **)soap_malloc(soap, sizeof(_ns1__loginResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__loginResponse *)soap_instantiate__ns1__loginResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__loginResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__loginResponse, sizeof(_ns1__loginResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__loginResponse(struct soap *soap, _ns1__loginResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__loginResponse(soap, tag ? tag : "ns1:loginResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__loginResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__loginResponse(struct soap *soap, _ns1__loginResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__loginResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__login(struct soap *soap, _ns1__login *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__login))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__login(struct soap *soap, const char *tag, int id, _ns1__login *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__login, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__login ? type : NULL);
}

SOAP_FMAC3 _ns1__login ** SOAP_FMAC4 soap_in_PointerTo_ns1__login(struct soap *soap, const char *tag, _ns1__login **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__login **)soap_malloc(soap, sizeof(_ns1__login *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__login *)soap_instantiate__ns1__login(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__login **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__login, sizeof(_ns1__login), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__login(struct soap *soap, _ns1__login *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__login(soap, tag ? tag : "ns1:login", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__login ** SOAP_FMAC4 soap_get_PointerTo_ns1__login(struct soap *soap, _ns1__login **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getCS8CompatibilityResponse(struct soap *soap, _ns1__getCS8CompatibilityResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getCS8CompatibilityResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getCS8CompatibilityResponse(struct soap *soap, const char *tag, int id, _ns1__getCS8CompatibilityResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getCS8CompatibilityResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__getCS8CompatibilityResponse ? type : NULL);
}

SOAP_FMAC3 _ns1__getCS8CompatibilityResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getCS8CompatibilityResponse(struct soap *soap, const char *tag, _ns1__getCS8CompatibilityResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getCS8CompatibilityResponse **)soap_malloc(soap, sizeof(_ns1__getCS8CompatibilityResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getCS8CompatibilityResponse *)soap_instantiate__ns1__getCS8CompatibilityResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__getCS8CompatibilityResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getCS8CompatibilityResponse, sizeof(_ns1__getCS8CompatibilityResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getCS8CompatibilityResponse(struct soap *soap, _ns1__getCS8CompatibilityResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__getCS8CompatibilityResponse(soap, tag ? tag : "ns1:getCS8CompatibilityResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getCS8CompatibilityResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getCS8CompatibilityResponse(struct soap *soap, _ns1__getCS8CompatibilityResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getCS8CompatibilityResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getCS8Compatibility(struct soap *soap, _ns1__getCS8Compatibility *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getCS8Compatibility))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getCS8Compatibility(struct soap *soap, const char *tag, int id, _ns1__getCS8Compatibility *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getCS8Compatibility, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__getCS8Compatibility ? type : NULL);
}

SOAP_FMAC3 _ns1__getCS8Compatibility ** SOAP_FMAC4 soap_in_PointerTo_ns1__getCS8Compatibility(struct soap *soap, const char *tag, _ns1__getCS8Compatibility **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getCS8Compatibility **)soap_malloc(soap, sizeof(_ns1__getCS8Compatibility *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getCS8Compatibility *)soap_instantiate__ns1__getCS8Compatibility(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__getCS8Compatibility **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getCS8Compatibility, sizeof(_ns1__getCS8Compatibility), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getCS8Compatibility(struct soap *soap, _ns1__getCS8Compatibility *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__getCS8Compatibility(soap, tag ? tag : "ns1:getCS8Compatibility", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getCS8Compatibility ** SOAP_FMAC4 soap_get_PointerTo_ns1__getCS8Compatibility(struct soap *soap, _ns1__getCS8Compatibility **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getCS8Compatibility(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getControllerParametersResponse(struct soap *soap, _ns1__getControllerParametersResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getControllerParametersResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getControllerParametersResponse(struct soap *soap, const char *tag, int id, _ns1__getControllerParametersResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getControllerParametersResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__getControllerParametersResponse ? type : NULL);
}

SOAP_FMAC3 _ns1__getControllerParametersResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getControllerParametersResponse(struct soap *soap, const char *tag, _ns1__getControllerParametersResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getControllerParametersResponse **)soap_malloc(soap, sizeof(_ns1__getControllerParametersResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getControllerParametersResponse *)soap_instantiate__ns1__getControllerParametersResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__getControllerParametersResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getControllerParametersResponse, sizeof(_ns1__getControllerParametersResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getControllerParametersResponse(struct soap *soap, _ns1__getControllerParametersResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__getControllerParametersResponse(soap, tag ? tag : "ns1:getControllerParametersResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getControllerParametersResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getControllerParametersResponse(struct soap *soap, _ns1__getControllerParametersResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getControllerParametersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getControllerParameters(struct soap *soap, _ns1__getControllerParameters *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getControllerParameters))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getControllerParameters(struct soap *soap, const char *tag, int id, _ns1__getControllerParameters *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getControllerParameters, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__getControllerParameters ? type : NULL);
}

SOAP_FMAC3 _ns1__getControllerParameters ** SOAP_FMAC4 soap_in_PointerTo_ns1__getControllerParameters(struct soap *soap, const char *tag, _ns1__getControllerParameters **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getControllerParameters **)soap_malloc(soap, sizeof(_ns1__getControllerParameters *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getControllerParameters *)soap_instantiate__ns1__getControllerParameters(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__getControllerParameters **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getControllerParameters, sizeof(_ns1__getControllerParameters), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getControllerParameters(struct soap *soap, _ns1__getControllerParameters *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__getControllerParameters(soap, tag ? tag : "ns1:getControllerParameters", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getControllerParameters ** SOAP_FMAC4 soap_get_PointerTo_ns1__getControllerParameters(struct soap *soap, _ns1__getControllerParameters **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getControllerParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getCS8VersionsResponse(struct soap *soap, _ns1__getCS8VersionsResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getCS8VersionsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getCS8VersionsResponse(struct soap *soap, const char *tag, int id, _ns1__getCS8VersionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getCS8VersionsResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__getCS8VersionsResponse ? type : NULL);
}

SOAP_FMAC3 _ns1__getCS8VersionsResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getCS8VersionsResponse(struct soap *soap, const char *tag, _ns1__getCS8VersionsResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getCS8VersionsResponse **)soap_malloc(soap, sizeof(_ns1__getCS8VersionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getCS8VersionsResponse *)soap_instantiate__ns1__getCS8VersionsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__getCS8VersionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getCS8VersionsResponse, sizeof(_ns1__getCS8VersionsResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getCS8VersionsResponse(struct soap *soap, _ns1__getCS8VersionsResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__getCS8VersionsResponse(soap, tag ? tag : "ns1:getCS8VersionsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getCS8VersionsResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getCS8VersionsResponse(struct soap *soap, _ns1__getCS8VersionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getCS8VersionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getCS8Versions(struct soap *soap, _ns1__getCS8Versions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getCS8Versions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getCS8Versions(struct soap *soap, const char *tag, int id, _ns1__getCS8Versions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getCS8Versions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__getCS8Versions ? type : NULL);
}

SOAP_FMAC3 _ns1__getCS8Versions ** SOAP_FMAC4 soap_in_PointerTo_ns1__getCS8Versions(struct soap *soap, const char *tag, _ns1__getCS8Versions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getCS8Versions **)soap_malloc(soap, sizeof(_ns1__getCS8Versions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getCS8Versions *)soap_instantiate__ns1__getCS8Versions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__getCS8Versions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getCS8Versions, sizeof(_ns1__getCS8Versions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getCS8Versions(struct soap *soap, _ns1__getCS8Versions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__getCS8Versions(soap, tag ? tag : "ns1:getCS8Versions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getCS8Versions ** SOAP_FMAC4 soap_get_PointerTo_ns1__getCS8Versions(struct soap *soap, _ns1__getCS8Versions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getCS8Versions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__pingResponse(struct soap *soap, _ns1__pingResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__pingResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__pingResponse(struct soap *soap, const char *tag, int id, _ns1__pingResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__pingResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__pingResponse ? type : NULL);
}

SOAP_FMAC3 _ns1__pingResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__pingResponse(struct soap *soap, const char *tag, _ns1__pingResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__pingResponse **)soap_malloc(soap, sizeof(_ns1__pingResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__pingResponse *)soap_instantiate__ns1__pingResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__pingResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__pingResponse, sizeof(_ns1__pingResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__pingResponse(struct soap *soap, _ns1__pingResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__pingResponse(soap, tag ? tag : "ns1:pingResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__pingResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__pingResponse(struct soap *soap, _ns1__pingResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__pingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ping(struct soap *soap, _ns1__ping *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ping))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ping(struct soap *soap, const char *tag, int id, _ns1__ping *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ping, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__ping ? type : NULL);
}

SOAP_FMAC3 _ns1__ping ** SOAP_FMAC4 soap_in_PointerTo_ns1__ping(struct soap *soap, const char *tag, _ns1__ping **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__ping **)soap_malloc(soap, sizeof(_ns1__ping *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__ping *)soap_instantiate__ns1__ping(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__ping **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ping, sizeof(_ns1__ping), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ping(struct soap *soap, _ns1__ping *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__ping(soap, tag ? tag : "ns1:ping", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__ping ** SOAP_FMAC4 soap_get_PointerTo_ns1__ping(struct soap *soap, _ns1__ping **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ping(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__findServerResponse(struct soap *soap, _ns1__findServerResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__findServerResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__findServerResponse(struct soap *soap, const char *tag, int id, _ns1__findServerResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__findServerResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__findServerResponse ? type : NULL);
}

SOAP_FMAC3 _ns1__findServerResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__findServerResponse(struct soap *soap, const char *tag, _ns1__findServerResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__findServerResponse **)soap_malloc(soap, sizeof(_ns1__findServerResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__findServerResponse *)soap_instantiate__ns1__findServerResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__findServerResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__findServerResponse, sizeof(_ns1__findServerResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__findServerResponse(struct soap *soap, _ns1__findServerResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__findServerResponse(soap, tag ? tag : "ns1:findServerResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__findServerResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__findServerResponse(struct soap *soap, _ns1__findServerResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__findServerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__findServer(struct soap *soap, _ns1__findServer *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__findServer))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__findServer(struct soap *soap, const char *tag, int id, _ns1__findServer *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__findServer, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__findServer ? type : NULL);
}

SOAP_FMAC3 _ns1__findServer ** SOAP_FMAC4 soap_in_PointerTo_ns1__findServer(struct soap *soap, const char *tag, _ns1__findServer **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__findServer **)soap_malloc(soap, sizeof(_ns1__findServer *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__findServer *)soap_instantiate__ns1__findServer(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__findServer **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__findServer, sizeof(_ns1__findServer), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__findServer(struct soap *soap, _ns1__findServer *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__findServer(soap, tag ? tag : "ns1:findServer", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__findServer ** SOAP_FMAC4 soap_get_PointerTo_ns1__findServer(struct soap *soap, _ns1__findServer **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__findServer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getSoapServerVersionResponse(struct soap *soap, _ns1__getSoapServerVersionResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getSoapServerVersionResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getSoapServerVersionResponse(struct soap *soap, const char *tag, int id, _ns1__getSoapServerVersionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getSoapServerVersionResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__getSoapServerVersionResponse ? type : NULL);
}

SOAP_FMAC3 _ns1__getSoapServerVersionResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getSoapServerVersionResponse(struct soap *soap, const char *tag, _ns1__getSoapServerVersionResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getSoapServerVersionResponse **)soap_malloc(soap, sizeof(_ns1__getSoapServerVersionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getSoapServerVersionResponse *)soap_instantiate__ns1__getSoapServerVersionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__getSoapServerVersionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getSoapServerVersionResponse, sizeof(_ns1__getSoapServerVersionResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getSoapServerVersionResponse(struct soap *soap, _ns1__getSoapServerVersionResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__getSoapServerVersionResponse(soap, tag ? tag : "ns1:getSoapServerVersionResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getSoapServerVersionResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getSoapServerVersionResponse(struct soap *soap, _ns1__getSoapServerVersionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getSoapServerVersionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getSoapServerVersion(struct soap *soap, _ns1__getSoapServerVersion *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getSoapServerVersion))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getSoapServerVersion(struct soap *soap, const char *tag, int id, _ns1__getSoapServerVersion *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getSoapServerVersion, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__getSoapServerVersion ? type : NULL);
}

SOAP_FMAC3 _ns1__getSoapServerVersion ** SOAP_FMAC4 soap_in_PointerTo_ns1__getSoapServerVersion(struct soap *soap, const char *tag, _ns1__getSoapServerVersion **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getSoapServerVersion **)soap_malloc(soap, sizeof(_ns1__getSoapServerVersion *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getSoapServerVersion *)soap_instantiate__ns1__getSoapServerVersion(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__getSoapServerVersion **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getSoapServerVersion, sizeof(_ns1__getSoapServerVersion), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getSoapServerVersion(struct soap *soap, _ns1__getSoapServerVersion *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__getSoapServerVersion(soap, tag ? tag : "ns1:getSoapServerVersion", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getSoapServerVersion ** SOAP_FMAC4 soap_get_PointerTo_ns1__getSoapServerVersion(struct soap *soap, _ns1__getSoapServerVersion **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getSoapServerVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ServerException(struct soap *soap, ns1__ServerException *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ServerException))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ServerException(struct soap *soap, const char *tag, int id, ns1__ServerException *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ServerException, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ServerException ? type : NULL);
}

SOAP_FMAC3 ns1__ServerException ** SOAP_FMAC4 soap_in_PointerTons1__ServerException(struct soap *soap, const char *tag, ns1__ServerException **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ServerException **)soap_malloc(soap, sizeof(ns1__ServerException *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ServerException *)soap_instantiate_ns1__ServerException(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ServerException **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ServerException, sizeof(ns1__ServerException), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ServerException(struct soap *soap, ns1__ServerException *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ServerException(soap, tag ? tag : "ns1:ServerException", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ServerException ** SOAP_FMAC4 soap_get_PointerTons1__ServerException(struct soap *soap, ns1__ServerException **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ServerException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SessionId(struct soap *soap, int *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns1__SessionId);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SessionId(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SessionId, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SessionId(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerTons1__SessionId(struct soap *soap, const char *tag, int **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SessionId(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SessionId, sizeof(int), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SessionId(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SessionId(soap, tag ? tag : "ns1:SessionId", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerTons1__SessionId(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SessionId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__JointRange(struct soap *soap, ns2__JointRange *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__JointRange))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__JointRange(struct soap *soap, const char *tag, int id, ns2__JointRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__JointRange, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__JointRange ? type : NULL);
}

SOAP_FMAC3 ns2__JointRange ** SOAP_FMAC4 soap_in_PointerTons2__JointRange(struct soap *soap, const char *tag, ns2__JointRange **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__JointRange **)soap_malloc(soap, sizeof(ns2__JointRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__JointRange *)soap_instantiate_ns2__JointRange(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__JointRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__JointRange, sizeof(ns2__JointRange), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__JointRange(struct soap *soap, ns2__JointRange *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__JointRange(soap, tag ? tag : "ns2:JointRange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__JointRange ** SOAP_FMAC4 soap_get_PointerTons2__JointRange(struct soap *soap, ns2__JointRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__JointRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Records(struct soap *soap, ns2__Records *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Records))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Records(struct soap *soap, const char *tag, int id, ns2__Records *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Records, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__Records ? type : NULL);
}

SOAP_FMAC3 ns2__Records ** SOAP_FMAC4 soap_in_PointerTons2__Records(struct soap *soap, const char *tag, ns2__Records **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__Records **)soap_malloc(soap, sizeof(ns2__Records *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__Records *)soap_instantiate_ns2__Records(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__Records **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Records, sizeof(ns2__Records), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Records(struct soap *soap, ns2__Records *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__Records(soap, tag ? tag : "ns2:Records", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__Records ** SOAP_FMAC4 soap_get_PointerTons2__Records(struct soap *soap, ns2__Records **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Records(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Data(struct soap *soap, ns2__Data *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Data))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Data(struct soap *soap, const char *tag, int id, ns2__Data *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Data, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__Data ? type : NULL);
}

SOAP_FMAC3 ns2__Data ** SOAP_FMAC4 soap_in_PointerTons2__Data(struct soap *soap, const char *tag, ns2__Data **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__Data **)soap_malloc(soap, sizeof(ns2__Data *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__Data *)soap_instantiate_ns2__Data(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__Data **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Data, sizeof(ns2__Data), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Data(struct soap *soap, ns2__Data *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__Data(soap, tag ? tag : "ns2:Data", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__Data ** SOAP_FMAC4 soap_get_PointerTons2__Data(struct soap *soap, ns2__Data **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Data(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__VALApplications(struct soap *soap, ns2__VALApplications *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__VALApplications))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__VALApplications(struct soap *soap, const char *tag, int id, ns2__VALApplications *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__VALApplications, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__VALApplications ? type : NULL);
}

SOAP_FMAC3 ns2__VALApplications ** SOAP_FMAC4 soap_in_PointerTons2__VALApplications(struct soap *soap, const char *tag, ns2__VALApplications **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__VALApplications **)soap_malloc(soap, sizeof(ns2__VALApplications *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__VALApplications *)soap_instantiate_ns2__VALApplications(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__VALApplications **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__VALApplications, sizeof(ns2__VALApplications), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__VALApplications(struct soap *soap, ns2__VALApplications *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__VALApplications(soap, tag ? tag : "ns2:VALApplications", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__VALApplications ** SOAP_FMAC4 soap_get_PointerTons2__VALApplications(struct soap *soap, ns2__VALApplications **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__VALApplications(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__Include(struct soap *soap, ns3__Include *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__Include))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__Include(struct soap *soap, const char *tag, int id, ns3__Include *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__Include, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns3__Include ? type : NULL);
}

SOAP_FMAC3 ns3__Include ** SOAP_FMAC4 soap_in_PointerTons3__Include(struct soap *soap, const char *tag, ns3__Include **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__Include **)soap_malloc(soap, sizeof(ns3__Include *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__Include *)soap_instantiate_ns3__Include(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns3__Include **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__Include, sizeof(ns3__Include), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__Include(struct soap *soap, ns3__Include *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons3__Include(soap, tag ? tag : "ns3:Include", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__Include ** SOAP_FMAC4 soap_get_PointerTons3__Include(struct soap *soap, ns3__Include **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__Include(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__SoapDhParametersArray(struct soap *soap, ns7__SoapDhParametersArray *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__SoapDhParametersArray))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__SoapDhParametersArray(struct soap *soap, const char *tag, int id, ns7__SoapDhParametersArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__SoapDhParametersArray, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns7__SoapDhParametersArray ? type : NULL);
}

SOAP_FMAC3 ns7__SoapDhParametersArray ** SOAP_FMAC4 soap_in_PointerTons7__SoapDhParametersArray(struct soap *soap, const char *tag, ns7__SoapDhParametersArray **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns7__SoapDhParametersArray **)soap_malloc(soap, sizeof(ns7__SoapDhParametersArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns7__SoapDhParametersArray *)soap_instantiate_ns7__SoapDhParametersArray(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns7__SoapDhParametersArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__SoapDhParametersArray, sizeof(ns7__SoapDhParametersArray), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__SoapDhParametersArray(struct soap *soap, ns7__SoapDhParametersArray *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons7__SoapDhParametersArray(soap, tag ? tag : "ns7:SoapDhParametersArray", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns7__SoapDhParametersArray ** SOAP_FMAC4 soap_get_PointerTons7__SoapDhParametersArray(struct soap *soap, ns7__SoapDhParametersArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__SoapDhParametersArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__SoapPhysicalIoUnlockResponses(struct soap *soap, ns7__SoapPhysicalIoUnlockResponses *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__SoapPhysicalIoUnlockResponses))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__SoapPhysicalIoUnlockResponses(struct soap *soap, const char *tag, int id, ns7__SoapPhysicalIoUnlockResponses *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__SoapPhysicalIoUnlockResponses, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns7__SoapPhysicalIoUnlockResponses ? type : NULL);
}

SOAP_FMAC3 ns7__SoapPhysicalIoUnlockResponses ** SOAP_FMAC4 soap_in_PointerTons7__SoapPhysicalIoUnlockResponses(struct soap *soap, const char *tag, ns7__SoapPhysicalIoUnlockResponses **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns7__SoapPhysicalIoUnlockResponses **)soap_malloc(soap, sizeof(ns7__SoapPhysicalIoUnlockResponses *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns7__SoapPhysicalIoUnlockResponses *)soap_instantiate_ns7__SoapPhysicalIoUnlockResponses(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns7__SoapPhysicalIoUnlockResponses **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__SoapPhysicalIoUnlockResponses, sizeof(ns7__SoapPhysicalIoUnlockResponses), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__SoapPhysicalIoUnlockResponses(struct soap *soap, ns7__SoapPhysicalIoUnlockResponses *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons7__SoapPhysicalIoUnlockResponses(soap, tag ? tag : "ns7:SoapPhysicalIoUnlockResponses", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns7__SoapPhysicalIoUnlockResponses ** SOAP_FMAC4 soap_get_PointerTons7__SoapPhysicalIoUnlockResponses(struct soap *soap, ns7__SoapPhysicalIoUnlockResponses **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__SoapPhysicalIoUnlockResponses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__SoapPhysicalIoResponses(struct soap *soap, ns7__SoapPhysicalIoResponses *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__SoapPhysicalIoResponses))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__SoapPhysicalIoResponses(struct soap *soap, const char *tag, int id, ns7__SoapPhysicalIoResponses *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__SoapPhysicalIoResponses, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns7__SoapPhysicalIoResponses ? type : NULL);
}

SOAP_FMAC3 ns7__SoapPhysicalIoResponses ** SOAP_FMAC4 soap_in_PointerTons7__SoapPhysicalIoResponses(struct soap *soap, const char *tag, ns7__SoapPhysicalIoResponses **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns7__SoapPhysicalIoResponses **)soap_malloc(soap, sizeof(ns7__SoapPhysicalIoResponses *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns7__SoapPhysicalIoResponses *)soap_instantiate_ns7__SoapPhysicalIoResponses(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns7__SoapPhysicalIoResponses **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__SoapPhysicalIoResponses, sizeof(ns7__SoapPhysicalIoResponses), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__SoapPhysicalIoResponses(struct soap *soap, ns7__SoapPhysicalIoResponses *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons7__SoapPhysicalIoResponses(soap, tag ? tag : "ns7:SoapPhysicalIoResponses", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns7__SoapPhysicalIoResponses ** SOAP_FMAC4 soap_get_PointerTons7__SoapPhysicalIoResponses(struct soap *soap, ns7__SoapPhysicalIoResponses **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__SoapPhysicalIoResponses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__SoapPhysicalIoValues(struct soap *soap, ns7__SoapPhysicalIoValues *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__SoapPhysicalIoValues))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__SoapPhysicalIoValues(struct soap *soap, const char *tag, int id, ns7__SoapPhysicalIoValues *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__SoapPhysicalIoValues, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns7__SoapPhysicalIoValues ? type : NULL);
}

SOAP_FMAC3 ns7__SoapPhysicalIoValues ** SOAP_FMAC4 soap_in_PointerTons7__SoapPhysicalIoValues(struct soap *soap, const char *tag, ns7__SoapPhysicalIoValues **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns7__SoapPhysicalIoValues **)soap_malloc(soap, sizeof(ns7__SoapPhysicalIoValues *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns7__SoapPhysicalIoValues *)soap_instantiate_ns7__SoapPhysicalIoValues(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns7__SoapPhysicalIoValues **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__SoapPhysicalIoValues, sizeof(ns7__SoapPhysicalIoValues), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__SoapPhysicalIoValues(struct soap *soap, ns7__SoapPhysicalIoValues *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons7__SoapPhysicalIoValues(soap, tag ? tag : "ns7:SoapPhysicalIoValues", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns7__SoapPhysicalIoValues ** SOAP_FMAC4 soap_get_PointerTons7__SoapPhysicalIoValues(struct soap *soap, ns7__SoapPhysicalIoValues **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__SoapPhysicalIoValues(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__SoapPhysicalIosStates(struct soap *soap, ns7__SoapPhysicalIosStates *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__SoapPhysicalIosStates))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__SoapPhysicalIosStates(struct soap *soap, const char *tag, int id, ns7__SoapPhysicalIosStates *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__SoapPhysicalIosStates, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns7__SoapPhysicalIosStates ? type : NULL);
}

SOAP_FMAC3 ns7__SoapPhysicalIosStates ** SOAP_FMAC4 soap_in_PointerTons7__SoapPhysicalIosStates(struct soap *soap, const char *tag, ns7__SoapPhysicalIosStates **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns7__SoapPhysicalIosStates **)soap_malloc(soap, sizeof(ns7__SoapPhysicalIosStates *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns7__SoapPhysicalIosStates *)soap_instantiate_ns7__SoapPhysicalIosStates(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns7__SoapPhysicalIosStates **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__SoapPhysicalIosStates, sizeof(ns7__SoapPhysicalIosStates), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__SoapPhysicalIosStates(struct soap *soap, ns7__SoapPhysicalIosStates *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons7__SoapPhysicalIosStates(soap, tag ? tag : "ns7:SoapPhysicalIosStates", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns7__SoapPhysicalIosStates ** SOAP_FMAC4 soap_get_PointerTons7__SoapPhysicalIosStates(struct soap *soap, ns7__SoapPhysicalIosStates **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__SoapPhysicalIosStates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__SoapPhysicalIoLinks(struct soap *soap, ns7__SoapPhysicalIoLinks *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__SoapPhysicalIoLinks))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__SoapPhysicalIoLinks(struct soap *soap, const char *tag, int id, ns7__SoapPhysicalIoLinks *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__SoapPhysicalIoLinks, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns7__SoapPhysicalIoLinks ? type : NULL);
}

SOAP_FMAC3 ns7__SoapPhysicalIoLinks ** SOAP_FMAC4 soap_in_PointerTons7__SoapPhysicalIoLinks(struct soap *soap, const char *tag, ns7__SoapPhysicalIoLinks **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns7__SoapPhysicalIoLinks **)soap_malloc(soap, sizeof(ns7__SoapPhysicalIoLinks *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns7__SoapPhysicalIoLinks *)soap_instantiate_ns7__SoapPhysicalIoLinks(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns7__SoapPhysicalIoLinks **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__SoapPhysicalIoLinks, sizeof(ns7__SoapPhysicalIoLinks), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__SoapPhysicalIoLinks(struct soap *soap, ns7__SoapPhysicalIoLinks *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons7__SoapPhysicalIoLinks(soap, tag ? tag : "ns7:SoapPhysicalIoLinks", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns7__SoapPhysicalIoLinks ** SOAP_FMAC4 soap_get_PointerTons7__SoapPhysicalIoLinks(struct soap *soap, ns7__SoapPhysicalIoLinks **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__SoapPhysicalIoLinks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__SoapWatches(struct soap *soap, ns7__SoapWatches *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__SoapWatches))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__SoapWatches(struct soap *soap, const char *tag, int id, ns7__SoapWatches *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__SoapWatches, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns7__SoapWatches ? type : NULL);
}

SOAP_FMAC3 ns7__SoapWatches ** SOAP_FMAC4 soap_in_PointerTons7__SoapWatches(struct soap *soap, const char *tag, ns7__SoapWatches **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns7__SoapWatches **)soap_malloc(soap, sizeof(ns7__SoapWatches *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns7__SoapWatches *)soap_instantiate_ns7__SoapWatches(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns7__SoapWatches **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__SoapWatches, sizeof(ns7__SoapWatches), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__SoapWatches(struct soap *soap, ns7__SoapWatches *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons7__SoapWatches(soap, tag ? tag : "ns7:SoapWatches", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns7__SoapWatches ** SOAP_FMAC4 soap_get_PointerTons7__SoapWatches(struct soap *soap, ns7__SoapWatches **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__SoapWatches(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__MimeData(struct soap *soap, ns7__MimeData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__MimeData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__MimeData(struct soap *soap, const char *tag, int id, ns7__MimeData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__MimeData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns7__MimeData ? type : NULL);
}

SOAP_FMAC3 ns7__MimeData ** SOAP_FMAC4 soap_in_PointerTons7__MimeData(struct soap *soap, const char *tag, ns7__MimeData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns7__MimeData **)soap_malloc(soap, sizeof(ns7__MimeData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns7__MimeData *)soap_instantiate_ns7__MimeData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns7__MimeData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__MimeData, sizeof(ns7__MimeData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__MimeData(struct soap *soap, ns7__MimeData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons7__MimeData(soap, tag ? tag : "ns7:MimeData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns7__MimeData ** SOAP_FMAC4 soap_get_PointerTons7__MimeData(struct soap *soap, ns7__MimeData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__MimeData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__SoapCallStack(struct soap *soap, ns7__SoapCallStack *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__SoapCallStack))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__SoapCallStack(struct soap *soap, const char *tag, int id, ns7__SoapCallStack *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__SoapCallStack, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns7__SoapCallStack ? type : NULL);
}

SOAP_FMAC3 ns7__SoapCallStack ** SOAP_FMAC4 soap_in_PointerTons7__SoapCallStack(struct soap *soap, const char *tag, ns7__SoapCallStack **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns7__SoapCallStack **)soap_malloc(soap, sizeof(ns7__SoapCallStack *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns7__SoapCallStack *)soap_instantiate_ns7__SoapCallStack(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns7__SoapCallStack **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__SoapCallStack, sizeof(ns7__SoapCallStack), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__SoapCallStack(struct soap *soap, ns7__SoapCallStack *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons7__SoapCallStack(soap, tag ? tag : "ns7:SoapCallStack", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns7__SoapCallStack ** SOAP_FMAC4 soap_get_PointerTons7__SoapCallStack(struct soap *soap, ns7__SoapCallStack **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__SoapCallStack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__SoapTasks(struct soap *soap, ns7__SoapTasks *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__SoapTasks))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__SoapTasks(struct soap *soap, const char *tag, int id, ns7__SoapTasks *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__SoapTasks, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns7__SoapTasks ? type : NULL);
}

SOAP_FMAC3 ns7__SoapTasks ** SOAP_FMAC4 soap_in_PointerTons7__SoapTasks(struct soap *soap, const char *tag, ns7__SoapTasks **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns7__SoapTasks **)soap_malloc(soap, sizeof(ns7__SoapTasks *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns7__SoapTasks *)soap_instantiate_ns7__SoapTasks(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns7__SoapTasks **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__SoapTasks, sizeof(ns7__SoapTasks), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__SoapTasks(struct soap *soap, ns7__SoapTasks *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons7__SoapTasks(soap, tag ? tag : "ns7:SoapTasks", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns7__SoapTasks ** SOAP_FMAC4 soap_get_PointerTons7__SoapTasks(struct soap *soap, ns7__SoapTasks **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__SoapTasks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__BreakpointsResponses(struct soap *soap, ns7__BreakpointsResponses *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__BreakpointsResponses))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__BreakpointsResponses(struct soap *soap, const char *tag, int id, ns7__BreakpointsResponses *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__BreakpointsResponses, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns7__BreakpointsResponses ? type : NULL);
}

SOAP_FMAC3 ns7__BreakpointsResponses ** SOAP_FMAC4 soap_in_PointerTons7__BreakpointsResponses(struct soap *soap, const char *tag, ns7__BreakpointsResponses **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns7__BreakpointsResponses **)soap_malloc(soap, sizeof(ns7__BreakpointsResponses *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns7__BreakpointsResponses *)soap_instantiate_ns7__BreakpointsResponses(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns7__BreakpointsResponses **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__BreakpointsResponses, sizeof(ns7__BreakpointsResponses), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__BreakpointsResponses(struct soap *soap, ns7__BreakpointsResponses *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons7__BreakpointsResponses(soap, tag ? tag : "ns7:BreakpointsResponses", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns7__BreakpointsResponses ** SOAP_FMAC4 soap_get_PointerTons7__BreakpointsResponses(struct soap *soap, ns7__BreakpointsResponses **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__BreakpointsResponses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__SoapBreakpoints(struct soap *soap, ns7__SoapBreakpoints *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__SoapBreakpoints))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__SoapBreakpoints(struct soap *soap, const char *tag, int id, ns7__SoapBreakpoints *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__SoapBreakpoints, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns7__SoapBreakpoints ? type : NULL);
}

SOAP_FMAC3 ns7__SoapBreakpoints ** SOAP_FMAC4 soap_in_PointerTons7__SoapBreakpoints(struct soap *soap, const char *tag, ns7__SoapBreakpoints **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns7__SoapBreakpoints **)soap_malloc(soap, sizeof(ns7__SoapBreakpoints *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns7__SoapBreakpoints *)soap_instantiate_ns7__SoapBreakpoints(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns7__SoapBreakpoints **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__SoapBreakpoints, sizeof(ns7__SoapBreakpoints), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__SoapBreakpoints(struct soap *soap, ns7__SoapBreakpoints *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons7__SoapBreakpoints(soap, tag ? tag : "ns7:SoapBreakpoints", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns7__SoapBreakpoints ** SOAP_FMAC4 soap_get_PointerTons7__SoapBreakpoints(struct soap *soap, ns7__SoapBreakpoints **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__SoapBreakpoints(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__SoapPhysicalIoAttrib(struct soap *soap, ns7__SoapPhysicalIoAttrib *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__SoapPhysicalIoAttrib))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__SoapPhysicalIoAttrib(struct soap *soap, const char *tag, int id, ns7__SoapPhysicalIoAttrib *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__SoapPhysicalIoAttrib, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns7__SoapPhysicalIoAttrib ? type : NULL);
}

SOAP_FMAC3 ns7__SoapPhysicalIoAttrib ** SOAP_FMAC4 soap_in_PointerTons7__SoapPhysicalIoAttrib(struct soap *soap, const char *tag, ns7__SoapPhysicalIoAttrib **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns7__SoapPhysicalIoAttrib **)soap_malloc(soap, sizeof(ns7__SoapPhysicalIoAttrib *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns7__SoapPhysicalIoAttrib *)soap_instantiate_ns7__SoapPhysicalIoAttrib(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns7__SoapPhysicalIoAttrib **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__SoapPhysicalIoAttrib, sizeof(ns7__SoapPhysicalIoAttrib), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__SoapPhysicalIoAttrib(struct soap *soap, ns7__SoapPhysicalIoAttrib *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons7__SoapPhysicalIoAttrib(soap, tag ? tag : "ns7:SoapPhysicalIoAttrib", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns7__SoapPhysicalIoAttrib ** SOAP_FMAC4 soap_get_PointerTons7__SoapPhysicalIoAttrib(struct soap *soap, ns7__SoapPhysicalIoAttrib **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__SoapPhysicalIoAttrib(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__SoapPhysicalAioAttrib(struct soap *soap, ns7__SoapPhysicalAioAttrib *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__SoapPhysicalAioAttrib))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__SoapPhysicalAioAttrib(struct soap *soap, const char *tag, int id, ns7__SoapPhysicalAioAttrib *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__SoapPhysicalAioAttrib, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns7__SoapPhysicalAioAttrib ? type : NULL);
}

SOAP_FMAC3 ns7__SoapPhysicalAioAttrib ** SOAP_FMAC4 soap_in_PointerTons7__SoapPhysicalAioAttrib(struct soap *soap, const char *tag, ns7__SoapPhysicalAioAttrib **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns7__SoapPhysicalAioAttrib **)soap_malloc(soap, sizeof(ns7__SoapPhysicalAioAttrib *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns7__SoapPhysicalAioAttrib *)soap_instantiate_ns7__SoapPhysicalAioAttrib(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns7__SoapPhysicalAioAttrib **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__SoapPhysicalAioAttrib, sizeof(ns7__SoapPhysicalAioAttrib), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__SoapPhysicalAioAttrib(struct soap *soap, ns7__SoapPhysicalAioAttrib *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons7__SoapPhysicalAioAttrib(soap, tag ? tag : "ns7:SoapPhysicalAioAttrib", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns7__SoapPhysicalAioAttrib ** SOAP_FMAC4 soap_get_PointerTons7__SoapPhysicalAioAttrib(struct soap *soap, ns7__SoapPhysicalAioAttrib **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__SoapPhysicalAioAttrib(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__SoapPhysicalDioAttrib(struct soap *soap, ns7__SoapPhysicalDioAttrib *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__SoapPhysicalDioAttrib))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__SoapPhysicalDioAttrib(struct soap *soap, const char *tag, int id, ns7__SoapPhysicalDioAttrib *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__SoapPhysicalDioAttrib, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns7__SoapPhysicalDioAttrib ? type : NULL);
}

SOAP_FMAC3 ns7__SoapPhysicalDioAttrib ** SOAP_FMAC4 soap_in_PointerTons7__SoapPhysicalDioAttrib(struct soap *soap, const char *tag, ns7__SoapPhysicalDioAttrib **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns7__SoapPhysicalDioAttrib **)soap_malloc(soap, sizeof(ns7__SoapPhysicalDioAttrib *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns7__SoapPhysicalDioAttrib *)soap_instantiate_ns7__SoapPhysicalDioAttrib(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns7__SoapPhysicalDioAttrib **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__SoapPhysicalDioAttrib, sizeof(ns7__SoapPhysicalDioAttrib), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__SoapPhysicalDioAttrib(struct soap *soap, ns7__SoapPhysicalDioAttrib *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons7__SoapPhysicalDioAttrib(soap, tag ? tag : "ns7:SoapPhysicalDioAttrib", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns7__SoapPhysicalDioAttrib ** SOAP_FMAC4 soap_get_PointerTons7__SoapPhysicalDioAttrib(struct soap *soap, ns7__SoapPhysicalDioAttrib **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__SoapPhysicalDioAttrib(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__SoapInstruction(struct soap *soap, ns7__SoapInstruction *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__SoapInstruction))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__SoapInstruction(struct soap *soap, const char *tag, int id, ns7__SoapInstruction *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__SoapInstruction, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns7__SoapInstruction ? type : NULL);
}

SOAP_FMAC3 ns7__SoapInstruction ** SOAP_FMAC4 soap_in_PointerTons7__SoapInstruction(struct soap *soap, const char *tag, ns7__SoapInstruction **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns7__SoapInstruction **)soap_malloc(soap, sizeof(ns7__SoapInstruction *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns7__SoapInstruction *)soap_instantiate_ns7__SoapInstruction(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns7__SoapInstruction **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__SoapInstruction, sizeof(ns7__SoapInstruction), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__SoapInstruction(struct soap *soap, ns7__SoapInstruction *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons7__SoapInstruction(soap, tag ? tag : "ns7:SoapInstruction", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns7__SoapInstruction ** SOAP_FMAC4 soap_get_PointerTons7__SoapInstruction(struct soap *soap, ns7__SoapInstruction **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__SoapInstruction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__SoapProgramLine(struct soap *soap, ns7__SoapProgramLine *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__SoapProgramLine))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__SoapProgramLine(struct soap *soap, const char *tag, int id, ns7__SoapProgramLine *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__SoapProgramLine, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns7__SoapProgramLine ? type : NULL);
}

SOAP_FMAC3 ns7__SoapProgramLine ** SOAP_FMAC4 soap_in_PointerTons7__SoapProgramLine(struct soap *soap, const char *tag, ns7__SoapProgramLine **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns7__SoapProgramLine **)soap_malloc(soap, sizeof(ns7__SoapProgramLine *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns7__SoapProgramLine *)soap_instantiate_ns7__SoapProgramLine(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns7__SoapProgramLine **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__SoapProgramLine, sizeof(ns7__SoapProgramLine), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__SoapProgramLine(struct soap *soap, ns7__SoapProgramLine *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons7__SoapProgramLine(soap, tag ? tag : "ns7:SoapProgramLine", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns7__SoapProgramLine ** SOAP_FMAC4 soap_get_PointerTons7__SoapProgramLine(struct soap *soap, ns7__SoapProgramLine **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__SoapProgramLine(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__SoapDhParameters(struct soap *soap, ns7__SoapDhParameters *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__SoapDhParameters))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__SoapDhParameters(struct soap *soap, const char *tag, int id, ns7__SoapDhParameters *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__SoapDhParameters, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns7__SoapDhParameters ? type : NULL);
}

SOAP_FMAC3 ns7__SoapDhParameters ** SOAP_FMAC4 soap_in_PointerTons7__SoapDhParameters(struct soap *soap, const char *tag, ns7__SoapDhParameters **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns7__SoapDhParameters **)soap_malloc(soap, sizeof(ns7__SoapDhParameters *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns7__SoapDhParameters *)soap_instantiate_ns7__SoapDhParameters(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns7__SoapDhParameters **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__SoapDhParameters, sizeof(ns7__SoapDhParameters), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__SoapDhParameters(struct soap *soap, ns7__SoapDhParameters *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons7__SoapDhParameters(soap, tag ? tag : "ns7:SoapDhParameters", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns7__SoapDhParameters ** SOAP_FMAC4 soap_get_PointerTons7__SoapDhParameters(struct soap *soap, ns7__SoapDhParameters **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__SoapDhParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__SoapPhysicalIoUnlockResponse(struct soap *soap, ns7__SoapPhysicalIoUnlockResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__SoapPhysicalIoUnlockResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__SoapPhysicalIoUnlockResponse(struct soap *soap, const char *tag, int id, ns7__SoapPhysicalIoUnlockResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__SoapPhysicalIoUnlockResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns7__SoapPhysicalIoUnlockResponse ? type : NULL);
}

SOAP_FMAC3 ns7__SoapPhysicalIoUnlockResponse ** SOAP_FMAC4 soap_in_PointerTons7__SoapPhysicalIoUnlockResponse(struct soap *soap, const char *tag, ns7__SoapPhysicalIoUnlockResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns7__SoapPhysicalIoUnlockResponse **)soap_malloc(soap, sizeof(ns7__SoapPhysicalIoUnlockResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns7__SoapPhysicalIoUnlockResponse *)soap_instantiate_ns7__SoapPhysicalIoUnlockResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns7__SoapPhysicalIoUnlockResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__SoapPhysicalIoUnlockResponse, sizeof(ns7__SoapPhysicalIoUnlockResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__SoapPhysicalIoUnlockResponse(struct soap *soap, ns7__SoapPhysicalIoUnlockResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons7__SoapPhysicalIoUnlockResponse(soap, tag ? tag : "ns7:SoapPhysicalIoUnlockResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns7__SoapPhysicalIoUnlockResponse ** SOAP_FMAC4 soap_get_PointerTons7__SoapPhysicalIoUnlockResponse(struct soap *soap, ns7__SoapPhysicalIoUnlockResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__SoapPhysicalIoUnlockResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__SoapPhysicalIoResponse(struct soap *soap, ns7__SoapPhysicalIoResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__SoapPhysicalIoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__SoapPhysicalIoResponse(struct soap *soap, const char *tag, int id, ns7__SoapPhysicalIoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__SoapPhysicalIoResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns7__SoapPhysicalIoResponse ? type : NULL);
}

SOAP_FMAC3 ns7__SoapPhysicalIoResponse ** SOAP_FMAC4 soap_in_PointerTons7__SoapPhysicalIoResponse(struct soap *soap, const char *tag, ns7__SoapPhysicalIoResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns7__SoapPhysicalIoResponse **)soap_malloc(soap, sizeof(ns7__SoapPhysicalIoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns7__SoapPhysicalIoResponse *)soap_instantiate_ns7__SoapPhysicalIoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns7__SoapPhysicalIoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__SoapPhysicalIoResponse, sizeof(ns7__SoapPhysicalIoResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__SoapPhysicalIoResponse(struct soap *soap, ns7__SoapPhysicalIoResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons7__SoapPhysicalIoResponse(soap, tag ? tag : "ns7:SoapPhysicalIoResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns7__SoapPhysicalIoResponse ** SOAP_FMAC4 soap_get_PointerTons7__SoapPhysicalIoResponse(struct soap *soap, ns7__SoapPhysicalIoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__SoapPhysicalIoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__SoapPhysicalIoState(struct soap *soap, ns7__SoapPhysicalIoState *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__SoapPhysicalIoState))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__SoapPhysicalIoState(struct soap *soap, const char *tag, int id, ns7__SoapPhysicalIoState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__SoapPhysicalIoState, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns7__SoapPhysicalIoState ? type : NULL);
}

SOAP_FMAC3 ns7__SoapPhysicalIoState ** SOAP_FMAC4 soap_in_PointerTons7__SoapPhysicalIoState(struct soap *soap, const char *tag, ns7__SoapPhysicalIoState **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns7__SoapPhysicalIoState **)soap_malloc(soap, sizeof(ns7__SoapPhysicalIoState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns7__SoapPhysicalIoState *)soap_instantiate_ns7__SoapPhysicalIoState(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns7__SoapPhysicalIoState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__SoapPhysicalIoState, sizeof(ns7__SoapPhysicalIoState), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__SoapPhysicalIoState(struct soap *soap, ns7__SoapPhysicalIoState *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons7__SoapPhysicalIoState(soap, tag ? tag : "ns7:SoapPhysicalIoState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns7__SoapPhysicalIoState ** SOAP_FMAC4 soap_get_PointerTons7__SoapPhysicalIoState(struct soap *soap, ns7__SoapPhysicalIoState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__SoapPhysicalIoState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__SoapData(struct soap *soap, ns7__SoapData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__SoapData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__SoapData(struct soap *soap, const char *tag, int id, ns7__SoapData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__SoapData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns7__SoapData ? type : NULL);
}

SOAP_FMAC3 ns7__SoapData ** SOAP_FMAC4 soap_in_PointerTons7__SoapData(struct soap *soap, const char *tag, ns7__SoapData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns7__SoapData **)soap_malloc(soap, sizeof(ns7__SoapData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns7__SoapData *)soap_instantiate_ns7__SoapData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns7__SoapData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__SoapData, sizeof(ns7__SoapData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__SoapData(struct soap *soap, ns7__SoapData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons7__SoapData(soap, tag ? tag : "ns7:SoapData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns7__SoapData ** SOAP_FMAC4 soap_get_PointerTons7__SoapData(struct soap *soap, ns7__SoapData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__SoapData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__SoapStackFrameAbstract(struct soap *soap, ns7__SoapStackFrameAbstract *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__SoapStackFrameAbstract))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__SoapStackFrameAbstract(struct soap *soap, const char *tag, int id, ns7__SoapStackFrameAbstract *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__SoapStackFrameAbstract, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns7__SoapStackFrameAbstract ? type : NULL);
}

SOAP_FMAC3 ns7__SoapStackFrameAbstract ** SOAP_FMAC4 soap_in_PointerTons7__SoapStackFrameAbstract(struct soap *soap, const char *tag, ns7__SoapStackFrameAbstract **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns7__SoapStackFrameAbstract **)soap_malloc(soap, sizeof(ns7__SoapStackFrameAbstract *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns7__SoapStackFrameAbstract *)soap_instantiate_ns7__SoapStackFrameAbstract(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns7__SoapStackFrameAbstract **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__SoapStackFrameAbstract, sizeof(ns7__SoapStackFrameAbstract), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__SoapStackFrameAbstract(struct soap *soap, ns7__SoapStackFrameAbstract *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons7__SoapStackFrameAbstract(soap, tag ? tag : "ns7:SoapStackFrameAbstract", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns7__SoapStackFrameAbstract ** SOAP_FMAC4 soap_get_PointerTons7__SoapStackFrameAbstract(struct soap *soap, ns7__SoapStackFrameAbstract **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__SoapStackFrameAbstract(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__SoapTask(struct soap *soap, ns7__SoapTask *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__SoapTask))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__SoapTask(struct soap *soap, const char *tag, int id, ns7__SoapTask *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__SoapTask, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns7__SoapTask ? type : NULL);
}

SOAP_FMAC3 ns7__SoapTask ** SOAP_FMAC4 soap_in_PointerTons7__SoapTask(struct soap *soap, const char *tag, ns7__SoapTask **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns7__SoapTask **)soap_malloc(soap, sizeof(ns7__SoapTask *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns7__SoapTask *)soap_instantiate_ns7__SoapTask(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns7__SoapTask **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__SoapTask, sizeof(ns7__SoapTask), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__SoapTask(struct soap *soap, ns7__SoapTask *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons7__SoapTask(soap, tag ? tag : "ns7:SoapTask", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns7__SoapTask ** SOAP_FMAC4 soap_get_PointerTons7__SoapTask(struct soap *soap, ns7__SoapTask **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__SoapTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__BreakpointsResponse(struct soap *soap, ns7__BreakpointsResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__BreakpointsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__BreakpointsResponse(struct soap *soap, const char *tag, int id, ns7__BreakpointsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__BreakpointsResponse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns7__BreakpointsResponse ? type : NULL);
}

SOAP_FMAC3 ns7__BreakpointsResponse ** SOAP_FMAC4 soap_in_PointerTons7__BreakpointsResponse(struct soap *soap, const char *tag, ns7__BreakpointsResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns7__BreakpointsResponse **)soap_malloc(soap, sizeof(ns7__BreakpointsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns7__BreakpointsResponse *)soap_instantiate_ns7__BreakpointsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns7__BreakpointsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__BreakpointsResponse, sizeof(ns7__BreakpointsResponse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__BreakpointsResponse(struct soap *soap, ns7__BreakpointsResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons7__BreakpointsResponse(soap, tag ? tag : "ns7:BreakpointsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns7__BreakpointsResponse ** SOAP_FMAC4 soap_get_PointerTons7__BreakpointsResponse(struct soap *soap, ns7__BreakpointsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__BreakpointsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__SoapBreakpoint(struct soap *soap, ns7__SoapBreakpoint *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__SoapBreakpoint))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__SoapBreakpoint(struct soap *soap, const char *tag, int id, ns7__SoapBreakpoint *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__SoapBreakpoint, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns7__SoapBreakpoint ? type : NULL);
}

SOAP_FMAC3 ns7__SoapBreakpoint ** SOAP_FMAC4 soap_in_PointerTons7__SoapBreakpoint(struct soap *soap, const char *tag, ns7__SoapBreakpoint **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns7__SoapBreakpoint **)soap_malloc(soap, sizeof(ns7__SoapBreakpoint *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns7__SoapBreakpoint *)soap_instantiate_ns7__SoapBreakpoint(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns7__SoapBreakpoint **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__SoapBreakpoint, sizeof(ns7__SoapBreakpoint), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__SoapBreakpoint(struct soap *soap, ns7__SoapBreakpoint *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons7__SoapBreakpoint(soap, tag ? tag : "ns7:SoapBreakpoint", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns7__SoapBreakpoint ** SOAP_FMAC4 soap_get_PointerTons7__SoapBreakpoint(struct soap *soap, ns7__SoapBreakpoint **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__SoapBreakpoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__VALApplication(struct soap *soap, ns2__VALApplication *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__VALApplication))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__VALApplication(struct soap *soap, const char *tag, int id, ns2__VALApplication *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__VALApplication, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__VALApplication ? type : NULL);
}

SOAP_FMAC3 ns2__VALApplication ** SOAP_FMAC4 soap_in_PointerTons2__VALApplication(struct soap *soap, const char *tag, ns2__VALApplication **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__VALApplication **)soap_malloc(soap, sizeof(ns2__VALApplication *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__VALApplication *)soap_instantiate_ns2__VALApplication(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__VALApplication **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__VALApplication, sizeof(ns2__VALApplication), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__VALApplication(struct soap *soap, ns2__VALApplication *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__VALApplication(soap, tag ? tag : "ns2:VALApplication", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__VALApplication ** SOAP_FMAC4 soap_get_PointerTons2__VALApplication(struct soap *soap, ns2__VALApplication **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__VALApplication(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CartesianPos(struct soap *soap, ns1__CartesianPos *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CartesianPos))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CartesianPos(struct soap *soap, const char *tag, int id, ns1__CartesianPos *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CartesianPos, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__CartesianPos ? type : NULL);
}

SOAP_FMAC3 ns1__CartesianPos ** SOAP_FMAC4 soap_in_PointerTons1__CartesianPos(struct soap *soap, const char *tag, ns1__CartesianPos **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CartesianPos **)soap_malloc(soap, sizeof(ns1__CartesianPos *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CartesianPos *)soap_instantiate_ns1__CartesianPos(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__CartesianPos **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CartesianPos, sizeof(ns1__CartesianPos), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CartesianPos(struct soap *soap, ns1__CartesianPos *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__CartesianPos(soap, tag ? tag : "ns1:CartesianPos", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CartesianPos ** SOAP_FMAC4 soap_get_PointerTons1__CartesianPos(struct soap *soap, ns1__CartesianPos **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CartesianPos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__JointPos(struct soap *soap, ns1__JointPos *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__JointPos))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__JointPos(struct soap *soap, const char *tag, int id, ns1__JointPos *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__JointPos, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__JointPos ? type : NULL);
}

SOAP_FMAC3 ns1__JointPos ** SOAP_FMAC4 soap_in_PointerTons1__JointPos(struct soap *soap, const char *tag, ns1__JointPos **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__JointPos **)soap_malloc(soap, sizeof(ns1__JointPos *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__JointPos *)soap_instantiate_ns1__JointPos(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__JointPos **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__JointPos, sizeof(ns1__JointPos), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__JointPos(struct soap *soap, ns1__JointPos *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__JointPos(soap, tag ? tag : "ns1:JointPos", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__JointPos ** SOAP_FMAC4 soap_get_PointerTons1__JointPos(struct soap *soap, ns1__JointPos **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__JointPos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Robots(struct soap *soap, ns1__Robots *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Robots))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Robots(struct soap *soap, const char *tag, int id, ns1__Robots *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Robots, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__Robots ? type : NULL);
}

SOAP_FMAC3 ns1__Robots ** SOAP_FMAC4 soap_in_PointerTons1__Robots(struct soap *soap, const char *tag, ns1__Robots **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Robots **)soap_malloc(soap, sizeof(ns1__Robots *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Robots *)soap_instantiate_ns1__Robots(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__Robots **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Robots, sizeof(ns1__Robots), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Robots(struct soap *soap, ns1__Robots *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Robots(soap, tag ? tag : "ns1:Robots", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Robots ** SOAP_FMAC4 soap_get_PointerTons1__Robots(struct soap *soap, ns1__Robots **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Robots(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Parameters(struct soap *soap, ns1__Parameters *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Parameters))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Parameters(struct soap *soap, const char *tag, int id, ns1__Parameters *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Parameters, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__Parameters ? type : NULL);
}

SOAP_FMAC3 ns1__Parameters ** SOAP_FMAC4 soap_in_PointerTons1__Parameters(struct soap *soap, const char *tag, ns1__Parameters **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Parameters **)soap_malloc(soap, sizeof(ns1__Parameters *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Parameters *)soap_instantiate_ns1__Parameters(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__Parameters **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Parameters, sizeof(ns1__Parameters), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Parameters(struct soap *soap, ns1__Parameters *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Parameters(soap, tag ? tag : "ns1:Parameters", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Parameters ** SOAP_FMAC4 soap_get_PointerTons1__Parameters(struct soap *soap, ns1__Parameters **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Parameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Versions(struct soap *soap, ns1__Versions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Versions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Versions(struct soap *soap, const char *tag, int id, ns1__Versions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Versions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__Versions ? type : NULL);
}

SOAP_FMAC3 ns1__Versions ** SOAP_FMAC4 soap_in_PointerTons1__Versions(struct soap *soap, const char *tag, ns1__Versions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Versions **)soap_malloc(soap, sizeof(ns1__Versions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Versions *)soap_instantiate_ns1__Versions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__Versions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Versions, sizeof(ns1__Versions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Versions(struct soap *soap, ns1__Versions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Versions(soap, tag ? tag : "ns1:Versions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Versions ** SOAP_FMAC4 soap_get_PointerTons1__Versions(struct soap *soap, ns1__Versions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Versions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SoapServerVersion(struct soap *soap, ns1__SoapServerVersion *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SoapServerVersion))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SoapServerVersion(struct soap *soap, const char *tag, int id, ns1__SoapServerVersion *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SoapServerVersion, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__SoapServerVersion ? type : NULL);
}

SOAP_FMAC3 ns1__SoapServerVersion ** SOAP_FMAC4 soap_in_PointerTons1__SoapServerVersion(struct soap *soap, const char *tag, ns1__SoapServerVersion **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SoapServerVersion **)soap_malloc(soap, sizeof(ns1__SoapServerVersion *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SoapServerVersion *)soap_instantiate_ns1__SoapServerVersion(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__SoapServerVersion **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SoapServerVersion, sizeof(ns1__SoapServerVersion), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SoapServerVersion(struct soap *soap, ns1__SoapServerVersion *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SoapServerVersion(soap, tag ? tag : "ns1:SoapServerVersion", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SoapServerVersion ** SOAP_FMAC4 soap_get_PointerTons1__SoapServerVersion(struct soap *soap, ns1__SoapServerVersion **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SoapServerVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Robot(struct soap *soap, ns1__Robot *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Robot))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Robot(struct soap *soap, const char *tag, int id, ns1__Robot *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Robot, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__Robot ? type : NULL);
}

SOAP_FMAC3 ns1__Robot ** SOAP_FMAC4 soap_in_PointerTons1__Robot(struct soap *soap, const char *tag, ns1__Robot **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Robot **)soap_malloc(soap, sizeof(ns1__Robot *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Robot *)soap_instantiate_ns1__Robot(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__Robot **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Robot, sizeof(ns1__Robot), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Robot(struct soap *soap, ns1__Robot *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Robot(soap, tag ? tag : "ns1:Robot", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Robot ** SOAP_FMAC4 soap_get_PointerTons1__Robot(struct soap *soap, ns1__Robot **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Robot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Version(struct soap *soap, ns1__Version *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Version))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Version(struct soap *soap, const char *tag, int id, ns1__Version *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Version, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__Version ? type : NULL);
}

SOAP_FMAC3 ns1__Version ** SOAP_FMAC4 soap_in_PointerTons1__Version(struct soap *soap, const char *tag, ns1__Version **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Version **)soap_malloc(soap, sizeof(ns1__Version *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Version *)soap_instantiate_ns1__Version(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__Version **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Version, sizeof(ns1__Version), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Version(struct soap *soap, ns1__Version *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Version(soap, tag ? tag : "ns1:Version", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Version ** SOAP_FMAC4 soap_get_PointerTons1__Version(struct soap *soap, ns1__Version **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Version(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Parameter(struct soap *soap, ns1__Parameter *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Parameter))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Parameter(struct soap *soap, const char *tag, int id, ns1__Parameter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Parameter, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__Parameter ? type : NULL);
}

SOAP_FMAC3 ns1__Parameter ** SOAP_FMAC4 soap_in_PointerTons1__Parameter(struct soap *soap, const char *tag, ns1__Parameter **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Parameter **)soap_malloc(soap, sizeof(ns1__Parameter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Parameter *)soap_instantiate_ns1__Parameter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__Parameter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Parameter, sizeof(ns1__Parameter), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Parameter(struct soap *soap, ns1__Parameter *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Parameter(soap, tag ? tag : "ns1:Parameter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Parameter ** SOAP_FMAC4 soap_get_PointerTons1__Parameter(struct soap *soap, ns1__Parameter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Parameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTostd__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_unsignedByte);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedByte, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTounsignedByte(soap, tag ? tag : "unsignedByte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new_string(struct soap *soap, int n)
{
	char * *a = static_cast<char * *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char *)));
	for (char * *p = a; p && n--; ++p)
		soap_default_string(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_XML(struct soap *soap, std::vector<char *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_XML(struct soap *soap, const std::vector<char *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_XML(struct soap *soap, const char *tag, int id, const std::vector<char *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<char *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_outliteral(soap, tag, (char*const*)&(*i), NULL))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<char *> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_XML(struct soap *soap, const char *tag, std::vector<char *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOf_XML(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		char *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE__XML, SOAP_TYPE_std__vectorTemplateOf_XML, sizeof(char *), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_inliteral(soap, tag, NULL))
				break;
		}
		else
		{	if (!soap_inliteral(soap, tag, &n))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<char *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_XML(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_XML(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<char *> *p;
	size_t k = sizeof(std::vector<char *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<char *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<char *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<char *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOf_XML, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons7__SoapDhParameters(struct soap *soap, std::vector<ns7__SoapDhParameters *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons7__SoapDhParameters(struct soap *soap, const std::vector<ns7__SoapDhParameters *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns7__SoapDhParameters *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons7__SoapDhParameters(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons7__SoapDhParameters(struct soap *soap, const char *tag, int id, const std::vector<ns7__SoapDhParameters *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns7__SoapDhParameters *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons7__SoapDhParameters(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns7__SoapDhParameters *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons7__SoapDhParameters(struct soap *soap, const char *tag, std::vector<ns7__SoapDhParameters *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons7__SoapDhParameters(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns7__SoapDhParameters *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns7__SoapDhParameters, SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapDhParameters, sizeof(ns7__SoapDhParameters), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons7__SoapDhParameters(soap, tag, NULL, "ns7:SoapDhParameters"))
				break;
		}
		else
		{	if (!soap_in_PointerTons7__SoapDhParameters(soap, tag, &n, "ns7:SoapDhParameters"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns7__SoapDhParameters *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons7__SoapDhParameters(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons7__SoapDhParameters(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns7__SoapDhParameters *> *p;
	size_t k = sizeof(std::vector<ns7__SoapDhParameters *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns7__SoapDhParameters *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns7__SoapDhParameters *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns7__SoapDhParameters *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapDhParameters, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons7__SoapPhysicalIoUnlockResponse(struct soap *soap, std::vector<ns7__SoapPhysicalIoUnlockResponse *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons7__SoapPhysicalIoUnlockResponse(struct soap *soap, const std::vector<ns7__SoapPhysicalIoUnlockResponse *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns7__SoapPhysicalIoUnlockResponse *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons7__SoapPhysicalIoUnlockResponse(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons7__SoapPhysicalIoUnlockResponse(struct soap *soap, const char *tag, int id, const std::vector<ns7__SoapPhysicalIoUnlockResponse *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns7__SoapPhysicalIoUnlockResponse *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons7__SoapPhysicalIoUnlockResponse(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns7__SoapPhysicalIoUnlockResponse *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons7__SoapPhysicalIoUnlockResponse(struct soap *soap, const char *tag, std::vector<ns7__SoapPhysicalIoUnlockResponse *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons7__SoapPhysicalIoUnlockResponse(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns7__SoapPhysicalIoUnlockResponse *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns7__SoapPhysicalIoUnlockResponse, SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapPhysicalIoUnlockResponse, sizeof(ns7__SoapPhysicalIoUnlockResponse), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons7__SoapPhysicalIoUnlockResponse(soap, tag, NULL, "ns7:SoapPhysicalIoUnlockResponse"))
				break;
		}
		else
		{	if (!soap_in_PointerTons7__SoapPhysicalIoUnlockResponse(soap, tag, &n, "ns7:SoapPhysicalIoUnlockResponse"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns7__SoapPhysicalIoUnlockResponse *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons7__SoapPhysicalIoUnlockResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons7__SoapPhysicalIoUnlockResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns7__SoapPhysicalIoUnlockResponse *> *p;
	size_t k = sizeof(std::vector<ns7__SoapPhysicalIoUnlockResponse *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns7__SoapPhysicalIoUnlockResponse *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns7__SoapPhysicalIoUnlockResponse *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns7__SoapPhysicalIoUnlockResponse *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapPhysicalIoUnlockResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons7__SoapPhysicalIoResponse(struct soap *soap, std::vector<ns7__SoapPhysicalIoResponse *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons7__SoapPhysicalIoResponse(struct soap *soap, const std::vector<ns7__SoapPhysicalIoResponse *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns7__SoapPhysicalIoResponse *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons7__SoapPhysicalIoResponse(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons7__SoapPhysicalIoResponse(struct soap *soap, const char *tag, int id, const std::vector<ns7__SoapPhysicalIoResponse *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns7__SoapPhysicalIoResponse *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons7__SoapPhysicalIoResponse(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns7__SoapPhysicalIoResponse *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons7__SoapPhysicalIoResponse(struct soap *soap, const char *tag, std::vector<ns7__SoapPhysicalIoResponse *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons7__SoapPhysicalIoResponse(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns7__SoapPhysicalIoResponse *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns7__SoapPhysicalIoResponse, SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapPhysicalIoResponse, sizeof(ns7__SoapPhysicalIoResponse), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons7__SoapPhysicalIoResponse(soap, tag, NULL, "ns7:SoapPhysicalIoResponse"))
				break;
		}
		else
		{	if (!soap_in_PointerTons7__SoapPhysicalIoResponse(soap, tag, &n, "ns7:SoapPhysicalIoResponse"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns7__SoapPhysicalIoResponse *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons7__SoapPhysicalIoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons7__SoapPhysicalIoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns7__SoapPhysicalIoResponse *> *p;
	size_t k = sizeof(std::vector<ns7__SoapPhysicalIoResponse *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns7__SoapPhysicalIoResponse *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns7__SoapPhysicalIoResponse *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns7__SoapPhysicalIoResponse *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapPhysicalIoResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons7__SoapPhysicalIoState(struct soap *soap, std::vector<ns7__SoapPhysicalIoState *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons7__SoapPhysicalIoState(struct soap *soap, const std::vector<ns7__SoapPhysicalIoState *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns7__SoapPhysicalIoState *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons7__SoapPhysicalIoState(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons7__SoapPhysicalIoState(struct soap *soap, const char *tag, int id, const std::vector<ns7__SoapPhysicalIoState *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns7__SoapPhysicalIoState *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons7__SoapPhysicalIoState(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns7__SoapPhysicalIoState *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons7__SoapPhysicalIoState(struct soap *soap, const char *tag, std::vector<ns7__SoapPhysicalIoState *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons7__SoapPhysicalIoState(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns7__SoapPhysicalIoState *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns7__SoapPhysicalIoState, SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapPhysicalIoState, sizeof(ns7__SoapPhysicalIoState), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons7__SoapPhysicalIoState(soap, tag, NULL, "ns7:SoapPhysicalIoState"))
				break;
		}
		else
		{	if (!soap_in_PointerTons7__SoapPhysicalIoState(soap, tag, &n, "ns7:SoapPhysicalIoState"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns7__SoapPhysicalIoState *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons7__SoapPhysicalIoState(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons7__SoapPhysicalIoState(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns7__SoapPhysicalIoState *> *p;
	size_t k = sizeof(std::vector<ns7__SoapPhysicalIoState *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns7__SoapPhysicalIoState *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns7__SoapPhysicalIoState *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns7__SoapPhysicalIoState *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapPhysicalIoState, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons7__SoapData(struct soap *soap, std::vector<ns7__SoapData *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons7__SoapData(struct soap *soap, const std::vector<ns7__SoapData *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns7__SoapData *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons7__SoapData(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons7__SoapData(struct soap *soap, const char *tag, int id, const std::vector<ns7__SoapData *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns7__SoapData *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons7__SoapData(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns7__SoapData *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons7__SoapData(struct soap *soap, const char *tag, std::vector<ns7__SoapData *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons7__SoapData(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns7__SoapData *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns7__SoapData, SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapData, sizeof(ns7__SoapData), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons7__SoapData(soap, tag, NULL, "ns7:SoapData"))
				break;
		}
		else
		{	if (!soap_in_PointerTons7__SoapData(soap, tag, &n, "ns7:SoapData"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns7__SoapData *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons7__SoapData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons7__SoapData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns7__SoapData *> *p;
	size_t k = sizeof(std::vector<ns7__SoapData *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns7__SoapData *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns7__SoapData *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns7__SoapData *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapData, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons7__SoapStackFrameAbstract(struct soap *soap, std::vector<ns7__SoapStackFrameAbstract *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons7__SoapStackFrameAbstract(struct soap *soap, const std::vector<ns7__SoapStackFrameAbstract *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns7__SoapStackFrameAbstract *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons7__SoapStackFrameAbstract(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons7__SoapStackFrameAbstract(struct soap *soap, const char *tag, int id, const std::vector<ns7__SoapStackFrameAbstract *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns7__SoapStackFrameAbstract *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons7__SoapStackFrameAbstract(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns7__SoapStackFrameAbstract *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons7__SoapStackFrameAbstract(struct soap *soap, const char *tag, std::vector<ns7__SoapStackFrameAbstract *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons7__SoapStackFrameAbstract(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns7__SoapStackFrameAbstract *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns7__SoapStackFrameAbstract, SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapStackFrameAbstract, sizeof(ns7__SoapStackFrameAbstract), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons7__SoapStackFrameAbstract(soap, tag, NULL, "ns7:SoapStackFrameAbstract"))
				break;
		}
		else
		{	if (!soap_in_PointerTons7__SoapStackFrameAbstract(soap, tag, &n, "ns7:SoapStackFrameAbstract"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns7__SoapStackFrameAbstract *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons7__SoapStackFrameAbstract(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons7__SoapStackFrameAbstract(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns7__SoapStackFrameAbstract *> *p;
	size_t k = sizeof(std::vector<ns7__SoapStackFrameAbstract *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns7__SoapStackFrameAbstract *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns7__SoapStackFrameAbstract *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns7__SoapStackFrameAbstract *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapStackFrameAbstract, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons7__SoapTask(struct soap *soap, std::vector<ns7__SoapTask *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons7__SoapTask(struct soap *soap, const std::vector<ns7__SoapTask *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns7__SoapTask *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons7__SoapTask(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons7__SoapTask(struct soap *soap, const char *tag, int id, const std::vector<ns7__SoapTask *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns7__SoapTask *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons7__SoapTask(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns7__SoapTask *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons7__SoapTask(struct soap *soap, const char *tag, std::vector<ns7__SoapTask *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons7__SoapTask(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns7__SoapTask *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns7__SoapTask, SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapTask, sizeof(ns7__SoapTask), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons7__SoapTask(soap, tag, NULL, "ns7:SoapTask"))
				break;
		}
		else
		{	if (!soap_in_PointerTons7__SoapTask(soap, tag, &n, "ns7:SoapTask"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns7__SoapTask *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons7__SoapTask(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons7__SoapTask(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns7__SoapTask *> *p;
	size_t k = sizeof(std::vector<ns7__SoapTask *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns7__SoapTask *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns7__SoapTask *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns7__SoapTask *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapTask, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons7__BreakpointsResponse(struct soap *soap, std::vector<ns7__BreakpointsResponse *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons7__BreakpointsResponse(struct soap *soap, const std::vector<ns7__BreakpointsResponse *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns7__BreakpointsResponse *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons7__BreakpointsResponse(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons7__BreakpointsResponse(struct soap *soap, const char *tag, int id, const std::vector<ns7__BreakpointsResponse *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns7__BreakpointsResponse *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons7__BreakpointsResponse(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns7__BreakpointsResponse *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons7__BreakpointsResponse(struct soap *soap, const char *tag, std::vector<ns7__BreakpointsResponse *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons7__BreakpointsResponse(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns7__BreakpointsResponse *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns7__BreakpointsResponse, SOAP_TYPE_std__vectorTemplateOfPointerTons7__BreakpointsResponse, sizeof(ns7__BreakpointsResponse), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons7__BreakpointsResponse(soap, tag, NULL, "ns7:BreakpointsResponse"))
				break;
		}
		else
		{	if (!soap_in_PointerTons7__BreakpointsResponse(soap, tag, &n, "ns7:BreakpointsResponse"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns7__BreakpointsResponse *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons7__BreakpointsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons7__BreakpointsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns7__BreakpointsResponse *> *p;
	size_t k = sizeof(std::vector<ns7__BreakpointsResponse *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns7__BreakpointsResponse *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns7__BreakpointsResponse *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns7__BreakpointsResponse *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons7__BreakpointsResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons7__SoapBreakpoint(struct soap *soap, std::vector<ns7__SoapBreakpoint *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons7__SoapBreakpoint(struct soap *soap, const std::vector<ns7__SoapBreakpoint *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns7__SoapBreakpoint *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons7__SoapBreakpoint(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons7__SoapBreakpoint(struct soap *soap, const char *tag, int id, const std::vector<ns7__SoapBreakpoint *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns7__SoapBreakpoint *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons7__SoapBreakpoint(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns7__SoapBreakpoint *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons7__SoapBreakpoint(struct soap *soap, const char *tag, std::vector<ns7__SoapBreakpoint *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons7__SoapBreakpoint(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns7__SoapBreakpoint *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns7__SoapBreakpoint, SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapBreakpoint, sizeof(ns7__SoapBreakpoint), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons7__SoapBreakpoint(soap, tag, NULL, "ns7:SoapBreakpoint"))
				break;
		}
		else
		{	if (!soap_in_PointerTons7__SoapBreakpoint(soap, tag, &n, "ns7:SoapBreakpoint"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns7__SoapBreakpoint *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons7__SoapBreakpoint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons7__SoapBreakpoint(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns7__SoapBreakpoint *> *p;
	size_t k = sizeof(std::vector<ns7__SoapBreakpoint *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns7__SoapBreakpoint *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns7__SoapBreakpoint *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns7__SoapBreakpoint *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapBreakpoint, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_std__string(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_std__string(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfstd__string(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		std::string n;
		soap_default_std__string(soap, &n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_std__string, SOAP_TYPE_std__vectorTemplateOfstd__string, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_std__string(soap, tag, NULL, "xsd:string"))
				break;
		}
		else
		{	if (!soap_in_std__string(soap, tag, &n, "xsd:string"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(std::string));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfstd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfstd__string(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfstd__string, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__VALApplication(struct soap *soap, std::vector<ns2__VALApplication *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__VALApplication(struct soap *soap, const std::vector<ns2__VALApplication *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns2__VALApplication *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__VALApplication(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__VALApplication(struct soap *soap, const char *tag, int id, const std::vector<ns2__VALApplication *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns2__VALApplication *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__VALApplication(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__VALApplication *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__VALApplication(struct soap *soap, const char *tag, std::vector<ns2__VALApplication *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__VALApplication(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns2__VALApplication *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns2__VALApplication, SOAP_TYPE_std__vectorTemplateOfPointerTons2__VALApplication, sizeof(ns2__VALApplication), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons2__VALApplication(soap, tag, NULL, "ns2:VALApplication"))
				break;
		}
		else
		{	if (!soap_in_PointerTons2__VALApplication(soap, tag, &n, "ns2:VALApplication"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__VALApplication *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__VALApplication(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__VALApplication(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns2__VALApplication *> *p;
	size_t k = sizeof(std::vector<ns2__VALApplication *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns2__VALApplication *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns2__VALApplication *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns2__VALApplication *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons2__VALApplication, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__Robot(struct soap *soap, std::vector<ns1__Robot *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__Robot(struct soap *soap, const std::vector<ns1__Robot *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__Robot *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__Robot(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__Robot(struct soap *soap, const char *tag, int id, const std::vector<ns1__Robot *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__Robot *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__Robot(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__Robot *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__Robot(struct soap *soap, const char *tag, std::vector<ns1__Robot *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__Robot(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__Robot *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__Robot, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Robot, sizeof(ns1__Robot), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__Robot(soap, tag, NULL, "ns1:Robot"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__Robot(soap, tag, &n, "ns1:Robot"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__Robot *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__Robot(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__Robot(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__Robot *> *p;
	size_t k = sizeof(std::vector<ns1__Robot *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns1__Robot *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns1__Robot *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__Robot *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Robot, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__Version(struct soap *soap, std::vector<ns1__Version *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__Version(struct soap *soap, const std::vector<ns1__Version *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__Version *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__Version(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__Version(struct soap *soap, const char *tag, int id, const std::vector<ns1__Version *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__Version *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__Version(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__Version *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__Version(struct soap *soap, const char *tag, std::vector<ns1__Version *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__Version(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__Version *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__Version, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Version, sizeof(ns1__Version), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__Version(soap, tag, NULL, "ns1:Version"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__Version(soap, tag, &n, "ns1:Version"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__Version *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__Version(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__Version(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__Version *> *p;
	size_t k = sizeof(std::vector<ns1__Version *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns1__Version *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns1__Version *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__Version *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Version, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__Parameter(struct soap *soap, std::vector<ns1__Parameter *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__Parameter(struct soap *soap, const std::vector<ns1__Parameter *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__Parameter *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__Parameter(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__Parameter(struct soap *soap, const char *tag, int id, const std::vector<ns1__Parameter *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__Parameter *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__Parameter(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__Parameter *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__Parameter(struct soap *soap, const char *tag, std::vector<ns1__Parameter *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__Parameter(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__Parameter *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__Parameter, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Parameter, sizeof(ns1__Parameter), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__Parameter(soap, tag, NULL, "ns1:Parameter"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__Parameter(soap, tag, &n, "ns1:Parameter"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__Parameter *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__Parameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__Parameter(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__Parameter *> *p;
	size_t k = sizeof(std::vector<ns1__Parameter *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns1__Parameter *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns1__Parameter *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__Parameter *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Parameter, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfdouble(struct soap *soap, std::vector<double> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfdouble(struct soap *soap, const std::vector<double> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfdouble(struct soap *soap, const char *tag, int id, const std::vector<double> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<double> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_double(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<double> * SOAP_FMAC4 soap_in_std__vectorTemplateOfdouble(struct soap *soap, const char *tag, std::vector<double> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfdouble(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		double n;
		soap_default_double(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_double, SOAP_TYPE_std__vectorTemplateOfdouble, sizeof(double), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_double(soap, tag, NULL, "xsd:double"))
				break;
		}
		else
		{	if (!soap_in_double(soap, tag, &n, "xsd:double"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<double>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfdouble(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfdouble(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<double> *p;
	size_t k = sizeof(std::vector<double> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<double> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<double> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<double>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfdouble, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
