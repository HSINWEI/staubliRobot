/* soapStub.h
   Generated by gSOAP 2.8.52 for CS8Server.h

gSOAP XML Web services tools
Copyright (C) 2000-2017, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <vector>
#define SOAP_NAMESPACE_OF_ns1	"CS8ServerV0"
#define SOAP_NAMESPACE_OF_ns5	"http://tempuri.org/xmlmime.xsd"
#define SOAP_NAMESPACE_OF_ns7	"urn:CS8ServerV2"
#define SOAP_NAMESPACE_OF_ns3	"http://www.w3.org/2004/08/xop/include"
#define SOAP_NAMESPACE_OF_ns2	"urn:CS8ServerV1"
#define SOAP_NAMESPACE_OF_ns4	"http://www.w3.org/2004/11/xmlmime"

#ifndef soapStub_H
#define soapStub_H
#include "../stdsoap2.h"
#if GSOAP_VERSION != 20852
# error "GSOAP VERSION 20852 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumeration Types                                                          *
 *                                                                            *
\******************************************************************************/


/* CS8Server.h:687 */
#ifndef SOAP_TYPE_ns1__ServerExceptionCode
#define SOAP_TYPE_ns1__ServerExceptionCode (171)
/* ns1:ServerExceptionCode */
enum ns1__ServerExceptionCode {
	ns1__ServerExceptionCode__UNKNOWN_CODE = 0,
	ns1__ServerExceptionCode__INVALID_SESSION_ID_CODE = 1,
	ns1__ServerExceptionCode__INVALID_ROBOT_ID_CODE = 2,
	ns1__ServerExceptionCode__READ_ACCESS_ERROR_CODE = 3,
	ns1__ServerExceptionCode__WRITE_ACCESS_ERROR_CODE = 4,
	ns1__ServerExceptionCode__SET_POS_NOT_SIMUL_CODE = 5,
	ns1__ServerExceptionCode__SET_POS_POWER_ON_CODE = 6,
	ns1__ServerExceptionCode__FILE_NOT_FOUND_CODE = 7,
	ns1__ServerExceptionCode__INVALID_CONFIG_CODE = 8,
	ns1__ServerExceptionCode__INVALID_NUMBER_OF_AXIS_CODE = 9,
	ns1__ServerExceptionCode__INVALID_MOT_DESC_CODE = 10,
	ns1__ServerExceptionCode__CLIENT_ALREADY_CONNECTED = 11,
	ns1__ServerExceptionCode__CLIENT_COMMUNICATION_ERROR = 12,
	ns1__ServerExceptionCode__APPLICATION_NOT_FOUND = 13,
	ns1__ServerExceptionCode__PROGRAM_NOT_FOUND = 14,
	ns1__ServerExceptionCode__TASK_NOT_FOUND = 15,
	ns1__ServerExceptionCode__STACK_FRAME_NOT_FOUND = 16,
	ns1__ServerExceptionCode__TASK_ALREADY_LOCKED = 17,
	ns1__ServerExceptionCode__INVALID_SOAP_HANDLER = 18,
	ns1__ServerExceptionCode__INVALID_SOAP_HEADER = 19,
	ns1__ServerExceptionCode__PROGRAM_LINE_NOT_FOUND = 20,
	ns1__ServerExceptionCode__MISMATCHED_CODE = 21,
	ns1__ServerExceptionCode__IOWRITE_ACCESS_ERROR_CODE = 22,
	ns1__ServerExceptionCode__IOWRITE_ACCESS_ERROR_WORKING_MODE = 23,
	ns1__ServerExceptionCode__IOWRITE_ACCESS_ERROR_VALIDATION = 24,
	ns1__ServerExceptionCode__SCHEDULING_MODE_ERROR = 25,
	ns1__ServerExceptionCode__INVALID_PARAMETERS = 26
};
#endif

/* CS8Server.h:721 */
#ifndef SOAP_TYPE_ns1__Kinematic
#define SOAP_TYPE_ns1__Kinematic (172)
/* ns1:Kinematic */
enum ns1__Kinematic {
	ns1__Kinematic__KINEMATIC_INVALID = 0,
	ns1__Kinematic__KINEMATIC_ANTHROPOMORPH6 = 1,
	ns1__Kinematic__KINEMATIC_ANTHROPOMORPH5 = 2,
	ns1__Kinematic__KINEMATIC_SCARA = 3,
	ns1__Kinematic__KINEMATIC_EISENMANN = 4
};
#endif

/* CS8Server.h:733 */
#ifndef SOAP_TYPE_ns1__MountType
#define SOAP_TYPE_ns1__MountType (173)
/* ns1:MountType */
enum ns1__MountType {
	ns1__MountType__MOUNTTYPE_INVALID = 0,
	ns1__MountType__MOUNTTYPE_FLOOR = 1,
	ns1__MountType__MOUNTTYPE_CEILING = 2,
	ns1__MountType__MOUNTTYPE_WALL = 3
};
#endif

/* CS8Server.h:744 */
#ifndef SOAP_TYPE_ns1__LengthAxis3
#define SOAP_TYPE_ns1__LengthAxis3 (174)
/* ns1:LengthAxis3 */
enum ns1__LengthAxis3 {
	ns1__LengthAxis3__LENGTHAXIS3_INVALID = 0,
	ns1__LengthAxis3__LENGTHAXIS3_L100 = 1,
	ns1__LengthAxis3__LENGTHAXIS3_L200 = 2,
	ns1__LengthAxis3__LENGTHAXIS3_L400 = 3,
	ns1__LengthAxis3__LENGTHAXIS3_L600 = 4
};
#endif

/* CS8Server.h:756 */
#ifndef SOAP_TYPE_ns1__DiameterAxis3
#define SOAP_TYPE_ns1__DiameterAxis3 (175)
/* ns1:DiameterAxis3 */
enum ns1__DiameterAxis3 {
	ns1__DiameterAxis3__DIAMETERAXIS3_INVALID = 0,
	ns1__DiameterAxis3__DIAMETERAXIS3_D20 = 1,
	ns1__DiameterAxis3__DIAMETERAXIS3_D25 = 2
};
#endif

/* CS8Server.h:782 */
#ifndef SOAP_TYPE_ns7__SoapTaskState
#define SOAP_TYPE_ns7__SoapTaskState (176)
/* ns7:SoapTaskState */
enum ns7__SoapTaskState {
	ns7__SoapTaskState__TASKSTATE_IDLE = 0,
	ns7__SoapTaskState__TASKSTATE_TRANSITION = 1,
	ns7__SoapTaskState__TASKSTATE_RUNNING = 2,
	ns7__SoapTaskState__TASKSTATE_STEPPING = 3,
	ns7__SoapTaskState__TASKSTATE_STOPPED = 4
};
#endif

/* CS8Server.h:794 */
#ifndef SOAP_TYPE_ns7__SoapTaskStep
#define SOAP_TYPE_ns7__SoapTaskStep (177)
/* ns7:SoapTaskStep */
enum ns7__SoapTaskStep {
	ns7__SoapTaskStep__TASKSTEP_INTO = 0,
	ns7__SoapTaskStep__TASKSTEP_OVER = 1,
	ns7__SoapTaskStep__TASKSTEP_OUT = 2
};
#endif

/* CS8Server.h:804 */
#ifndef SOAP_TYPE_ns7__SoapPhysicalIoEnumState
#define SOAP_TYPE_ns7__SoapPhysicalIoEnumState (178)
/* ns7:SoapPhysicalIoEnumState */
enum ns7__SoapPhysicalIoEnumState {
	ns7__SoapPhysicalIoEnumState__IO_DEFINED = 0,
	ns7__SoapPhysicalIoEnumState__IO_UNDEFINED = 1,
	ns7__SoapPhysicalIoEnumState__IO_INVALID_NAME = 2
};
#endif

/* CS8Server.h:813 */
#ifndef SOAP_TYPE_ns7__execVal3ReturnCode
#define SOAP_TYPE_ns7__execVal3ReturnCode (179)
/* ns7:execVal3ReturnCode */
enum ns7__execVal3ReturnCode {
	ns7__execVal3ReturnCode__EXV_NO_ERROR = 0,
	ns7__execVal3ReturnCode__EXV_COMPILATION_ERROR = 1,
	ns7__execVal3ReturnCode__EXV_RUNTIME_ERROR = 2
};
#endif

/* CS8Server.h:822 */
#ifndef SOAP_TYPE_ns7__replaceLineReturnCode
#define SOAP_TYPE_ns7__replaceLineReturnCode (180)
/* ns7:replaceLineReturnCode */
enum ns7__replaceLineReturnCode {
	ns7__replaceLineReturnCode__RLI_NO_ERROR = 0,
	ns7__replaceLineReturnCode__RLI_PROGRAM_IN_EDITION = 1,
	ns7__replaceLineReturnCode__RLI_COMPILATION_ERROR = 2,
	ns7__replaceLineReturnCode__RLI_INSTRUCTION_BUSY = 3,
	ns7__replaceLineReturnCode__RLI_INSTRUCTION_CONTROL = 4,
	ns7__replaceLineReturnCode__RLI_UNKNOW_RET_CODE = 5
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class xsd__base64Binary;	/* CS8Server.h:152 */
class xsd__hexBinary;	/* CS8Server.h:160 */
class ns1__ServerException;	/* CS8Server.h:171 */
class ns1__JointPos;	/* CS8Server.h:174 */
class ns1__CartesianPos;	/* CS8Server.h:177 */
class ns1__Robot;	/* CS8Server.h:180 */
class ns1__Version;	/* CS8Server.h:183 */
class ns1__Parameter;	/* CS8Server.h:186 */
class ns1__Parameters;	/* CS8Server.h:189 */
class ns1__Versions;	/* CS8Server.h:192 */
class ns1__SoapServerVersion;	/* CS8Server.h:195 */
class ns1__Robots;	/* CS8Server.h:198 */
class _ns1__getSoapServerVersion;	/* CS8Server.h:201 */
class _ns1__getSoapServerVersionResponse;	/* CS8Server.h:204 */
class _ns1__findServer;	/* CS8Server.h:207 */
class _ns1__findServerResponse;	/* CS8Server.h:210 */
class _ns1__ping;	/* CS8Server.h:213 */
class _ns1__pingResponse;	/* CS8Server.h:216 */
class _ns1__getCS8Versions;	/* CS8Server.h:219 */
class _ns1__getCS8VersionsResponse;	/* CS8Server.h:222 */
class _ns1__getControllerParameters;	/* CS8Server.h:225 */
class _ns1__getControllerParametersResponse;	/* CS8Server.h:228 */
class _ns1__getCS8Compatibility;	/* CS8Server.h:231 */
class _ns1__getCS8CompatibilityResponse;	/* CS8Server.h:234 */
class _ns1__login;	/* CS8Server.h:237 */
class _ns1__loginResponse;	/* CS8Server.h:240 */
class _ns1__logout;	/* CS8Server.h:243 */
class _ns1__logoutResponse;	/* CS8Server.h:246 */
class _ns1__getRobots;	/* CS8Server.h:249 */
class _ns1__getRobotsResponse;	/* CS8Server.h:252 */
class _ns1__getRobotJointPos;	/* CS8Server.h:255 */
class _ns1__getRobotJointPosResponse;	/* CS8Server.h:258 */
class _ns1__getRobotJntCartPos;	/* CS8Server.h:261 */
class _ns1__getRobotJntCartPosResponse;	/* CS8Server.h:264 */
class _ns1__setRobotJointPos;	/* CS8Server.h:267 */
class _ns1__setRobotPosResponse;	/* CS8Server.h:270 */
class ns5__JointPos;	/* CS8Server.h:273 */
class ns5__Parameters;	/* CS8Server.h:276 */
class ns5__Versions;	/* CS8Server.h:279 */
class ns5__Robots;	/* CS8Server.h:282 */
class ns5__VALApplications;	/* CS8Server.h:285 */
class ns5__Records;	/* CS8Server.h:288 */
class ns5__SoapBreakpoints;	/* CS8Server.h:291 */
class ns5__BreakpointsResponses;	/* CS8Server.h:294 */
class ns5__SoapTasks;	/* CS8Server.h:297 */
class ns5__SoapCallStack;	/* CS8Server.h:300 */
class ns5__SoapWatches;	/* CS8Server.h:303 */
class ns5__SoapPhysicalIoLinks;	/* CS8Server.h:306 */
class ns5__SoapPhysicalIoValues;	/* CS8Server.h:309 */
class ns5__SoapPhysicalIosStates;	/* CS8Server.h:312 */
class ns5__SoapPhysicalIoResponses;	/* CS8Server.h:315 */
class ns5__SoapPhysicalIoUnlockResponses;	/* CS8Server.h:318 */
class ns5__SoapDhParametersArray;	/* CS8Server.h:321 */
class ns7__JointPos;	/* CS8Server.h:324 */
class ns7__Parameters;	/* CS8Server.h:327 */
class ns7__Versions;	/* CS8Server.h:330 */
class ns7__Robots;	/* CS8Server.h:333 */
class ns7__VALApplications;	/* CS8Server.h:336 */
class ns7__Records;	/* CS8Server.h:339 */
class ns7__SoapProgramLine;	/* CS8Server.h:342 */
class ns7__SoapBreakpoint;	/* CS8Server.h:345 */
class ns7__SoapBreakpoints;	/* CS8Server.h:348 */
class ns7__BreakpointsResponse;	/* CS8Server.h:351 */
class ns7__BreakpointsResponses;	/* CS8Server.h:354 */
class ns7__MimeData;	/* CS8Server.h:357 */
class ns7__SoapTask;	/* CS8Server.h:360 */
class ns7__SoapTasks;	/* CS8Server.h:363 */
class ns7__SoapInstruction;	/* CS8Server.h:366 */
class ns7__SoapStackFrameAbstract;	/* CS8Server.h:369 */
class ns7__SoapCallStack;	/* CS8Server.h:372 */
class ns7__SoapData;	/* CS8Server.h:375 */
class ns7__SoapWatches;	/* CS8Server.h:378 */
class ns7__SoapPhysicalIoLinks;	/* CS8Server.h:381 */
class ns7__SoapPhysicalDioAttrib;	/* CS8Server.h:384 */
class ns7__SoapPhysicalAioAttrib;	/* CS8Server.h:387 */
union _ns7__union_SoapPhysicalIoAttrib;	/* CS8Server.h:1692 */
class ns7__SoapPhysicalIoAttrib;	/* CS8Server.h:390 */
class ns7__SoapPhysicalIoState;	/* CS8Server.h:393 */
class ns7__SoapPhysicalIoValues;	/* CS8Server.h:396 */
class ns7__SoapPhysicalIosStates;	/* CS8Server.h:399 */
class ns7__SoapPhysicalIoResponse;	/* CS8Server.h:402 */
class ns7__SoapPhysicalIoResponses;	/* CS8Server.h:405 */
class ns7__SoapPhysicalIoUnlockResponse;	/* CS8Server.h:408 */
class ns7__SoapPhysicalIoUnlockResponses;	/* CS8Server.h:411 */
class ns7__SoapDhParameters;	/* CS8Server.h:414 */
class ns7__SoapDhParametersArray;	/* CS8Server.h:417 */
class _ns7__setBreakpoints;	/* CS8Server.h:420 */
class _ns7__setBreakpointsResponse;	/* CS8Server.h:423 */
class _ns7__getBreakpoints;	/* CS8Server.h:426 */
class _ns7__getBreakpointsResponse;	/* CS8Server.h:429 */
class _ns7__clearBreakpoints;	/* CS8Server.h:432 */
class _ns7__clearBreakpointsResponse;	/* CS8Server.h:435 */
class _ns7__clearAllBreakpoints;	/* CS8Server.h:438 */
class _ns7__clearAllBreakpointsResponse;	/* CS8Server.h:441 */
class _ns7__getTasks;	/* CS8Server.h:444 */
class _ns7__getTasksResponse;	/* CS8Server.h:447 */
class _ns7__taskSuspend;	/* CS8Server.h:450 */
class _ns7__taskSuspendResponse;	/* CS8Server.h:453 */
class _ns7__taskResume;	/* CS8Server.h:456 */
class _ns7__taskResumeResponse;	/* CS8Server.h:459 */
class _ns7__taskKill;	/* CS8Server.h:462 */
class _ns7__taskKillResponse;	/* CS8Server.h:465 */
class _ns7__taskStep;	/* CS8Server.h:468 */
class _ns7__taskStepResponse;	/* CS8Server.h:471 */
class _ns7__subscribeToControllerEvents;	/* CS8Server.h:474 */
class _ns7__subscribeResponse;	/* CS8Server.h:477 */
class _ns7__unsubscribeToControllerEvents;	/* CS8Server.h:480 */
class _ns7__unsubscribeResponse;	/* CS8Server.h:483 */
class _ns7__getCallStack;	/* CS8Server.h:486 */
class _ns7__getCallStackResponse;	/* CS8Server.h:489 */
class _ns7__getStackFrame;	/* CS8Server.h:492 */
class _ns7__getStackFrameResponse;	/* CS8Server.h:495 */
class _ns7__getWatches;	/* CS8Server.h:498 */
class _ns7__getWatchResponse;	/* CS8Server.h:501 */
class _ns7__execVal3;	/* CS8Server.h:504 */
class _ns7__execVal3Response;	/* CS8Server.h:507 */
class _ns7__setProjectAsModified;	/* CS8Server.h:510 */
class _ns7__setProjectAsModifiedResponse;	/* CS8Server.h:513 */
class _ns7__setCurrentInstruction;	/* CS8Server.h:516 */
class _ns7__setCurrentInstructionResponse;	/* CS8Server.h:519 */
class _ns7__replaceLine;	/* CS8Server.h:522 */
class _ns7__replaceLineResponse;	/* CS8Server.h:525 */
class _ns7__readIos;	/* CS8Server.h:528 */
class _ns7__readIosResponse;	/* CS8Server.h:531 */
class _ns7__writeIos;	/* CS8Server.h:534 */
class _ns7__writeIosResponse;	/* CS8Server.h:537 */
class _ns7__lockIos;	/* CS8Server.h:540 */
class _ns7__lockIosResponse;	/* CS8Server.h:543 */
class _ns7__unlockIos;	/* CS8Server.h:546 */
class _ns7__unlockIosResponse;	/* CS8Server.h:549 */
class _ns7__lockAllIos;	/* CS8Server.h:552 */
class _ns7__SoapAllPhysicalIoResponse;	/* CS8Server.h:555 */
class _ns7__unlockAllIos;	/* CS8Server.h:558 */
class _ns7__getAllPhysicalIos;	/* CS8Server.h:561 */
class _ns7__getAllPhysicalIosResponse;	/* CS8Server.h:564 */
class _ns7__getRobotDhParameters;	/* CS8Server.h:567 */
class _ns7__SoapRobotDhParameters;	/* CS8Server.h:570 */
class _ns7__getProject;	/* CS8Server.h:573 */
class _ns7__getProjectResponse;	/* CS8Server.h:576 */
class ns3__Include;	/* CS8Server.h:579 */
class ns2__VALApplication;	/* CS8Server.h:582 */
class ns2__VALApplications;	/* CS8Server.h:585 */
class ns2__Data;	/* CS8Server.h:588 */
class ns2__Records;	/* CS8Server.h:591 */
class ns2__JointRange;	/* CS8Server.h:594 */
class _ns2__getApplications;	/* CS8Server.h:597 */
class _ns2__getApplicationsResponse;	/* CS8Server.h:600 */
class _ns2__getApplicationDatas;	/* CS8Server.h:603 */
class _ns2__getApplicationDatasResponse;	/* CS8Server.h:606 */
class _ns2__getRecords;	/* CS8Server.h:609 */
class _ns2__getRecordsResponse;	/* CS8Server.h:612 */
class _ns2__getRecord;	/* CS8Server.h:615 */
class _ns2__getRecordResponse;	/* CS8Server.h:618 */
class _ns2__getJointRange;	/* CS8Server.h:621 */
class _ns2__getJointRangeResponse;	/* CS8Server.h:624 */
class ns4__base64Binary;	/* CS8Server.h:627 */
class ns4__hexBinary;	/* CS8Server.h:630 */
struct __ns1__getSoapServerVersion;	/* CS8Server.h:3039 */
struct __ns1__findServer;	/* CS8Server.h:3104 */
struct __ns1__ping;	/* CS8Server.h:3169 */
struct __ns1__getCS8Versions;	/* CS8Server.h:3237 */
struct __ns1__getControllerParameters;	/* CS8Server.h:3305 */
struct __ns1__getCS8Compatibility;	/* CS8Server.h:3373 */
struct __ns1__login;	/* CS8Server.h:3441 */
struct __ns1__logout;	/* CS8Server.h:3509 */
struct __ns1__getRobots;	/* CS8Server.h:3577 */
struct __ns1__getRobotJointPos;	/* CS8Server.h:3645 */
struct __ns1__getRobotJntCartPos;	/* CS8Server.h:3713 */
struct __ns1__setRobotJointPos;	/* CS8Server.h:3781 */
struct __ns7__setBreakpoints;	/* CS8Server.h:3856 */
struct __ns7__getBreakpoints;	/* CS8Server.h:3923 */
struct __ns7__clearBreakpoints;	/* CS8Server.h:3990 */
struct __ns7__clearAllBreakpoints;	/* CS8Server.h:4057 */
struct __ns7__getTasks;	/* CS8Server.h:4124 */
struct __ns7__taskSuspend;	/* CS8Server.h:4191 */
struct __ns7__taskResume;	/* CS8Server.h:4258 */
struct __ns7__taskKill;	/* CS8Server.h:4325 */
struct __ns7__taskStep;	/* CS8Server.h:4392 */
struct __ns7__subscribeToControllerEvents;	/* CS8Server.h:4459 */
struct __ns7__unsubscribeToControllerEvents;	/* CS8Server.h:4526 */
struct __ns7__getCallStack;	/* CS8Server.h:4593 */
struct __ns7__getStackFrame;	/* CS8Server.h:4660 */
struct __ns7__getWatches;	/* CS8Server.h:4727 */
struct __ns7__execVal3;	/* CS8Server.h:4794 */
struct __ns7__setProjectAsModified;	/* CS8Server.h:4861 */
struct __ns7__setCurrentInstruction;	/* CS8Server.h:4928 */
struct __ns7__replaceLine;	/* CS8Server.h:4995 */
struct __ns7__readIos;	/* CS8Server.h:5062 */
struct __ns7__writeIos;	/* CS8Server.h:5129 */
struct __ns7__lockIos;	/* CS8Server.h:5196 */
struct __ns7__unlockIos;	/* CS8Server.h:5263 */
struct __ns7__lockAllIos;	/* CS8Server.h:5330 */
struct __ns7__unlockAllIos;	/* CS8Server.h:5397 */
struct __ns7__getAllPhysicalIos;	/* CS8Server.h:5464 */
struct __ns7__getRobotDhParameters;	/* CS8Server.h:5531 */
struct __ns7__getProject;	/* CS8Server.h:5598 */

/* CS8Server.h:152 */
#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (10)
/* binary data attached as MTOM/MIME/DIME attachment or included as *`xsd:base64Binary`* base64: */
class SOAP_CMAC xsd__base64Binary {
      public:
        unsigned char *__ptr;
        int __size;
        /// Optional element 'id' of XSD type 'xsd:string'
        char *id;
        /// Optional element 'type' of XSD type 'xsd:string'
        char *type;
        /// Optional element 'options' of XSD type 'xsd:string'
        char *options;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_xsd__base64Binary
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__base64Binary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__base64Binary, default initialized and not managed by a soap context
        virtual xsd__base64Binary *soap_alloc(void) const { return SOAP_NEW(xsd__base64Binary); }
      public:
        /// Constructor with initializations
        xsd__base64Binary() : __ptr(), __size(), id(), type(), options(), soap() { }
        virtual ~xsd__base64Binary() { }
        /// Friend allocator used by soap_new_xsd__base64Binary(struct soap*, int)
        friend SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 soap_instantiate_xsd__base64Binary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:160 */
#ifndef SOAP_TYPE_xsd__hexBinary
#define SOAP_TYPE_xsd__hexBinary (15)
/* hexBinary XSD type: */
class SOAP_CMAC xsd__hexBinary {
      public:
        unsigned char *__ptr;
        int __size;
      public:
        /// Return unique type id SOAP_TYPE_xsd__hexBinary
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__hexBinary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__hexBinary, default initialized and not managed by a soap context
        virtual xsd__hexBinary *soap_alloc(void) const { return SOAP_NEW(xsd__hexBinary); }
      public:
        /// Constructor with initializations
        xsd__hexBinary() : __ptr(), __size() { }
        virtual ~xsd__hexBinary() { }
        /// Friend allocator used by soap_new_xsd__hexBinary(struct soap*, int)
        friend SOAP_FMAC1 xsd__hexBinary * SOAP_FMAC2 soap_instantiate_xsd__hexBinary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:171 */
#ifndef SOAP_TYPE_ns1__ServerException
#define SOAP_TYPE_ns1__ServerException (16)
/* complex XSD type 'ns1:ServerException': */
class SOAP_CMAC ns1__ServerException {
      public:
        /// Required element 'code' of XSD type 'ns1:ServerExceptionCode'
        enum ns1__ServerExceptionCode code;
        /// Optional element 'description' of XSD type 'xsd:string'
        std::string *description;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ServerException
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__ServerException; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ServerException, default initialized and not managed by a soap context
        virtual ns1__ServerException *soap_alloc(void) const { return SOAP_NEW(ns1__ServerException); }
      public:
        /// Constructor with initializations
        ns1__ServerException() : code(), description(), soap() { }
        virtual ~ns1__ServerException() { }
        /// Friend allocator used by soap_new_ns1__ServerException(struct soap*, int)
        friend SOAP_FMAC1 ns1__ServerException * SOAP_FMAC2 soap_instantiate_ns1__ServerException(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:174 */
#ifndef SOAP_TYPE_ns1__JointPos
#define SOAP_TYPE_ns1__JointPos (17)
/* complex XSD type 'ns1:JointPos': */
class SOAP_CMAC ns1__JointPos {
      public:
        /// Sequence of 1 to 100 elements 'item' of XSD type 'xsd:double'
        std::vector<double> item;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__JointPos
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__JointPos; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__JointPos, default initialized and not managed by a soap context
        virtual ns1__JointPos *soap_alloc(void) const { return SOAP_NEW(ns1__JointPos); }
      public:
        /// Constructor with initializations
        ns1__JointPos() : item(), soap() { }
        virtual ~ns1__JointPos() { }
        /// Friend allocator used by soap_new_ns1__JointPos(struct soap*, int)
        friend SOAP_FMAC1 ns1__JointPos * SOAP_FMAC2 soap_instantiate_ns1__JointPos(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:177 */
#ifndef SOAP_TYPE_ns1__CartesianPos
#define SOAP_TYPE_ns1__CartesianPos (18)
/* complex XSD type 'ns1:CartesianPos': */
class SOAP_CMAC ns1__CartesianPos {
      public:
        /// Required element 'x' of XSD type 'xsd:double'
        double x;
        /// Required element 'y' of XSD type 'xsd:double'
        double y;
        /// Required element 'z' of XSD type 'xsd:double'
        double z;
        /// Required element 'rx' of XSD type 'xsd:double'
        double rx;
        /// Required element 'ry' of XSD type 'xsd:double'
        double ry;
        /// Required element 'rz' of XSD type 'xsd:double'
        double rz;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__CartesianPos
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__CartesianPos; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CartesianPos, default initialized and not managed by a soap context
        virtual ns1__CartesianPos *soap_alloc(void) const { return SOAP_NEW(ns1__CartesianPos); }
      public:
        /// Constructor with initializations
        ns1__CartesianPos() : x(), y(), z(), rx(), ry(), rz(), soap() { }
        virtual ~ns1__CartesianPos() { }
        /// Friend allocator used by soap_new_ns1__CartesianPos(struct soap*, int)
        friend SOAP_FMAC1 ns1__CartesianPos * SOAP_FMAC2 soap_instantiate_ns1__CartesianPos(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:180 */
#ifndef SOAP_TYPE_ns1__Robot
#define SOAP_TYPE_ns1__Robot (19)
/* complex XSD type 'ns1:Robot': */
class SOAP_CMAC ns1__Robot {
      public:
        /// Required element 'kinematic' of XSD type 'ns1:Kinematic'
        enum ns1__Kinematic kinematic;
        /// Optional element 'arm' of XSD type 'xsd:string'
        std::string *arm;
        /// Optional element 'tuning' of XSD type 'xsd:string'
        std::string *tuning;
        /// Required element 'mountType' of XSD type 'ns1:MountType'
        enum ns1__MountType mountType;
        /// Required element 'lengthAxis3' of XSD type 'ns1:LengthAxis3'
        enum ns1__LengthAxis3 lengthAxis3;
        /// Required element 'diameterAxis3' of XSD type 'ns1:DiameterAxis3'
        enum ns1__DiameterAxis3 diameterAxis3;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__Robot
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__Robot; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__Robot, default initialized and not managed by a soap context
        virtual ns1__Robot *soap_alloc(void) const { return SOAP_NEW(ns1__Robot); }
      public:
        /// Constructor with initializations
        ns1__Robot() : kinematic(), arm(), tuning(), mountType(), lengthAxis3(), diameterAxis3(), soap() { }
        virtual ~ns1__Robot() { }
        /// Friend allocator used by soap_new_ns1__Robot(struct soap*, int)
        friend SOAP_FMAC1 ns1__Robot * SOAP_FMAC2 soap_instantiate_ns1__Robot(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:183 */
#ifndef SOAP_TYPE_ns1__Version
#define SOAP_TYPE_ns1__Version (20)
/* complex XSD type 'ns1:Version': */
class SOAP_CMAC ns1__Version {
      public:
        /// Optional element 'name' of XSD type 'xsd:string'
        std::string *name;
        /// Optional element 'version' of XSD type 'xsd:string'
        std::string *version;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__Version
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__Version; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__Version, default initialized and not managed by a soap context
        virtual ns1__Version *soap_alloc(void) const { return SOAP_NEW(ns1__Version); }
      public:
        /// Constructor with initializations
        ns1__Version() : name(), version(), soap() { }
        virtual ~ns1__Version() { }
        /// Friend allocator used by soap_new_ns1__Version(struct soap*, int)
        friend SOAP_FMAC1 ns1__Version * SOAP_FMAC2 soap_instantiate_ns1__Version(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:186 */
#ifndef SOAP_TYPE_ns1__Parameter
#define SOAP_TYPE_ns1__Parameter (21)
/* complex XSD type 'ns1:Parameter': */
class SOAP_CMAC ns1__Parameter {
      public:
        /// Optional element 'key' of XSD type 'xsd:string'
        std::string *key;
        /// Optional element 'name' of XSD type 'xsd:string'
        std::string *name;
        /// Optional element 'value' of XSD type 'xsd:string'
        std::string *value;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__Parameter
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__Parameter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__Parameter, default initialized and not managed by a soap context
        virtual ns1__Parameter *soap_alloc(void) const { return SOAP_NEW(ns1__Parameter); }
      public:
        /// Constructor with initializations
        ns1__Parameter() : key(), name(), value(), soap() { }
        virtual ~ns1__Parameter() { }
        /// Friend allocator used by soap_new_ns1__Parameter(struct soap*, int)
        friend SOAP_FMAC1 ns1__Parameter * SOAP_FMAC2 soap_instantiate_ns1__Parameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:189 */
#ifndef SOAP_TYPE_ns1__Parameters
#define SOAP_TYPE_ns1__Parameters (22)
/* complex XSD type 'ns1:Parameters': */
class SOAP_CMAC ns1__Parameters {
      public:
        /// Optional element 'Parameters' of XSD type 'ns1:Parameter'
        std::vector<ns1__Parameter *> Parameters;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__Parameters
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__Parameters; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__Parameters, default initialized and not managed by a soap context
        virtual ns1__Parameters *soap_alloc(void) const { return SOAP_NEW(ns1__Parameters); }
      public:
        /// Constructor with initializations
        ns1__Parameters() : Parameters(), soap() { }
        virtual ~ns1__Parameters() { }
        /// Friend allocator used by soap_new_ns1__Parameters(struct soap*, int)
        friend SOAP_FMAC1 ns1__Parameters * SOAP_FMAC2 soap_instantiate_ns1__Parameters(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:192 */
#ifndef SOAP_TYPE_ns1__Versions
#define SOAP_TYPE_ns1__Versions (23)
/* complex XSD type 'ns1:Versions': */
class SOAP_CMAC ns1__Versions {
      public:
        /// Optional element 'Versions' of XSD type 'ns1:Version'
        std::vector<ns1__Version *> Versions;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__Versions
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__Versions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__Versions, default initialized and not managed by a soap context
        virtual ns1__Versions *soap_alloc(void) const { return SOAP_NEW(ns1__Versions); }
      public:
        /// Constructor with initializations
        ns1__Versions() : Versions(), soap() { }
        virtual ~ns1__Versions() { }
        /// Friend allocator used by soap_new_ns1__Versions(struct soap*, int)
        friend SOAP_FMAC1 ns1__Versions * SOAP_FMAC2 soap_instantiate_ns1__Versions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:195 */
#ifndef SOAP_TYPE_ns1__SoapServerVersion
#define SOAP_TYPE_ns1__SoapServerVersion (24)
/* complex XSD type 'ns1:SoapServerVersion': */
class SOAP_CMAC ns1__SoapServerVersion {
      public:
        /// Optional element 'version' of XSD type 'xsd:string'
        std::string *version;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SoapServerVersion
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SoapServerVersion; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SoapServerVersion, default initialized and not managed by a soap context
        virtual ns1__SoapServerVersion *soap_alloc(void) const { return SOAP_NEW(ns1__SoapServerVersion); }
      public:
        /// Constructor with initializations
        ns1__SoapServerVersion() : version(), soap() { }
        virtual ~ns1__SoapServerVersion() { }
        /// Friend allocator used by soap_new_ns1__SoapServerVersion(struct soap*, int)
        friend SOAP_FMAC1 ns1__SoapServerVersion * SOAP_FMAC2 soap_instantiate_ns1__SoapServerVersion(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:198 */
#ifndef SOAP_TYPE_ns1__Robots
#define SOAP_TYPE_ns1__Robots (25)
/* complex XSD type 'ns1:Robots': */
class SOAP_CMAC ns1__Robots {
      public:
        /// Optional element 'Robots' of XSD type 'ns1:Robot'
        std::vector<ns1__Robot *> Robots;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__Robots
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__Robots; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__Robots, default initialized and not managed by a soap context
        virtual ns1__Robots *soap_alloc(void) const { return SOAP_NEW(ns1__Robots); }
      public:
        /// Constructor with initializations
        ns1__Robots() : Robots(), soap() { }
        virtual ~ns1__Robots() { }
        /// Friend allocator used by soap_new_ns1__Robots(struct soap*, int)
        friend SOAP_FMAC1 ns1__Robots * SOAP_FMAC2 soap_instantiate_ns1__Robots(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:201 */
#ifndef SOAP_TYPE__ns1__getSoapServerVersion
#define SOAP_TYPE__ns1__getSoapServerVersion (26)
/* complex XSD type 'ns1:getSoapServerVersion': */
class SOAP_CMAC _ns1__getSoapServerVersion {
      public:
        /// Optional element 'cltName' of XSD type 'xsd:string'
        std::string *cltName;
        /// Optional element 'cltVersion' of XSD type 'xsd:string'
        std::string *cltVersion;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getSoapServerVersion
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__getSoapServerVersion; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getSoapServerVersion, default initialized and not managed by a soap context
        virtual _ns1__getSoapServerVersion *soap_alloc(void) const { return SOAP_NEW(_ns1__getSoapServerVersion); }
      public:
        /// Constructor with initializations
        _ns1__getSoapServerVersion() : cltName(), cltVersion(), soap() { }
        virtual ~_ns1__getSoapServerVersion() { }
        /// Friend allocator used by soap_new__ns1__getSoapServerVersion(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getSoapServerVersion * SOAP_FMAC2 soap_instantiate__ns1__getSoapServerVersion(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:204 */
#ifndef SOAP_TYPE__ns1__getSoapServerVersionResponse
#define SOAP_TYPE__ns1__getSoapServerVersionResponse (27)
/* complex XSD type 'ns1:getSoapServerVersionResponse': */
class SOAP_CMAC _ns1__getSoapServerVersionResponse {
      public:
        /// Required element 'server' of XSD type 'ns1:SoapServerVersion'
        ns1__SoapServerVersion *server;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getSoapServerVersionResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__getSoapServerVersionResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getSoapServerVersionResponse, default initialized and not managed by a soap context
        virtual _ns1__getSoapServerVersionResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__getSoapServerVersionResponse); }
      public:
        /// Constructor with initializations
        _ns1__getSoapServerVersionResponse() : server(), soap() { }
        virtual ~_ns1__getSoapServerVersionResponse() { }
        /// Friend allocator used by soap_new__ns1__getSoapServerVersionResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getSoapServerVersionResponse * SOAP_FMAC2 soap_instantiate__ns1__getSoapServerVersionResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:207 */
#ifndef SOAP_TYPE__ns1__findServer
#define SOAP_TYPE__ns1__findServer (28)
/* complex XSD type 'ns1:findServer': */
class SOAP_CMAC _ns1__findServer {
      public:
        /// Optional element 'serverName' of XSD type 'xsd:string'
        std::string *serverName;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__findServer
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__findServer; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__findServer, default initialized and not managed by a soap context
        virtual _ns1__findServer *soap_alloc(void) const { return SOAP_NEW(_ns1__findServer); }
      public:
        /// Constructor with initializations
        _ns1__findServer() : serverName(), soap() { }
        virtual ~_ns1__findServer() { }
        /// Friend allocator used by soap_new__ns1__findServer(struct soap*, int)
        friend SOAP_FMAC1 _ns1__findServer * SOAP_FMAC2 soap_instantiate__ns1__findServer(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:210 */
#ifndef SOAP_TYPE__ns1__findServerResponse
#define SOAP_TYPE__ns1__findServerResponse (29)
/* complex XSD type 'ns1:findServerResponse': */
class SOAP_CMAC _ns1__findServerResponse {
      public:
        /// Required element 'found' of XSD type 'xsd:boolean'
        bool found;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__findServerResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__findServerResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__findServerResponse, default initialized and not managed by a soap context
        virtual _ns1__findServerResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__findServerResponse); }
      public:
        /// Constructor with initializations
        _ns1__findServerResponse() : found(), soap() { }
        virtual ~_ns1__findServerResponse() { }
        /// Friend allocator used by soap_new__ns1__findServerResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__findServerResponse * SOAP_FMAC2 soap_instantiate__ns1__findServerResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:213 */
#ifndef SOAP_TYPE__ns1__ping
#define SOAP_TYPE__ns1__ping (30)
/* complex XSD type 'ns1:ping': */
class SOAP_CMAC _ns1__ping {
      public:
        /// Optional element 'message' of XSD type 'xsd:string'
        std::string *message;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ping
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__ping; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ping, default initialized and not managed by a soap context
        virtual _ns1__ping *soap_alloc(void) const { return SOAP_NEW(_ns1__ping); }
      public:
        /// Constructor with initializations
        _ns1__ping() : message(), soap() { }
        virtual ~_ns1__ping() { }
        /// Friend allocator used by soap_new__ns1__ping(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ping * SOAP_FMAC2 soap_instantiate__ns1__ping(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:216 */
#ifndef SOAP_TYPE__ns1__pingResponse
#define SOAP_TYPE__ns1__pingResponse (31)
/* complex XSD type 'ns1:pingResponse': */
class SOAP_CMAC _ns1__pingResponse {
      public:
        /// Optional element 'message' of XSD type 'xsd:string'
        std::string *message;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__pingResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__pingResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__pingResponse, default initialized and not managed by a soap context
        virtual _ns1__pingResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__pingResponse); }
      public:
        /// Constructor with initializations
        _ns1__pingResponse() : message(), soap() { }
        virtual ~_ns1__pingResponse() { }
        /// Friend allocator used by soap_new__ns1__pingResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__pingResponse * SOAP_FMAC2 soap_instantiate__ns1__pingResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:219 */
#ifndef SOAP_TYPE__ns1__getCS8Versions
#define SOAP_TYPE__ns1__getCS8Versions (32)
/* complex XSD type 'ns1:getCS8Versions': */
class SOAP_CMAC _ns1__getCS8Versions {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getCS8Versions
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__getCS8Versions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getCS8Versions, default initialized and not managed by a soap context
        virtual _ns1__getCS8Versions *soap_alloc(void) const { return SOAP_NEW(_ns1__getCS8Versions); }
      public:
        /// Constructor with initializations
        _ns1__getCS8Versions() : soap() { }
        virtual ~_ns1__getCS8Versions() { }
        /// Friend allocator used by soap_new__ns1__getCS8Versions(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getCS8Versions * SOAP_FMAC2 soap_instantiate__ns1__getCS8Versions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:222 */
#ifndef SOAP_TYPE__ns1__getCS8VersionsResponse
#define SOAP_TYPE__ns1__getCS8VersionsResponse (33)
/* complex XSD type 'ns1:getCS8VersionsResponse': */
class SOAP_CMAC _ns1__getCS8VersionsResponse {
      public:
        /// Required element 'out' of XSD type 'ns1:Versions'
        ns1__Versions *out;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getCS8VersionsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__getCS8VersionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getCS8VersionsResponse, default initialized and not managed by a soap context
        virtual _ns1__getCS8VersionsResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__getCS8VersionsResponse); }
      public:
        /// Constructor with initializations
        _ns1__getCS8VersionsResponse() : out(), soap() { }
        virtual ~_ns1__getCS8VersionsResponse() { }
        /// Friend allocator used by soap_new__ns1__getCS8VersionsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getCS8VersionsResponse * SOAP_FMAC2 soap_instantiate__ns1__getCS8VersionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:225 */
#ifndef SOAP_TYPE__ns1__getControllerParameters
#define SOAP_TYPE__ns1__getControllerParameters (34)
/* complex XSD type 'ns1:getControllerParameters': */
class SOAP_CMAC _ns1__getControllerParameters {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getControllerParameters
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__getControllerParameters; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getControllerParameters, default initialized and not managed by a soap context
        virtual _ns1__getControllerParameters *soap_alloc(void) const { return SOAP_NEW(_ns1__getControllerParameters); }
      public:
        /// Constructor with initializations
        _ns1__getControllerParameters() : soap() { }
        virtual ~_ns1__getControllerParameters() { }
        /// Friend allocator used by soap_new__ns1__getControllerParameters(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getControllerParameters * SOAP_FMAC2 soap_instantiate__ns1__getControllerParameters(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:228 */
#ifndef SOAP_TYPE__ns1__getControllerParametersResponse
#define SOAP_TYPE__ns1__getControllerParametersResponse (35)
/* complex XSD type 'ns1:getControllerParametersResponse': */
class SOAP_CMAC _ns1__getControllerParametersResponse {
      public:
        /// Required element 'out' of XSD type 'ns1:Parameters'
        ns1__Parameters *out;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getControllerParametersResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__getControllerParametersResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getControllerParametersResponse, default initialized and not managed by a soap context
        virtual _ns1__getControllerParametersResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__getControllerParametersResponse); }
      public:
        /// Constructor with initializations
        _ns1__getControllerParametersResponse() : out(), soap() { }
        virtual ~_ns1__getControllerParametersResponse() { }
        /// Friend allocator used by soap_new__ns1__getControllerParametersResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getControllerParametersResponse * SOAP_FMAC2 soap_instantiate__ns1__getControllerParametersResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:231 */
#ifndef SOAP_TYPE__ns1__getCS8Compatibility
#define SOAP_TYPE__ns1__getCS8Compatibility (36)
/* complex XSD type 'ns1:getCS8Compatibility': */
class SOAP_CMAC _ns1__getCS8Compatibility {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getCS8Compatibility
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__getCS8Compatibility; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getCS8Compatibility, default initialized and not managed by a soap context
        virtual _ns1__getCS8Compatibility *soap_alloc(void) const { return SOAP_NEW(_ns1__getCS8Compatibility); }
      public:
        /// Constructor with initializations
        _ns1__getCS8Compatibility() : soap() { }
        virtual ~_ns1__getCS8Compatibility() { }
        /// Friend allocator used by soap_new__ns1__getCS8Compatibility(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getCS8Compatibility * SOAP_FMAC2 soap_instantiate__ns1__getCS8Compatibility(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:234 */
#ifndef SOAP_TYPE__ns1__getCS8CompatibilityResponse
#define SOAP_TYPE__ns1__getCS8CompatibilityResponse (37)
/* complex XSD type 'ns1:getCS8CompatibilityResponse': */
class SOAP_CMAC _ns1__getCS8CompatibilityResponse {
      public:
        /// Optional element 'compatibility' of XSD type 'xsd:string'
        std::string *compatibility;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getCS8CompatibilityResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__getCS8CompatibilityResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getCS8CompatibilityResponse, default initialized and not managed by a soap context
        virtual _ns1__getCS8CompatibilityResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__getCS8CompatibilityResponse); }
      public:
        /// Constructor with initializations
        _ns1__getCS8CompatibilityResponse() : compatibility(), soap() { }
        virtual ~_ns1__getCS8CompatibilityResponse() { }
        /// Friend allocator used by soap_new__ns1__getCS8CompatibilityResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getCS8CompatibilityResponse * SOAP_FMAC2 soap_instantiate__ns1__getCS8CompatibilityResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:237 */
#ifndef SOAP_TYPE__ns1__login
#define SOAP_TYPE__ns1__login (38)
/* complex XSD type 'ns1:login': */
class SOAP_CMAC _ns1__login {
      public:
        /// Optional element 'user' of XSD type 'xsd:string'
        std::string *user;
        /// Optional element 'pwd' of XSD type 'xsd:string'
        std::string *pwd;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__login
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__login; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__login, default initialized and not managed by a soap context
        virtual _ns1__login *soap_alloc(void) const { return SOAP_NEW(_ns1__login); }
      public:
        /// Constructor with initializations
        _ns1__login() : user(), pwd(), soap() { }
        virtual ~_ns1__login() { }
        /// Friend allocator used by soap_new__ns1__login(struct soap*, int)
        friend SOAP_FMAC1 _ns1__login * SOAP_FMAC2 soap_instantiate__ns1__login(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:240 */
#ifndef SOAP_TYPE__ns1__loginResponse
#define SOAP_TYPE__ns1__loginResponse (39)
/* complex XSD type 'ns1:loginResponse': */
class SOAP_CMAC _ns1__loginResponse {
      public:
        /// Required element 'sid' of XSD type 'ns1:SessionId'
        int sid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__loginResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__loginResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__loginResponse, default initialized and not managed by a soap context
        virtual _ns1__loginResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__loginResponse); }
      public:
        /// Constructor with initializations
        _ns1__loginResponse() : sid(), soap() { }
        virtual ~_ns1__loginResponse() { }
        /// Friend allocator used by soap_new__ns1__loginResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__loginResponse * SOAP_FMAC2 soap_instantiate__ns1__loginResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:243 */
#ifndef SOAP_TYPE__ns1__logout
#define SOAP_TYPE__ns1__logout (40)
/* complex XSD type 'ns1:logout': */
class SOAP_CMAC _ns1__logout {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__logout
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__logout; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__logout, default initialized and not managed by a soap context
        virtual _ns1__logout *soap_alloc(void) const { return SOAP_NEW(_ns1__logout); }
      public:
        /// Constructor with initializations
        _ns1__logout() : soap() { }
        virtual ~_ns1__logout() { }
        /// Friend allocator used by soap_new__ns1__logout(struct soap*, int)
        friend SOAP_FMAC1 _ns1__logout * SOAP_FMAC2 soap_instantiate__ns1__logout(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:246 */
#ifndef SOAP_TYPE__ns1__logoutResponse
#define SOAP_TYPE__ns1__logoutResponse (41)
/* complex XSD type 'ns1:logoutResponse': */
class SOAP_CMAC _ns1__logoutResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__logoutResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__logoutResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__logoutResponse, default initialized and not managed by a soap context
        virtual _ns1__logoutResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__logoutResponse); }
      public:
        /// Constructor with initializations
        _ns1__logoutResponse() : soap() { }
        virtual ~_ns1__logoutResponse() { }
        /// Friend allocator used by soap_new__ns1__logoutResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__logoutResponse * SOAP_FMAC2 soap_instantiate__ns1__logoutResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:249 */
#ifndef SOAP_TYPE__ns1__getRobots
#define SOAP_TYPE__ns1__getRobots (42)
/* complex XSD type 'ns1:getRobots': */
class SOAP_CMAC _ns1__getRobots {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getRobots
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__getRobots; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getRobots, default initialized and not managed by a soap context
        virtual _ns1__getRobots *soap_alloc(void) const { return SOAP_NEW(_ns1__getRobots); }
      public:
        /// Constructor with initializations
        _ns1__getRobots() : soap() { }
        virtual ~_ns1__getRobots() { }
        /// Friend allocator used by soap_new__ns1__getRobots(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getRobots * SOAP_FMAC2 soap_instantiate__ns1__getRobots(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:252 */
#ifndef SOAP_TYPE__ns1__getRobotsResponse
#define SOAP_TYPE__ns1__getRobotsResponse (43)
/* complex XSD type 'ns1:getRobotsResponse': */
class SOAP_CMAC _ns1__getRobotsResponse {
      public:
        /// Required element 'out' of XSD type 'ns1:Robots'
        ns1__Robots *out;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getRobotsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__getRobotsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getRobotsResponse, default initialized and not managed by a soap context
        virtual _ns1__getRobotsResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__getRobotsResponse); }
      public:
        /// Constructor with initializations
        _ns1__getRobotsResponse() : out(), soap() { }
        virtual ~_ns1__getRobotsResponse() { }
        /// Friend allocator used by soap_new__ns1__getRobotsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getRobotsResponse * SOAP_FMAC2 soap_instantiate__ns1__getRobotsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:255 */
#ifndef SOAP_TYPE__ns1__getRobotJointPos
#define SOAP_TYPE__ns1__getRobotJointPos (44)
/* complex XSD type 'ns1:getRobotJointPos': */
class SOAP_CMAC _ns1__getRobotJointPos {
      public:
        /// Required element 'robot' of XSD type 'xsd:int'
        int robot;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getRobotJointPos
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__getRobotJointPos; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getRobotJointPos, default initialized and not managed by a soap context
        virtual _ns1__getRobotJointPos *soap_alloc(void) const { return SOAP_NEW(_ns1__getRobotJointPos); }
      public:
        /// Constructor with initializations
        _ns1__getRobotJointPos() : robot(), soap() { }
        virtual ~_ns1__getRobotJointPos() { }
        /// Friend allocator used by soap_new__ns1__getRobotJointPos(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getRobotJointPos * SOAP_FMAC2 soap_instantiate__ns1__getRobotJointPos(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:258 */
#ifndef SOAP_TYPE__ns1__getRobotJointPosResponse
#define SOAP_TYPE__ns1__getRobotJointPosResponse (45)
/* complex XSD type 'ns1:getRobotJointPosResponse': */
class SOAP_CMAC _ns1__getRobotJointPosResponse {
      public:
        /// Required element 'pos' of XSD type 'ns1:JointPos'
        ns1__JointPos *pos;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getRobotJointPosResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__getRobotJointPosResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getRobotJointPosResponse, default initialized and not managed by a soap context
        virtual _ns1__getRobotJointPosResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__getRobotJointPosResponse); }
      public:
        /// Constructor with initializations
        _ns1__getRobotJointPosResponse() : pos(), soap() { }
        virtual ~_ns1__getRobotJointPosResponse() { }
        /// Friend allocator used by soap_new__ns1__getRobotJointPosResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getRobotJointPosResponse * SOAP_FMAC2 soap_instantiate__ns1__getRobotJointPosResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:261 */
#ifndef SOAP_TYPE__ns1__getRobotJntCartPos
#define SOAP_TYPE__ns1__getRobotJntCartPos (46)
/* complex XSD type 'ns1:getRobotJntCartPos': */
class SOAP_CMAC _ns1__getRobotJntCartPos {
      public:
        /// Required element 'robot' of XSD type 'xsd:int'
        int robot;
        /// Required element 'tool' of XSD type 'ns1:CartesianPos'
        ns1__CartesianPos *tool;
        /// Required element 'frame' of XSD type 'ns1:CartesianPos'
        ns1__CartesianPos *frame;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getRobotJntCartPos
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__getRobotJntCartPos; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getRobotJntCartPos, default initialized and not managed by a soap context
        virtual _ns1__getRobotJntCartPos *soap_alloc(void) const { return SOAP_NEW(_ns1__getRobotJntCartPos); }
      public:
        /// Constructor with initializations
        _ns1__getRobotJntCartPos() : robot(), tool(), frame(), soap() { }
        virtual ~_ns1__getRobotJntCartPos() { }
        /// Friend allocator used by soap_new__ns1__getRobotJntCartPos(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getRobotJntCartPos * SOAP_FMAC2 soap_instantiate__ns1__getRobotJntCartPos(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:264 */
#ifndef SOAP_TYPE__ns1__getRobotJntCartPosResponse
#define SOAP_TYPE__ns1__getRobotJntCartPosResponse (47)
/* complex XSD type 'ns1:getRobotJntCartPosResponse': */
class SOAP_CMAC _ns1__getRobotJntCartPosResponse {
      public:
        /// Required element 'jntPos' of XSD type 'ns1:JointPos'
        ns1__JointPos *jntPos;
        /// Required element 'cartPos' of XSD type 'ns1:CartesianPos'
        ns1__CartesianPos *cartPos;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getRobotJntCartPosResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__getRobotJntCartPosResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getRobotJntCartPosResponse, default initialized and not managed by a soap context
        virtual _ns1__getRobotJntCartPosResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__getRobotJntCartPosResponse); }
      public:
        /// Constructor with initializations
        _ns1__getRobotJntCartPosResponse() : jntPos(), cartPos(), soap() { }
        virtual ~_ns1__getRobotJntCartPosResponse() { }
        /// Friend allocator used by soap_new__ns1__getRobotJntCartPosResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getRobotJntCartPosResponse * SOAP_FMAC2 soap_instantiate__ns1__getRobotJntCartPosResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:267 */
#ifndef SOAP_TYPE__ns1__setRobotJointPos
#define SOAP_TYPE__ns1__setRobotJointPos (48)
/* complex XSD type 'ns1:setRobotJointPos': */
class SOAP_CMAC _ns1__setRobotJointPos {
      public:
        /// Required element 'robot' of XSD type 'xsd:int'
        int robot;
        /// Required element 'pos' of XSD type 'ns1:JointPos'
        ns1__JointPos *pos;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__setRobotJointPos
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__setRobotJointPos; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__setRobotJointPos, default initialized and not managed by a soap context
        virtual _ns1__setRobotJointPos *soap_alloc(void) const { return SOAP_NEW(_ns1__setRobotJointPos); }
      public:
        /// Constructor with initializations
        _ns1__setRobotJointPos() : robot(), pos(), soap() { }
        virtual ~_ns1__setRobotJointPos() { }
        /// Friend allocator used by soap_new__ns1__setRobotJointPos(struct soap*, int)
        friend SOAP_FMAC1 _ns1__setRobotJointPos * SOAP_FMAC2 soap_instantiate__ns1__setRobotJointPos(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:270 */
#ifndef SOAP_TYPE__ns1__setRobotPosResponse
#define SOAP_TYPE__ns1__setRobotPosResponse (49)
/* complex XSD type 'ns1:setRobotPosResponse': */
class SOAP_CMAC _ns1__setRobotPosResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__setRobotPosResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__setRobotPosResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__setRobotPosResponse, default initialized and not managed by a soap context
        virtual _ns1__setRobotPosResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__setRobotPosResponse); }
      public:
        /// Constructor with initializations
        _ns1__setRobotPosResponse() : soap() { }
        virtual ~_ns1__setRobotPosResponse() { }
        /// Friend allocator used by soap_new__ns1__setRobotPosResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__setRobotPosResponse * SOAP_FMAC2 soap_instantiate__ns1__setRobotPosResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:273 */
#ifndef SOAP_TYPE_ns5__JointPos
#define SOAP_TYPE_ns5__JointPos (50)
/* complex XSD type 'ns5:JointPos': */
class SOAP_CMAC ns5__JointPos {
      public:
        /// Sequence of 1 to 100 elements 'item' of XSD type 'xsd:double'
        std::vector<double> item;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns5__JointPos
        virtual int soap_type(void) const { return SOAP_TYPE_ns5__JointPos; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__JointPos, default initialized and not managed by a soap context
        virtual ns5__JointPos *soap_alloc(void) const { return SOAP_NEW(ns5__JointPos); }
      public:
        /// Constructor with initializations
        ns5__JointPos() : item(), soap() { }
        virtual ~ns5__JointPos() { }
        /// Friend allocator used by soap_new_ns5__JointPos(struct soap*, int)
        friend SOAP_FMAC1 ns5__JointPos * SOAP_FMAC2 soap_instantiate_ns5__JointPos(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:276 */
#ifndef SOAP_TYPE_ns5__Parameters
#define SOAP_TYPE_ns5__Parameters (51)
/* complex XSD type 'ns5:Parameters': */
class SOAP_CMAC ns5__Parameters {
      public:
        /// Optional element 'Parameters' of XSD type 'ns1:Parameter'
        std::vector<ns1__Parameter *> Parameters;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns5__Parameters
        virtual int soap_type(void) const { return SOAP_TYPE_ns5__Parameters; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__Parameters, default initialized and not managed by a soap context
        virtual ns5__Parameters *soap_alloc(void) const { return SOAP_NEW(ns5__Parameters); }
      public:
        /// Constructor with initializations
        ns5__Parameters() : Parameters(), soap() { }
        virtual ~ns5__Parameters() { }
        /// Friend allocator used by soap_new_ns5__Parameters(struct soap*, int)
        friend SOAP_FMAC1 ns5__Parameters * SOAP_FMAC2 soap_instantiate_ns5__Parameters(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:279 */
#ifndef SOAP_TYPE_ns5__Versions
#define SOAP_TYPE_ns5__Versions (52)
/* complex XSD type 'ns5:Versions': */
class SOAP_CMAC ns5__Versions {
      public:
        /// Optional element 'Versions' of XSD type 'ns1:Version'
        std::vector<ns1__Version *> Versions;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns5__Versions
        virtual int soap_type(void) const { return SOAP_TYPE_ns5__Versions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__Versions, default initialized and not managed by a soap context
        virtual ns5__Versions *soap_alloc(void) const { return SOAP_NEW(ns5__Versions); }
      public:
        /// Constructor with initializations
        ns5__Versions() : Versions(), soap() { }
        virtual ~ns5__Versions() { }
        /// Friend allocator used by soap_new_ns5__Versions(struct soap*, int)
        friend SOAP_FMAC1 ns5__Versions * SOAP_FMAC2 soap_instantiate_ns5__Versions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:282 */
#ifndef SOAP_TYPE_ns5__Robots
#define SOAP_TYPE_ns5__Robots (53)
/* complex XSD type 'ns5:Robots': */
class SOAP_CMAC ns5__Robots {
      public:
        /// Optional element 'Robots' of XSD type 'ns1:Robot'
        std::vector<ns1__Robot *> Robots;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns5__Robots
        virtual int soap_type(void) const { return SOAP_TYPE_ns5__Robots; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__Robots, default initialized and not managed by a soap context
        virtual ns5__Robots *soap_alloc(void) const { return SOAP_NEW(ns5__Robots); }
      public:
        /// Constructor with initializations
        ns5__Robots() : Robots(), soap() { }
        virtual ~ns5__Robots() { }
        /// Friend allocator used by soap_new_ns5__Robots(struct soap*, int)
        friend SOAP_FMAC1 ns5__Robots * SOAP_FMAC2 soap_instantiate_ns5__Robots(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:285 */
#ifndef SOAP_TYPE_ns5__VALApplications
#define SOAP_TYPE_ns5__VALApplications (54)
/* complex XSD type 'ns5:VALApplications': */
class SOAP_CMAC ns5__VALApplications {
      public:
        /// Optional element 'application' of XSD type 'ns2:VALApplication'
        std::vector<ns2__VALApplication *> application;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns5__VALApplications
        virtual int soap_type(void) const { return SOAP_TYPE_ns5__VALApplications; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__VALApplications, default initialized and not managed by a soap context
        virtual ns5__VALApplications *soap_alloc(void) const { return SOAP_NEW(ns5__VALApplications); }
      public:
        /// Constructor with initializations
        ns5__VALApplications() : application(), soap() { }
        virtual ~ns5__VALApplications() { }
        /// Friend allocator used by soap_new_ns5__VALApplications(struct soap*, int)
        friend SOAP_FMAC1 ns5__VALApplications * SOAP_FMAC2 soap_instantiate_ns5__VALApplications(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:288 */
#ifndef SOAP_TYPE_ns5__Records
#define SOAP_TYPE_ns5__Records (55)
/* complex XSD type 'ns5:Records': */
class SOAP_CMAC ns5__Records {
      public:
        /// Optional element 'record' of XSD type 'xsd:string'
        std::vector<std::string> record;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns5__Records
        virtual int soap_type(void) const { return SOAP_TYPE_ns5__Records; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__Records, default initialized and not managed by a soap context
        virtual ns5__Records *soap_alloc(void) const { return SOAP_NEW(ns5__Records); }
      public:
        /// Constructor with initializations
        ns5__Records() : record(), soap() { }
        virtual ~ns5__Records() { }
        /// Friend allocator used by soap_new_ns5__Records(struct soap*, int)
        friend SOAP_FMAC1 ns5__Records * SOAP_FMAC2 soap_instantiate_ns5__Records(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:291 */
#ifndef SOAP_TYPE_ns5__SoapBreakpoints
#define SOAP_TYPE_ns5__SoapBreakpoints (56)
/* complex XSD type 'ns5:SoapBreakpoints': */
class SOAP_CMAC ns5__SoapBreakpoints {
      public:
        /// Optional element 'BreakPoint' of XSD type 'ns7:SoapBreakpoint'
        std::vector<ns7__SoapBreakpoint *> BreakPoint;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns5__SoapBreakpoints
        virtual int soap_type(void) const { return SOAP_TYPE_ns5__SoapBreakpoints; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__SoapBreakpoints, default initialized and not managed by a soap context
        virtual ns5__SoapBreakpoints *soap_alloc(void) const { return SOAP_NEW(ns5__SoapBreakpoints); }
      public:
        /// Constructor with initializations
        ns5__SoapBreakpoints() : BreakPoint(), soap() { }
        virtual ~ns5__SoapBreakpoints() { }
        /// Friend allocator used by soap_new_ns5__SoapBreakpoints(struct soap*, int)
        friend SOAP_FMAC1 ns5__SoapBreakpoints * SOAP_FMAC2 soap_instantiate_ns5__SoapBreakpoints(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:294 */
#ifndef SOAP_TYPE_ns5__BreakpointsResponses
#define SOAP_TYPE_ns5__BreakpointsResponses (57)
/* complex XSD type 'ns5:BreakpointsResponses': */
class SOAP_CMAC ns5__BreakpointsResponses {
      public:
        /// Optional element 'BreakpointResponse' of XSD type 'ns7:BreakpointsResponse'
        std::vector<ns7__BreakpointsResponse *> BreakpointResponse;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns5__BreakpointsResponses
        virtual int soap_type(void) const { return SOAP_TYPE_ns5__BreakpointsResponses; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__BreakpointsResponses, default initialized and not managed by a soap context
        virtual ns5__BreakpointsResponses *soap_alloc(void) const { return SOAP_NEW(ns5__BreakpointsResponses); }
      public:
        /// Constructor with initializations
        ns5__BreakpointsResponses() : BreakpointResponse(), soap() { }
        virtual ~ns5__BreakpointsResponses() { }
        /// Friend allocator used by soap_new_ns5__BreakpointsResponses(struct soap*, int)
        friend SOAP_FMAC1 ns5__BreakpointsResponses * SOAP_FMAC2 soap_instantiate_ns5__BreakpointsResponses(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:297 */
#ifndef SOAP_TYPE_ns5__SoapTasks
#define SOAP_TYPE_ns5__SoapTasks (58)
/* complex XSD type 'ns5:SoapTasks': */
class SOAP_CMAC ns5__SoapTasks {
      public:
        /// Optional element 'Task' of XSD type 'ns7:SoapTask'
        std::vector<ns7__SoapTask *> Task;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns5__SoapTasks
        virtual int soap_type(void) const { return SOAP_TYPE_ns5__SoapTasks; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__SoapTasks, default initialized and not managed by a soap context
        virtual ns5__SoapTasks *soap_alloc(void) const { return SOAP_NEW(ns5__SoapTasks); }
      public:
        /// Constructor with initializations
        ns5__SoapTasks() : Task(), soap() { }
        virtual ~ns5__SoapTasks() { }
        /// Friend allocator used by soap_new_ns5__SoapTasks(struct soap*, int)
        friend SOAP_FMAC1 ns5__SoapTasks * SOAP_FMAC2 soap_instantiate_ns5__SoapTasks(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:300 */
#ifndef SOAP_TYPE_ns5__SoapCallStack
#define SOAP_TYPE_ns5__SoapCallStack (59)
/* complex XSD type 'ns5:SoapCallStack': */
class SOAP_CMAC ns5__SoapCallStack {
      public:
        /// Optional element 'SfAbstract' of XSD type 'ns7:SoapStackFrameAbstract'
        std::vector<ns7__SoapStackFrameAbstract *> SfAbstract;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns5__SoapCallStack
        virtual int soap_type(void) const { return SOAP_TYPE_ns5__SoapCallStack; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__SoapCallStack, default initialized and not managed by a soap context
        virtual ns5__SoapCallStack *soap_alloc(void) const { return SOAP_NEW(ns5__SoapCallStack); }
      public:
        /// Constructor with initializations
        ns5__SoapCallStack() : SfAbstract(), soap() { }
        virtual ~ns5__SoapCallStack() { }
        /// Friend allocator used by soap_new_ns5__SoapCallStack(struct soap*, int)
        friend SOAP_FMAC1 ns5__SoapCallStack * SOAP_FMAC2 soap_instantiate_ns5__SoapCallStack(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:303 */
#ifndef SOAP_TYPE_ns5__SoapWatches
#define SOAP_TYPE_ns5__SoapWatches (60)
/* complex XSD type 'ns5:SoapWatches': */
class SOAP_CMAC ns5__SoapWatches {
      public:
        /// Optional element 'SoapData' of XSD type 'ns7:SoapData'
        std::vector<ns7__SoapData *> SoapData;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns5__SoapWatches
        virtual int soap_type(void) const { return SOAP_TYPE_ns5__SoapWatches; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__SoapWatches, default initialized and not managed by a soap context
        virtual ns5__SoapWatches *soap_alloc(void) const { return SOAP_NEW(ns5__SoapWatches); }
      public:
        /// Constructor with initializations
        ns5__SoapWatches() : SoapData(), soap() { }
        virtual ~ns5__SoapWatches() { }
        /// Friend allocator used by soap_new_ns5__SoapWatches(struct soap*, int)
        friend SOAP_FMAC1 ns5__SoapWatches * SOAP_FMAC2 soap_instantiate_ns5__SoapWatches(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:306 */
#ifndef SOAP_TYPE_ns5__SoapPhysicalIoLinks
#define SOAP_TYPE_ns5__SoapPhysicalIoLinks (61)
/* complex XSD type 'ns5:SoapPhysicalIoLinks': */
class SOAP_CMAC ns5__SoapPhysicalIoLinks {
      public:
        /// Optional element 'PhysicalPath' of XSD type 'xsd:string'
        std::vector<std::string> PhysicalPath;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns5__SoapPhysicalIoLinks
        virtual int soap_type(void) const { return SOAP_TYPE_ns5__SoapPhysicalIoLinks; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__SoapPhysicalIoLinks, default initialized and not managed by a soap context
        virtual ns5__SoapPhysicalIoLinks *soap_alloc(void) const { return SOAP_NEW(ns5__SoapPhysicalIoLinks); }
      public:
        /// Constructor with initializations
        ns5__SoapPhysicalIoLinks() : PhysicalPath(), soap() { }
        virtual ~ns5__SoapPhysicalIoLinks() { }
        /// Friend allocator used by soap_new_ns5__SoapPhysicalIoLinks(struct soap*, int)
        friend SOAP_FMAC1 ns5__SoapPhysicalIoLinks * SOAP_FMAC2 soap_instantiate_ns5__SoapPhysicalIoLinks(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:309 */
#ifndef SOAP_TYPE_ns5__SoapPhysicalIoValues
#define SOAP_TYPE_ns5__SoapPhysicalIoValues (62)
/* complex XSD type 'ns5:SoapPhysicalIoValues': */
class SOAP_CMAC ns5__SoapPhysicalIoValues {
      public:
        /// Optional element 'PhysicalIoValue' of XSD type 'xsd:double'
        std::vector<double> PhysicalIoValue;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns5__SoapPhysicalIoValues
        virtual int soap_type(void) const { return SOAP_TYPE_ns5__SoapPhysicalIoValues; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__SoapPhysicalIoValues, default initialized and not managed by a soap context
        virtual ns5__SoapPhysicalIoValues *soap_alloc(void) const { return SOAP_NEW(ns5__SoapPhysicalIoValues); }
      public:
        /// Constructor with initializations
        ns5__SoapPhysicalIoValues() : PhysicalIoValue(), soap() { }
        virtual ~ns5__SoapPhysicalIoValues() { }
        /// Friend allocator used by soap_new_ns5__SoapPhysicalIoValues(struct soap*, int)
        friend SOAP_FMAC1 ns5__SoapPhysicalIoValues * SOAP_FMAC2 soap_instantiate_ns5__SoapPhysicalIoValues(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:312 */
#ifndef SOAP_TYPE_ns5__SoapPhysicalIosStates
#define SOAP_TYPE_ns5__SoapPhysicalIosStates (63)
/* complex XSD type 'ns5:SoapPhysicalIosStates': */
class SOAP_CMAC ns5__SoapPhysicalIosStates {
      public:
        /// Optional element 'PhysicalIoState' of XSD type 'ns7:SoapPhysicalIoState'
        std::vector<ns7__SoapPhysicalIoState *> PhysicalIoState;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns5__SoapPhysicalIosStates
        virtual int soap_type(void) const { return SOAP_TYPE_ns5__SoapPhysicalIosStates; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__SoapPhysicalIosStates, default initialized and not managed by a soap context
        virtual ns5__SoapPhysicalIosStates *soap_alloc(void) const { return SOAP_NEW(ns5__SoapPhysicalIosStates); }
      public:
        /// Constructor with initializations
        ns5__SoapPhysicalIosStates() : PhysicalIoState(), soap() { }
        virtual ~ns5__SoapPhysicalIosStates() { }
        /// Friend allocator used by soap_new_ns5__SoapPhysicalIosStates(struct soap*, int)
        friend SOAP_FMAC1 ns5__SoapPhysicalIosStates * SOAP_FMAC2 soap_instantiate_ns5__SoapPhysicalIosStates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:315 */
#ifndef SOAP_TYPE_ns5__SoapPhysicalIoResponses
#define SOAP_TYPE_ns5__SoapPhysicalIoResponses (64)
/* complex XSD type 'ns5:SoapPhysicalIoResponses': */
class SOAP_CMAC ns5__SoapPhysicalIoResponses {
      public:
        /// Optional element 'PhysicalIoResponse' of XSD type 'ns7:SoapPhysicalIoResponse'
        std::vector<ns7__SoapPhysicalIoResponse *> PhysicalIoResponse;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns5__SoapPhysicalIoResponses
        virtual int soap_type(void) const { return SOAP_TYPE_ns5__SoapPhysicalIoResponses; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__SoapPhysicalIoResponses, default initialized and not managed by a soap context
        virtual ns5__SoapPhysicalIoResponses *soap_alloc(void) const { return SOAP_NEW(ns5__SoapPhysicalIoResponses); }
      public:
        /// Constructor with initializations
        ns5__SoapPhysicalIoResponses() : PhysicalIoResponse(), soap() { }
        virtual ~ns5__SoapPhysicalIoResponses() { }
        /// Friend allocator used by soap_new_ns5__SoapPhysicalIoResponses(struct soap*, int)
        friend SOAP_FMAC1 ns5__SoapPhysicalIoResponses * SOAP_FMAC2 soap_instantiate_ns5__SoapPhysicalIoResponses(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:318 */
#ifndef SOAP_TYPE_ns5__SoapPhysicalIoUnlockResponses
#define SOAP_TYPE_ns5__SoapPhysicalIoUnlockResponses (65)
/* complex XSD type 'ns5:SoapPhysicalIoUnlockResponses': */
class SOAP_CMAC ns5__SoapPhysicalIoUnlockResponses {
      public:
        /// Optional element 'PhysicalIoResponse' of XSD type 'ns7:SoapPhysicalIoUnlockResponse'
        std::vector<ns7__SoapPhysicalIoUnlockResponse *> PhysicalIoResponse;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns5__SoapPhysicalIoUnlockResponses
        virtual int soap_type(void) const { return SOAP_TYPE_ns5__SoapPhysicalIoUnlockResponses; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__SoapPhysicalIoUnlockResponses, default initialized and not managed by a soap context
        virtual ns5__SoapPhysicalIoUnlockResponses *soap_alloc(void) const { return SOAP_NEW(ns5__SoapPhysicalIoUnlockResponses); }
      public:
        /// Constructor with initializations
        ns5__SoapPhysicalIoUnlockResponses() : PhysicalIoResponse(), soap() { }
        virtual ~ns5__SoapPhysicalIoUnlockResponses() { }
        /// Friend allocator used by soap_new_ns5__SoapPhysicalIoUnlockResponses(struct soap*, int)
        friend SOAP_FMAC1 ns5__SoapPhysicalIoUnlockResponses * SOAP_FMAC2 soap_instantiate_ns5__SoapPhysicalIoUnlockResponses(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:321 */
#ifndef SOAP_TYPE_ns5__SoapDhParametersArray
#define SOAP_TYPE_ns5__SoapDhParametersArray (66)
/* complex XSD type 'ns5:SoapDhParametersArray': */
class SOAP_CMAC ns5__SoapDhParametersArray {
      public:
        /// Optional element 'DhParameters' of XSD type 'ns7:SoapDhParameters'
        std::vector<ns7__SoapDhParameters *> DhParameters;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns5__SoapDhParametersArray
        virtual int soap_type(void) const { return SOAP_TYPE_ns5__SoapDhParametersArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__SoapDhParametersArray, default initialized and not managed by a soap context
        virtual ns5__SoapDhParametersArray *soap_alloc(void) const { return SOAP_NEW(ns5__SoapDhParametersArray); }
      public:
        /// Constructor with initializations
        ns5__SoapDhParametersArray() : DhParameters(), soap() { }
        virtual ~ns5__SoapDhParametersArray() { }
        /// Friend allocator used by soap_new_ns5__SoapDhParametersArray(struct soap*, int)
        friend SOAP_FMAC1 ns5__SoapDhParametersArray * SOAP_FMAC2 soap_instantiate_ns5__SoapDhParametersArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:324 */
#ifndef SOAP_TYPE_ns7__JointPos
#define SOAP_TYPE_ns7__JointPos (67)
/* complex XSD type 'ns7:JointPos': */
class SOAP_CMAC ns7__JointPos {
      public:
        /// Sequence of 1 to 100 elements 'item' of XSD type 'xsd:double'
        std::vector<double> item;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns7__JointPos
        virtual int soap_type(void) const { return SOAP_TYPE_ns7__JointPos; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns7__JointPos, default initialized and not managed by a soap context
        virtual ns7__JointPos *soap_alloc(void) const { return SOAP_NEW(ns7__JointPos); }
      public:
        /// Constructor with initializations
        ns7__JointPos() : item(), soap() { }
        virtual ~ns7__JointPos() { }
        /// Friend allocator used by soap_new_ns7__JointPos(struct soap*, int)
        friend SOAP_FMAC1 ns7__JointPos * SOAP_FMAC2 soap_instantiate_ns7__JointPos(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:327 */
#ifndef SOAP_TYPE_ns7__Parameters
#define SOAP_TYPE_ns7__Parameters (68)
/* complex XSD type 'ns7:Parameters': */
class SOAP_CMAC ns7__Parameters {
      public:
        /// Optional element 'Parameters' of XSD type 'ns1:Parameter'
        std::vector<ns1__Parameter *> Parameters;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns7__Parameters
        virtual int soap_type(void) const { return SOAP_TYPE_ns7__Parameters; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns7__Parameters, default initialized and not managed by a soap context
        virtual ns7__Parameters *soap_alloc(void) const { return SOAP_NEW(ns7__Parameters); }
      public:
        /// Constructor with initializations
        ns7__Parameters() : Parameters(), soap() { }
        virtual ~ns7__Parameters() { }
        /// Friend allocator used by soap_new_ns7__Parameters(struct soap*, int)
        friend SOAP_FMAC1 ns7__Parameters * SOAP_FMAC2 soap_instantiate_ns7__Parameters(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:330 */
#ifndef SOAP_TYPE_ns7__Versions
#define SOAP_TYPE_ns7__Versions (69)
/* complex XSD type 'ns7:Versions': */
class SOAP_CMAC ns7__Versions {
      public:
        /// Optional element 'Versions' of XSD type 'ns1:Version'
        std::vector<ns1__Version *> Versions;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns7__Versions
        virtual int soap_type(void) const { return SOAP_TYPE_ns7__Versions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns7__Versions, default initialized and not managed by a soap context
        virtual ns7__Versions *soap_alloc(void) const { return SOAP_NEW(ns7__Versions); }
      public:
        /// Constructor with initializations
        ns7__Versions() : Versions(), soap() { }
        virtual ~ns7__Versions() { }
        /// Friend allocator used by soap_new_ns7__Versions(struct soap*, int)
        friend SOAP_FMAC1 ns7__Versions * SOAP_FMAC2 soap_instantiate_ns7__Versions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:333 */
#ifndef SOAP_TYPE_ns7__Robots
#define SOAP_TYPE_ns7__Robots (70)
/* complex XSD type 'ns7:Robots': */
class SOAP_CMAC ns7__Robots {
      public:
        /// Optional element 'Robots' of XSD type 'ns1:Robot'
        std::vector<ns1__Robot *> Robots;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns7__Robots
        virtual int soap_type(void) const { return SOAP_TYPE_ns7__Robots; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns7__Robots, default initialized and not managed by a soap context
        virtual ns7__Robots *soap_alloc(void) const { return SOAP_NEW(ns7__Robots); }
      public:
        /// Constructor with initializations
        ns7__Robots() : Robots(), soap() { }
        virtual ~ns7__Robots() { }
        /// Friend allocator used by soap_new_ns7__Robots(struct soap*, int)
        friend SOAP_FMAC1 ns7__Robots * SOAP_FMAC2 soap_instantiate_ns7__Robots(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:336 */
#ifndef SOAP_TYPE_ns7__VALApplications
#define SOAP_TYPE_ns7__VALApplications (71)
/* complex XSD type 'ns7:VALApplications': */
class SOAP_CMAC ns7__VALApplications {
      public:
        /// Optional element 'application' of XSD type 'ns2:VALApplication'
        std::vector<ns2__VALApplication *> application;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns7__VALApplications
        virtual int soap_type(void) const { return SOAP_TYPE_ns7__VALApplications; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns7__VALApplications, default initialized and not managed by a soap context
        virtual ns7__VALApplications *soap_alloc(void) const { return SOAP_NEW(ns7__VALApplications); }
      public:
        /// Constructor with initializations
        ns7__VALApplications() : application(), soap() { }
        virtual ~ns7__VALApplications() { }
        /// Friend allocator used by soap_new_ns7__VALApplications(struct soap*, int)
        friend SOAP_FMAC1 ns7__VALApplications * SOAP_FMAC2 soap_instantiate_ns7__VALApplications(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:339 */
#ifndef SOAP_TYPE_ns7__Records
#define SOAP_TYPE_ns7__Records (72)
/* complex XSD type 'ns7:Records': */
class SOAP_CMAC ns7__Records {
      public:
        /// Optional element 'record' of XSD type 'xsd:string'
        std::vector<std::string> record;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns7__Records
        virtual int soap_type(void) const { return SOAP_TYPE_ns7__Records; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns7__Records, default initialized and not managed by a soap context
        virtual ns7__Records *soap_alloc(void) const { return SOAP_NEW(ns7__Records); }
      public:
        /// Constructor with initializations
        ns7__Records() : record(), soap() { }
        virtual ~ns7__Records() { }
        /// Friend allocator used by soap_new_ns7__Records(struct soap*, int)
        friend SOAP_FMAC1 ns7__Records * SOAP_FMAC2 soap_instantiate_ns7__Records(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:342 */
#ifndef SOAP_TYPE_ns7__SoapProgramLine
#define SOAP_TYPE_ns7__SoapProgramLine (73)
/* complex XSD type 'ns7:SoapProgramLine': */
class SOAP_CMAC ns7__SoapProgramLine {
      public:
        /// Optional element 'appName' of XSD type 'xsd:string'
        std::string *appName;
        /// Optional element 'pgmName' of XSD type 'xsd:string'
        std::string *pgmName;
        /// Required element 'lineNumber' of XSD type 'xsd:int'
        int lineNumber;
        /// Optional element 'lineContent' of XSD type 'xsd:string'
        std::string *lineContent;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns7__SoapProgramLine
        virtual int soap_type(void) const { return SOAP_TYPE_ns7__SoapProgramLine; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns7__SoapProgramLine, default initialized and not managed by a soap context
        virtual ns7__SoapProgramLine *soap_alloc(void) const { return SOAP_NEW(ns7__SoapProgramLine); }
      public:
        /// Constructor with initializations
        ns7__SoapProgramLine() : appName(), pgmName(), lineNumber(), lineContent(), soap() { }
        virtual ~ns7__SoapProgramLine() { }
        /// Friend allocator used by soap_new_ns7__SoapProgramLine(struct soap*, int)
        friend SOAP_FMAC1 ns7__SoapProgramLine * SOAP_FMAC2 soap_instantiate_ns7__SoapProgramLine(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:345 */
#ifndef SOAP_TYPE_ns7__SoapBreakpoint
#define SOAP_TYPE_ns7__SoapBreakpoint (74)
/* complex XSD type 'ns7:SoapBreakpoint': */
class SOAP_CMAC ns7__SoapBreakpoint {
      public:
        /// Required element 'programLine' of XSD type 'ns7:SoapProgramLine'
        ns7__SoapProgramLine *programLine;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns7__SoapBreakpoint
        virtual int soap_type(void) const { return SOAP_TYPE_ns7__SoapBreakpoint; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns7__SoapBreakpoint, default initialized and not managed by a soap context
        virtual ns7__SoapBreakpoint *soap_alloc(void) const { return SOAP_NEW(ns7__SoapBreakpoint); }
      public:
        /// Constructor with initializations
        ns7__SoapBreakpoint() : programLine(), soap() { }
        virtual ~ns7__SoapBreakpoint() { }
        /// Friend allocator used by soap_new_ns7__SoapBreakpoint(struct soap*, int)
        friend SOAP_FMAC1 ns7__SoapBreakpoint * SOAP_FMAC2 soap_instantiate_ns7__SoapBreakpoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:348 */
#ifndef SOAP_TYPE_ns7__SoapBreakpoints
#define SOAP_TYPE_ns7__SoapBreakpoints (75)
/* complex XSD type 'ns7:SoapBreakpoints': */
class SOAP_CMAC ns7__SoapBreakpoints {
      public:
        /// Optional element 'BreakPoint' of XSD type 'ns7:SoapBreakpoint'
        std::vector<ns7__SoapBreakpoint *> BreakPoint;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns7__SoapBreakpoints
        virtual int soap_type(void) const { return SOAP_TYPE_ns7__SoapBreakpoints; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns7__SoapBreakpoints, default initialized and not managed by a soap context
        virtual ns7__SoapBreakpoints *soap_alloc(void) const { return SOAP_NEW(ns7__SoapBreakpoints); }
      public:
        /// Constructor with initializations
        ns7__SoapBreakpoints() : BreakPoint(), soap() { }
        virtual ~ns7__SoapBreakpoints() { }
        /// Friend allocator used by soap_new_ns7__SoapBreakpoints(struct soap*, int)
        friend SOAP_FMAC1 ns7__SoapBreakpoints * SOAP_FMAC2 soap_instantiate_ns7__SoapBreakpoints(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:351 */
#ifndef SOAP_TYPE_ns7__BreakpointsResponse
#define SOAP_TYPE_ns7__BreakpointsResponse (76)
/* complex XSD type 'ns7:BreakpointsResponse': */
class SOAP_CMAC ns7__BreakpointsResponse {
      public:
        /// Required element 'breakpointIndex' of XSD type 'xsd:int'
        int breakpointIndex;
        /// Required element 'errorCode' of XSD type 'ns1:ServerExceptionCode'
        enum ns1__ServerExceptionCode errorCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns7__BreakpointsResponse
        virtual int soap_type(void) const { return SOAP_TYPE_ns7__BreakpointsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns7__BreakpointsResponse, default initialized and not managed by a soap context
        virtual ns7__BreakpointsResponse *soap_alloc(void) const { return SOAP_NEW(ns7__BreakpointsResponse); }
      public:
        /// Constructor with initializations
        ns7__BreakpointsResponse() : breakpointIndex(), errorCode(), soap() { }
        virtual ~ns7__BreakpointsResponse() { }
        /// Friend allocator used by soap_new_ns7__BreakpointsResponse(struct soap*, int)
        friend SOAP_FMAC1 ns7__BreakpointsResponse * SOAP_FMAC2 soap_instantiate_ns7__BreakpointsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:354 */
#ifndef SOAP_TYPE_ns7__BreakpointsResponses
#define SOAP_TYPE_ns7__BreakpointsResponses (77)
/* complex XSD type 'ns7:BreakpointsResponses': */
class SOAP_CMAC ns7__BreakpointsResponses {
      public:
        /// Optional element 'BreakpointResponse' of XSD type 'ns7:BreakpointsResponse'
        std::vector<ns7__BreakpointsResponse *> BreakpointResponse;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns7__BreakpointsResponses
        virtual int soap_type(void) const { return SOAP_TYPE_ns7__BreakpointsResponses; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns7__BreakpointsResponses, default initialized and not managed by a soap context
        virtual ns7__BreakpointsResponses *soap_alloc(void) const { return SOAP_NEW(ns7__BreakpointsResponses); }
      public:
        /// Constructor with initializations
        ns7__BreakpointsResponses() : BreakpointResponse(), soap() { }
        virtual ~ns7__BreakpointsResponses() { }
        /// Friend allocator used by soap_new_ns7__BreakpointsResponses(struct soap*, int)
        friend SOAP_FMAC1 ns7__BreakpointsResponses * SOAP_FMAC2 soap_instantiate_ns7__BreakpointsResponses(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:357 */
#ifndef SOAP_TYPE_ns7__MimeData
#define SOAP_TYPE_ns7__MimeData (78)
/* complex XSD type 'ns7:MimeData': */
class SOAP_CMAC ns7__MimeData {
      public:
        /// Required element 'data' of XSD type 'xsd:base64Binary'
        xsd__base64Binary data;
        /// optional attribute 'ns5:contentType' of XSD type 'xsd:string'
        std::string *ns5__contentType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns7__MimeData
        virtual int soap_type(void) const { return SOAP_TYPE_ns7__MimeData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns7__MimeData, default initialized and not managed by a soap context
        virtual ns7__MimeData *soap_alloc(void) const { return SOAP_NEW(ns7__MimeData); }
      public:
        /// Constructor with initializations
        ns7__MimeData() : data(), ns5__contentType(), soap() { }
        virtual ~ns7__MimeData() { }
        /// Friend allocator used by soap_new_ns7__MimeData(struct soap*, int)
        friend SOAP_FMAC1 ns7__MimeData * SOAP_FMAC2 soap_instantiate_ns7__MimeData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:360 */
#ifndef SOAP_TYPE_ns7__SoapTask
#define SOAP_TYPE_ns7__SoapTask (79)
/* complex XSD type 'ns7:SoapTask': */
class SOAP_CMAC ns7__SoapTask {
      public:
        /// Optional element 'name' of XSD type 'xsd:string'
        std::string *name;
        /// Required element 'state' of XSD type 'ns7:SoapTaskState'
        enum ns7__SoapTaskState state;
        /// Required element 'priority' of XSD type 'xsd:int'
        int priority;
        /// Optional element 'createdBy' of XSD type 'xsd:string'
        std::string *createdBy;
        /// Required element 'runtimeError' of XSD type 'xsd:int'
        int runtimeError;
        /// Optional element 'runtimeErrorDescription' of XSD type 'xsd:string'
        std::string *runtimeErrorDescription;
        /// Required element 'programLine' of XSD type 'ns7:SoapProgramLine'
        ns7__SoapProgramLine *programLine;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns7__SoapTask
        virtual int soap_type(void) const { return SOAP_TYPE_ns7__SoapTask; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns7__SoapTask, default initialized and not managed by a soap context
        virtual ns7__SoapTask *soap_alloc(void) const { return SOAP_NEW(ns7__SoapTask); }
      public:
        /// Constructor with initializations
        ns7__SoapTask() : name(), state(), priority(), createdBy(), runtimeError(), runtimeErrorDescription(), programLine(), soap() { }
        virtual ~ns7__SoapTask() { }
        /// Friend allocator used by soap_new_ns7__SoapTask(struct soap*, int)
        friend SOAP_FMAC1 ns7__SoapTask * SOAP_FMAC2 soap_instantiate_ns7__SoapTask(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:363 */
#ifndef SOAP_TYPE_ns7__SoapTasks
#define SOAP_TYPE_ns7__SoapTasks (80)
/* complex XSD type 'ns7:SoapTasks': */
class SOAP_CMAC ns7__SoapTasks {
      public:
        /// Optional element 'Task' of XSD type 'ns7:SoapTask'
        std::vector<ns7__SoapTask *> Task;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns7__SoapTasks
        virtual int soap_type(void) const { return SOAP_TYPE_ns7__SoapTasks; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns7__SoapTasks, default initialized and not managed by a soap context
        virtual ns7__SoapTasks *soap_alloc(void) const { return SOAP_NEW(ns7__SoapTasks); }
      public:
        /// Constructor with initializations
        ns7__SoapTasks() : Task(), soap() { }
        virtual ~ns7__SoapTasks() { }
        /// Friend allocator used by soap_new_ns7__SoapTasks(struct soap*, int)
        friend SOAP_FMAC1 ns7__SoapTasks * SOAP_FMAC2 soap_instantiate_ns7__SoapTasks(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:366 */
#ifndef SOAP_TYPE_ns7__SoapInstruction
#define SOAP_TYPE_ns7__SoapInstruction (81)
/* complex XSD type 'ns7:SoapInstruction': */
class SOAP_CMAC ns7__SoapInstruction {
      public:
        /// Required element 'programLine' of XSD type 'ns7:SoapProgramLine'
        ns7__SoapProgramLine *programLine;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns7__SoapInstruction
        virtual int soap_type(void) const { return SOAP_TYPE_ns7__SoapInstruction; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns7__SoapInstruction, default initialized and not managed by a soap context
        virtual ns7__SoapInstruction *soap_alloc(void) const { return SOAP_NEW(ns7__SoapInstruction); }
      public:
        /// Constructor with initializations
        ns7__SoapInstruction() : programLine(), soap() { }
        virtual ~ns7__SoapInstruction() { }
        /// Friend allocator used by soap_new_ns7__SoapInstruction(struct soap*, int)
        friend SOAP_FMAC1 ns7__SoapInstruction * SOAP_FMAC2 soap_instantiate_ns7__SoapInstruction(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:369 */
#ifndef SOAP_TYPE_ns7__SoapStackFrameAbstract
#define SOAP_TYPE_ns7__SoapStackFrameAbstract (82)
/* complex XSD type 'ns7:SoapStackFrameAbstract': */
class SOAP_CMAC ns7__SoapStackFrameAbstract {
      public:
        /// Required element 'currentInstruction' of XSD type 'ns7:SoapInstruction'
        ns7__SoapInstruction *currentInstruction;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns7__SoapStackFrameAbstract
        virtual int soap_type(void) const { return SOAP_TYPE_ns7__SoapStackFrameAbstract; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns7__SoapStackFrameAbstract, default initialized and not managed by a soap context
        virtual ns7__SoapStackFrameAbstract *soap_alloc(void) const { return SOAP_NEW(ns7__SoapStackFrameAbstract); }
      public:
        /// Constructor with initializations
        ns7__SoapStackFrameAbstract() : currentInstruction(), soap() { }
        virtual ~ns7__SoapStackFrameAbstract() { }
        /// Friend allocator used by soap_new_ns7__SoapStackFrameAbstract(struct soap*, int)
        friend SOAP_FMAC1 ns7__SoapStackFrameAbstract * SOAP_FMAC2 soap_instantiate_ns7__SoapStackFrameAbstract(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:372 */
#ifndef SOAP_TYPE_ns7__SoapCallStack
#define SOAP_TYPE_ns7__SoapCallStack (83)
/* complex XSD type 'ns7:SoapCallStack': */
class SOAP_CMAC ns7__SoapCallStack {
      public:
        /// Optional element 'SfAbstract' of XSD type 'ns7:SoapStackFrameAbstract'
        std::vector<ns7__SoapStackFrameAbstract *> SfAbstract;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns7__SoapCallStack
        virtual int soap_type(void) const { return SOAP_TYPE_ns7__SoapCallStack; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns7__SoapCallStack, default initialized and not managed by a soap context
        virtual ns7__SoapCallStack *soap_alloc(void) const { return SOAP_NEW(ns7__SoapCallStack); }
      public:
        /// Constructor with initializations
        ns7__SoapCallStack() : SfAbstract(), soap() { }
        virtual ~ns7__SoapCallStack() { }
        /// Friend allocator used by soap_new_ns7__SoapCallStack(struct soap*, int)
        friend SOAP_FMAC1 ns7__SoapCallStack * SOAP_FMAC2 soap_instantiate_ns7__SoapCallStack(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:375 */
#ifndef SOAP_TYPE_ns7__SoapData
#define SOAP_TYPE_ns7__SoapData (84)
/* complex XSD type 'ns7:SoapData': */
class SOAP_CMAC ns7__SoapData {
      public:
        /// Optional element 'appName' of XSD type 'xsd:string'
        std::string *appName;
        /// Optional element 'dataName' of XSD type 'xsd:string'
        std::string *dataName;
        /// Optional element 'dataIndex' of XSD type 'xsd:string'
        std::string *dataIndex;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns7__SoapData
        virtual int soap_type(void) const { return SOAP_TYPE_ns7__SoapData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns7__SoapData, default initialized and not managed by a soap context
        virtual ns7__SoapData *soap_alloc(void) const { return SOAP_NEW(ns7__SoapData); }
      public:
        /// Constructor with initializations
        ns7__SoapData() : appName(), dataName(), dataIndex(), soap() { }
        virtual ~ns7__SoapData() { }
        /// Friend allocator used by soap_new_ns7__SoapData(struct soap*, int)
        friend SOAP_FMAC1 ns7__SoapData * SOAP_FMAC2 soap_instantiate_ns7__SoapData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:378 */
#ifndef SOAP_TYPE_ns7__SoapWatches
#define SOAP_TYPE_ns7__SoapWatches (85)
/* complex XSD type 'ns7:SoapWatches': */
class SOAP_CMAC ns7__SoapWatches {
      public:
        /// Optional element 'SoapData' of XSD type 'ns7:SoapData'
        std::vector<ns7__SoapData *> SoapData;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns7__SoapWatches
        virtual int soap_type(void) const { return SOAP_TYPE_ns7__SoapWatches; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns7__SoapWatches, default initialized and not managed by a soap context
        virtual ns7__SoapWatches *soap_alloc(void) const { return SOAP_NEW(ns7__SoapWatches); }
      public:
        /// Constructor with initializations
        ns7__SoapWatches() : SoapData(), soap() { }
        virtual ~ns7__SoapWatches() { }
        /// Friend allocator used by soap_new_ns7__SoapWatches(struct soap*, int)
        friend SOAP_FMAC1 ns7__SoapWatches * SOAP_FMAC2 soap_instantiate_ns7__SoapWatches(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:381 */
#ifndef SOAP_TYPE_ns7__SoapPhysicalIoLinks
#define SOAP_TYPE_ns7__SoapPhysicalIoLinks (86)
/* complex XSD type 'ns7:SoapPhysicalIoLinks': */
class SOAP_CMAC ns7__SoapPhysicalIoLinks {
      public:
        /// Optional element 'PhysicalPath' of XSD type 'xsd:string'
        std::vector<std::string> PhysicalPath;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns7__SoapPhysicalIoLinks
        virtual int soap_type(void) const { return SOAP_TYPE_ns7__SoapPhysicalIoLinks; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns7__SoapPhysicalIoLinks, default initialized and not managed by a soap context
        virtual ns7__SoapPhysicalIoLinks *soap_alloc(void) const { return SOAP_NEW(ns7__SoapPhysicalIoLinks); }
      public:
        /// Constructor with initializations
        ns7__SoapPhysicalIoLinks() : PhysicalPath(), soap() { }
        virtual ~ns7__SoapPhysicalIoLinks() { }
        /// Friend allocator used by soap_new_ns7__SoapPhysicalIoLinks(struct soap*, int)
        friend SOAP_FMAC1 ns7__SoapPhysicalIoLinks * SOAP_FMAC2 soap_instantiate_ns7__SoapPhysicalIoLinks(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:384 */
#ifndef SOAP_TYPE_ns7__SoapPhysicalDioAttrib
#define SOAP_TYPE_ns7__SoapPhysicalDioAttrib (87)
/* complex XSD type 'ns7:SoapPhysicalDioAttrib': */
class SOAP_CMAC ns7__SoapPhysicalDioAttrib {
      public:
        /// Required element 'inverted' of XSD type 'xsd:boolean'
        bool inverted;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns7__SoapPhysicalDioAttrib
        virtual int soap_type(void) const { return SOAP_TYPE_ns7__SoapPhysicalDioAttrib; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns7__SoapPhysicalDioAttrib, default initialized and not managed by a soap context
        virtual ns7__SoapPhysicalDioAttrib *soap_alloc(void) const { return SOAP_NEW(ns7__SoapPhysicalDioAttrib); }
      public:
        /// Constructor with initializations
        ns7__SoapPhysicalDioAttrib() : inverted(), soap() { }
        virtual ~ns7__SoapPhysicalDioAttrib() { }
        /// Friend allocator used by soap_new_ns7__SoapPhysicalDioAttrib(struct soap*, int)
        friend SOAP_FMAC1 ns7__SoapPhysicalDioAttrib * SOAP_FMAC2 soap_instantiate_ns7__SoapPhysicalDioAttrib(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:387 */
#ifndef SOAP_TYPE_ns7__SoapPhysicalAioAttrib
#define SOAP_TYPE_ns7__SoapPhysicalAioAttrib (88)
/* complex XSD type 'ns7:SoapPhysicalAioAttrib': */
class SOAP_CMAC ns7__SoapPhysicalAioAttrib {
      public:
        /// Required element 'coefA' of XSD type 'xsd:double'
        double coefA;
        /// Required element 'coefB' of XSD type 'xsd:double'
        double coefB;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns7__SoapPhysicalAioAttrib
        virtual int soap_type(void) const { return SOAP_TYPE_ns7__SoapPhysicalAioAttrib; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns7__SoapPhysicalAioAttrib, default initialized and not managed by a soap context
        virtual ns7__SoapPhysicalAioAttrib *soap_alloc(void) const { return SOAP_NEW(ns7__SoapPhysicalAioAttrib); }
      public:
        /// Constructor with initializations
        ns7__SoapPhysicalAioAttrib() : coefA(), coefB(), soap() { }
        virtual ~ns7__SoapPhysicalAioAttrib() { }
        /// Friend allocator used by soap_new_ns7__SoapPhysicalAioAttrib(struct soap*, int)
        friend SOAP_FMAC1 ns7__SoapPhysicalAioAttrib * SOAP_FMAC2 soap_instantiate_ns7__SoapPhysicalAioAttrib(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:1692 */
#ifndef SOAP_TYPE__ns7__union_SoapPhysicalIoAttrib
#define SOAP_TYPE__ns7__union_SoapPhysicalIoAttrib (222)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ns7__union_SoapPhysicalIoAttrib
{
        #define SOAP_UNION__ns7__union_SoapPhysicalIoAttrib_dioAttrib	(1)	/**< union variant selector value for member dioAttrib */
        ns7__SoapPhysicalDioAttrib *dioAttrib;
        #define SOAP_UNION__ns7__union_SoapPhysicalIoAttrib_aioAttrib	(2)	/**< union variant selector value for member aioAttrib */
        ns7__SoapPhysicalAioAttrib *aioAttrib;
};
#endif

/* CS8Server.h:390 */
#ifndef SOAP_TYPE_ns7__SoapPhysicalIoAttrib
#define SOAP_TYPE_ns7__SoapPhysicalIoAttrib (89)
/* Choice: */
class SOAP_CMAC ns7__SoapPhysicalIoAttrib {
      public:
        /// Union with union _ns7__union_SoapPhysicalIoAttrib variant selector __union_SoapPhysicalIoAttrib set to one of: SOAP_UNION__ns7__union_SoapPhysicalIoAttrib_dioAttrib SOAP_UNION__ns7__union_SoapPhysicalIoAttrib_aioAttrib
        int __union_SoapPhysicalIoAttrib;
        union _ns7__union_SoapPhysicalIoAttrib union_SoapPhysicalIoAttrib;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns7__SoapPhysicalIoAttrib
        virtual int soap_type(void) const { return SOAP_TYPE_ns7__SoapPhysicalIoAttrib; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns7__SoapPhysicalIoAttrib, default initialized and not managed by a soap context
        virtual ns7__SoapPhysicalIoAttrib *soap_alloc(void) const { return SOAP_NEW(ns7__SoapPhysicalIoAttrib); }
      public:
        /// Constructor with initializations
        ns7__SoapPhysicalIoAttrib() : __union_SoapPhysicalIoAttrib(), soap() { }
        virtual ~ns7__SoapPhysicalIoAttrib() { }
        /// Friend allocator used by soap_new_ns7__SoapPhysicalIoAttrib(struct soap*, int)
        friend SOAP_FMAC1 ns7__SoapPhysicalIoAttrib * SOAP_FMAC2 soap_instantiate_ns7__SoapPhysicalIoAttrib(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:393 */
#ifndef SOAP_TYPE_ns7__SoapPhysicalIoState
#define SOAP_TYPE_ns7__SoapPhysicalIoState (90)
/* complex XSD type 'ns7:SoapPhysicalIoState': */
class SOAP_CMAC ns7__SoapPhysicalIoState {
      public:
        /// Required element 'state' of XSD type 'ns7:SoapPhysicalIoEnumState'
        enum ns7__SoapPhysicalIoEnumState state;
        /// Required element 'locked' of XSD type 'xsd:boolean'
        bool locked;
        /// Required element 'simulated' of XSD type 'xsd:boolean'
        bool simulated;
        /// Required element 'value' of XSD type 'xsd:double'
        double value;
        /// Optional element 'description' of XSD type 'xsd:string'
        std::string *description;
        /// Required element 'attrib' of XSD type 'ns7:SoapPhysicalIoAttrib'
        ns7__SoapPhysicalIoAttrib *attrib;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns7__SoapPhysicalIoState
        virtual int soap_type(void) const { return SOAP_TYPE_ns7__SoapPhysicalIoState; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns7__SoapPhysicalIoState, default initialized and not managed by a soap context
        virtual ns7__SoapPhysicalIoState *soap_alloc(void) const { return SOAP_NEW(ns7__SoapPhysicalIoState); }
      public:
        /// Constructor with initializations
        ns7__SoapPhysicalIoState() : state(), locked(), simulated(), value(), description(), attrib(), soap() { }
        virtual ~ns7__SoapPhysicalIoState() { }
        /// Friend allocator used by soap_new_ns7__SoapPhysicalIoState(struct soap*, int)
        friend SOAP_FMAC1 ns7__SoapPhysicalIoState * SOAP_FMAC2 soap_instantiate_ns7__SoapPhysicalIoState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:396 */
#ifndef SOAP_TYPE_ns7__SoapPhysicalIoValues
#define SOAP_TYPE_ns7__SoapPhysicalIoValues (91)
/* complex XSD type 'ns7:SoapPhysicalIoValues': */
class SOAP_CMAC ns7__SoapPhysicalIoValues {
      public:
        /// Optional element 'PhysicalIoValue' of XSD type 'xsd:double'
        std::vector<double> PhysicalIoValue;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns7__SoapPhysicalIoValues
        virtual int soap_type(void) const { return SOAP_TYPE_ns7__SoapPhysicalIoValues; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns7__SoapPhysicalIoValues, default initialized and not managed by a soap context
        virtual ns7__SoapPhysicalIoValues *soap_alloc(void) const { return SOAP_NEW(ns7__SoapPhysicalIoValues); }
      public:
        /// Constructor with initializations
        ns7__SoapPhysicalIoValues() : PhysicalIoValue(), soap() { }
        virtual ~ns7__SoapPhysicalIoValues() { }
        /// Friend allocator used by soap_new_ns7__SoapPhysicalIoValues(struct soap*, int)
        friend SOAP_FMAC1 ns7__SoapPhysicalIoValues * SOAP_FMAC2 soap_instantiate_ns7__SoapPhysicalIoValues(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:399 */
#ifndef SOAP_TYPE_ns7__SoapPhysicalIosStates
#define SOAP_TYPE_ns7__SoapPhysicalIosStates (92)
/* complex XSD type 'ns7:SoapPhysicalIosStates': */
class SOAP_CMAC ns7__SoapPhysicalIosStates {
      public:
        /// Optional element 'PhysicalIoState' of XSD type 'ns7:SoapPhysicalIoState'
        std::vector<ns7__SoapPhysicalIoState *> PhysicalIoState;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns7__SoapPhysicalIosStates
        virtual int soap_type(void) const { return SOAP_TYPE_ns7__SoapPhysicalIosStates; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns7__SoapPhysicalIosStates, default initialized and not managed by a soap context
        virtual ns7__SoapPhysicalIosStates *soap_alloc(void) const { return SOAP_NEW(ns7__SoapPhysicalIosStates); }
      public:
        /// Constructor with initializations
        ns7__SoapPhysicalIosStates() : PhysicalIoState(), soap() { }
        virtual ~ns7__SoapPhysicalIosStates() { }
        /// Friend allocator used by soap_new_ns7__SoapPhysicalIosStates(struct soap*, int)
        friend SOAP_FMAC1 ns7__SoapPhysicalIosStates * SOAP_FMAC2 soap_instantiate_ns7__SoapPhysicalIosStates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:402 */
#ifndef SOAP_TYPE_ns7__SoapPhysicalIoResponse
#define SOAP_TYPE_ns7__SoapPhysicalIoResponse (93)
/* complex XSD type 'ns7:SoapPhysicalIoResponse': */
class SOAP_CMAC ns7__SoapPhysicalIoResponse {
      public:
        /// Required element 'success' of XSD type 'xsd:boolean'
        bool success;
        /// Required element 'found' of XSD type 'xsd:boolean'
        bool found;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns7__SoapPhysicalIoResponse
        virtual int soap_type(void) const { return SOAP_TYPE_ns7__SoapPhysicalIoResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns7__SoapPhysicalIoResponse, default initialized and not managed by a soap context
        virtual ns7__SoapPhysicalIoResponse *soap_alloc(void) const { return SOAP_NEW(ns7__SoapPhysicalIoResponse); }
      public:
        /// Constructor with initializations
        ns7__SoapPhysicalIoResponse() : success(), found(), soap() { }
        virtual ~ns7__SoapPhysicalIoResponse() { }
        /// Friend allocator used by soap_new_ns7__SoapPhysicalIoResponse(struct soap*, int)
        friend SOAP_FMAC1 ns7__SoapPhysicalIoResponse * SOAP_FMAC2 soap_instantiate_ns7__SoapPhysicalIoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:405 */
#ifndef SOAP_TYPE_ns7__SoapPhysicalIoResponses
#define SOAP_TYPE_ns7__SoapPhysicalIoResponses (94)
/* complex XSD type 'ns7:SoapPhysicalIoResponses': */
class SOAP_CMAC ns7__SoapPhysicalIoResponses {
      public:
        /// Optional element 'PhysicalIoResponse' of XSD type 'ns7:SoapPhysicalIoResponse'
        std::vector<ns7__SoapPhysicalIoResponse *> PhysicalIoResponse;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns7__SoapPhysicalIoResponses
        virtual int soap_type(void) const { return SOAP_TYPE_ns7__SoapPhysicalIoResponses; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns7__SoapPhysicalIoResponses, default initialized and not managed by a soap context
        virtual ns7__SoapPhysicalIoResponses *soap_alloc(void) const { return SOAP_NEW(ns7__SoapPhysicalIoResponses); }
      public:
        /// Constructor with initializations
        ns7__SoapPhysicalIoResponses() : PhysicalIoResponse(), soap() { }
        virtual ~ns7__SoapPhysicalIoResponses() { }
        /// Friend allocator used by soap_new_ns7__SoapPhysicalIoResponses(struct soap*, int)
        friend SOAP_FMAC1 ns7__SoapPhysicalIoResponses * SOAP_FMAC2 soap_instantiate_ns7__SoapPhysicalIoResponses(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:408 */
#ifndef SOAP_TYPE_ns7__SoapPhysicalIoUnlockResponse
#define SOAP_TYPE_ns7__SoapPhysicalIoUnlockResponse (95)
/* complex XSD type 'ns7:SoapPhysicalIoUnlockResponse': */
class SOAP_CMAC ns7__SoapPhysicalIoUnlockResponse {
      public:
        /// Required element 'response' of XSD type 'ns7:SoapPhysicalIoResponse'
        ns7__SoapPhysicalIoResponse *response;
        /// Required element 'state' of XSD type 'ns7:SoapPhysicalIoState'
        ns7__SoapPhysicalIoState *state;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns7__SoapPhysicalIoUnlockResponse
        virtual int soap_type(void) const { return SOAP_TYPE_ns7__SoapPhysicalIoUnlockResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns7__SoapPhysicalIoUnlockResponse, default initialized and not managed by a soap context
        virtual ns7__SoapPhysicalIoUnlockResponse *soap_alloc(void) const { return SOAP_NEW(ns7__SoapPhysicalIoUnlockResponse); }
      public:
        /// Constructor with initializations
        ns7__SoapPhysicalIoUnlockResponse() : response(), state(), soap() { }
        virtual ~ns7__SoapPhysicalIoUnlockResponse() { }
        /// Friend allocator used by soap_new_ns7__SoapPhysicalIoUnlockResponse(struct soap*, int)
        friend SOAP_FMAC1 ns7__SoapPhysicalIoUnlockResponse * SOAP_FMAC2 soap_instantiate_ns7__SoapPhysicalIoUnlockResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:411 */
#ifndef SOAP_TYPE_ns7__SoapPhysicalIoUnlockResponses
#define SOAP_TYPE_ns7__SoapPhysicalIoUnlockResponses (96)
/* complex XSD type 'ns7:SoapPhysicalIoUnlockResponses': */
class SOAP_CMAC ns7__SoapPhysicalIoUnlockResponses {
      public:
        /// Optional element 'PhysicalIoResponse' of XSD type 'ns7:SoapPhysicalIoUnlockResponse'
        std::vector<ns7__SoapPhysicalIoUnlockResponse *> PhysicalIoResponse;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns7__SoapPhysicalIoUnlockResponses
        virtual int soap_type(void) const { return SOAP_TYPE_ns7__SoapPhysicalIoUnlockResponses; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns7__SoapPhysicalIoUnlockResponses, default initialized and not managed by a soap context
        virtual ns7__SoapPhysicalIoUnlockResponses *soap_alloc(void) const { return SOAP_NEW(ns7__SoapPhysicalIoUnlockResponses); }
      public:
        /// Constructor with initializations
        ns7__SoapPhysicalIoUnlockResponses() : PhysicalIoResponse(), soap() { }
        virtual ~ns7__SoapPhysicalIoUnlockResponses() { }
        /// Friend allocator used by soap_new_ns7__SoapPhysicalIoUnlockResponses(struct soap*, int)
        friend SOAP_FMAC1 ns7__SoapPhysicalIoUnlockResponses * SOAP_FMAC2 soap_instantiate_ns7__SoapPhysicalIoUnlockResponses(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:414 */
#ifndef SOAP_TYPE_ns7__SoapDhParameters
#define SOAP_TYPE_ns7__SoapDhParameters (97)
/* complex XSD type 'ns7:SoapDhParameters': */
class SOAP_CMAC ns7__SoapDhParameters {
      public:
        /// Required element 'theta' of XSD type 'xsd:double'
        double theta;
        /// Required element 'd' of XSD type 'xsd:double'
        double d;
        /// Required element 'a' of XSD type 'xsd:double'
        double a;
        /// Required element 'alpha' of XSD type 'xsd:double'
        double alpha;
        /// Required element 'beta' of XSD type 'xsd:double'
        double beta;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns7__SoapDhParameters
        virtual int soap_type(void) const { return SOAP_TYPE_ns7__SoapDhParameters; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns7__SoapDhParameters, default initialized and not managed by a soap context
        virtual ns7__SoapDhParameters *soap_alloc(void) const { return SOAP_NEW(ns7__SoapDhParameters); }
      public:
        /// Constructor with initializations
        ns7__SoapDhParameters() : theta(), d(), a(), alpha(), beta(), soap() { }
        virtual ~ns7__SoapDhParameters() { }
        /// Friend allocator used by soap_new_ns7__SoapDhParameters(struct soap*, int)
        friend SOAP_FMAC1 ns7__SoapDhParameters * SOAP_FMAC2 soap_instantiate_ns7__SoapDhParameters(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:417 */
#ifndef SOAP_TYPE_ns7__SoapDhParametersArray
#define SOAP_TYPE_ns7__SoapDhParametersArray (98)
/* complex XSD type 'ns7:SoapDhParametersArray': */
class SOAP_CMAC ns7__SoapDhParametersArray {
      public:
        /// Optional element 'DhParameters' of XSD type 'ns7:SoapDhParameters'
        std::vector<ns7__SoapDhParameters *> DhParameters;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns7__SoapDhParametersArray
        virtual int soap_type(void) const { return SOAP_TYPE_ns7__SoapDhParametersArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns7__SoapDhParametersArray, default initialized and not managed by a soap context
        virtual ns7__SoapDhParametersArray *soap_alloc(void) const { return SOAP_NEW(ns7__SoapDhParametersArray); }
      public:
        /// Constructor with initializations
        ns7__SoapDhParametersArray() : DhParameters(), soap() { }
        virtual ~ns7__SoapDhParametersArray() { }
        /// Friend allocator used by soap_new_ns7__SoapDhParametersArray(struct soap*, int)
        friend SOAP_FMAC1 ns7__SoapDhParametersArray * SOAP_FMAC2 soap_instantiate_ns7__SoapDhParametersArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:420 */
#ifndef SOAP_TYPE__ns7__setBreakpoints
#define SOAP_TYPE__ns7__setBreakpoints (99)
/* complex XSD type 'ns7:setBreakpoints': */
class SOAP_CMAC _ns7__setBreakpoints {
      public:
        /// Required element 'breakpoints' of XSD type 'ns7:SoapBreakpoints'
        ns7__SoapBreakpoints *breakpoints;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__setBreakpoints
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__setBreakpoints; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__setBreakpoints, default initialized and not managed by a soap context
        virtual _ns7__setBreakpoints *soap_alloc(void) const { return SOAP_NEW(_ns7__setBreakpoints); }
      public:
        /// Constructor with initializations
        _ns7__setBreakpoints() : breakpoints(), soap() { }
        virtual ~_ns7__setBreakpoints() { }
        /// Friend allocator used by soap_new__ns7__setBreakpoints(struct soap*, int)
        friend SOAP_FMAC1 _ns7__setBreakpoints * SOAP_FMAC2 soap_instantiate__ns7__setBreakpoints(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:423 */
#ifndef SOAP_TYPE__ns7__setBreakpointsResponse
#define SOAP_TYPE__ns7__setBreakpointsResponse (100)
/* complex XSD type 'ns7:setBreakpointsResponse': */
class SOAP_CMAC _ns7__setBreakpointsResponse {
      public:
        /// Required element 'out' of XSD type 'ns7:BreakpointsResponses'
        ns7__BreakpointsResponses *out;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__setBreakpointsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__setBreakpointsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__setBreakpointsResponse, default initialized and not managed by a soap context
        virtual _ns7__setBreakpointsResponse *soap_alloc(void) const { return SOAP_NEW(_ns7__setBreakpointsResponse); }
      public:
        /// Constructor with initializations
        _ns7__setBreakpointsResponse() : out(), soap() { }
        virtual ~_ns7__setBreakpointsResponse() { }
        /// Friend allocator used by soap_new__ns7__setBreakpointsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns7__setBreakpointsResponse * SOAP_FMAC2 soap_instantiate__ns7__setBreakpointsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:426 */
#ifndef SOAP_TYPE__ns7__getBreakpoints
#define SOAP_TYPE__ns7__getBreakpoints (101)
/* complex XSD type 'ns7:getBreakpoints': */
class SOAP_CMAC _ns7__getBreakpoints {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__getBreakpoints
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__getBreakpoints; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__getBreakpoints, default initialized and not managed by a soap context
        virtual _ns7__getBreakpoints *soap_alloc(void) const { return SOAP_NEW(_ns7__getBreakpoints); }
      public:
        /// Constructor with initializations
        _ns7__getBreakpoints() : soap() { }
        virtual ~_ns7__getBreakpoints() { }
        /// Friend allocator used by soap_new__ns7__getBreakpoints(struct soap*, int)
        friend SOAP_FMAC1 _ns7__getBreakpoints * SOAP_FMAC2 soap_instantiate__ns7__getBreakpoints(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:429 */
#ifndef SOAP_TYPE__ns7__getBreakpointsResponse
#define SOAP_TYPE__ns7__getBreakpointsResponse (102)
/* complex XSD type 'ns7:getBreakpointsResponse': */
class SOAP_CMAC _ns7__getBreakpointsResponse {
      public:
        /// Required element 'breakpoints' of XSD type 'ns7:SoapBreakpoints'
        ns7__SoapBreakpoints *breakpoints;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__getBreakpointsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__getBreakpointsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__getBreakpointsResponse, default initialized and not managed by a soap context
        virtual _ns7__getBreakpointsResponse *soap_alloc(void) const { return SOAP_NEW(_ns7__getBreakpointsResponse); }
      public:
        /// Constructor with initializations
        _ns7__getBreakpointsResponse() : breakpoints(), soap() { }
        virtual ~_ns7__getBreakpointsResponse() { }
        /// Friend allocator used by soap_new__ns7__getBreakpointsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns7__getBreakpointsResponse * SOAP_FMAC2 soap_instantiate__ns7__getBreakpointsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:432 */
#ifndef SOAP_TYPE__ns7__clearBreakpoints
#define SOAP_TYPE__ns7__clearBreakpoints (103)
/* complex XSD type 'ns7:clearBreakpoints': */
class SOAP_CMAC _ns7__clearBreakpoints {
      public:
        /// Required element 'breakpoints' of XSD type 'ns7:SoapBreakpoints'
        ns7__SoapBreakpoints *breakpoints;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__clearBreakpoints
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__clearBreakpoints; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__clearBreakpoints, default initialized and not managed by a soap context
        virtual _ns7__clearBreakpoints *soap_alloc(void) const { return SOAP_NEW(_ns7__clearBreakpoints); }
      public:
        /// Constructor with initializations
        _ns7__clearBreakpoints() : breakpoints(), soap() { }
        virtual ~_ns7__clearBreakpoints() { }
        /// Friend allocator used by soap_new__ns7__clearBreakpoints(struct soap*, int)
        friend SOAP_FMAC1 _ns7__clearBreakpoints * SOAP_FMAC2 soap_instantiate__ns7__clearBreakpoints(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:435 */
#ifndef SOAP_TYPE__ns7__clearBreakpointsResponse
#define SOAP_TYPE__ns7__clearBreakpointsResponse (104)
/* complex XSD type 'ns7:clearBreakpointsResponse': */
class SOAP_CMAC _ns7__clearBreakpointsResponse {
      public:
        /// Required element 'out' of XSD type 'ns7:BreakpointsResponses'
        ns7__BreakpointsResponses *out;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__clearBreakpointsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__clearBreakpointsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__clearBreakpointsResponse, default initialized and not managed by a soap context
        virtual _ns7__clearBreakpointsResponse *soap_alloc(void) const { return SOAP_NEW(_ns7__clearBreakpointsResponse); }
      public:
        /// Constructor with initializations
        _ns7__clearBreakpointsResponse() : out(), soap() { }
        virtual ~_ns7__clearBreakpointsResponse() { }
        /// Friend allocator used by soap_new__ns7__clearBreakpointsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns7__clearBreakpointsResponse * SOAP_FMAC2 soap_instantiate__ns7__clearBreakpointsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:438 */
#ifndef SOAP_TYPE__ns7__clearAllBreakpoints
#define SOAP_TYPE__ns7__clearAllBreakpoints (105)
/* complex XSD type 'ns7:clearAllBreakpoints': */
class SOAP_CMAC _ns7__clearAllBreakpoints {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__clearAllBreakpoints
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__clearAllBreakpoints; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__clearAllBreakpoints, default initialized and not managed by a soap context
        virtual _ns7__clearAllBreakpoints *soap_alloc(void) const { return SOAP_NEW(_ns7__clearAllBreakpoints); }
      public:
        /// Constructor with initializations
        _ns7__clearAllBreakpoints() : soap() { }
        virtual ~_ns7__clearAllBreakpoints() { }
        /// Friend allocator used by soap_new__ns7__clearAllBreakpoints(struct soap*, int)
        friend SOAP_FMAC1 _ns7__clearAllBreakpoints * SOAP_FMAC2 soap_instantiate__ns7__clearAllBreakpoints(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:441 */
#ifndef SOAP_TYPE__ns7__clearAllBreakpointsResponse
#define SOAP_TYPE__ns7__clearAllBreakpointsResponse (106)
/* complex XSD type 'ns7:clearAllBreakpointsResponse': */
class SOAP_CMAC _ns7__clearAllBreakpointsResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__clearAllBreakpointsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__clearAllBreakpointsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__clearAllBreakpointsResponse, default initialized and not managed by a soap context
        virtual _ns7__clearAllBreakpointsResponse *soap_alloc(void) const { return SOAP_NEW(_ns7__clearAllBreakpointsResponse); }
      public:
        /// Constructor with initializations
        _ns7__clearAllBreakpointsResponse() : soap() { }
        virtual ~_ns7__clearAllBreakpointsResponse() { }
        /// Friend allocator used by soap_new__ns7__clearAllBreakpointsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns7__clearAllBreakpointsResponse * SOAP_FMAC2 soap_instantiate__ns7__clearAllBreakpointsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:444 */
#ifndef SOAP_TYPE__ns7__getTasks
#define SOAP_TYPE__ns7__getTasks (107)
/* complex XSD type 'ns7:getTasks': */
class SOAP_CMAC _ns7__getTasks {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__getTasks
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__getTasks; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__getTasks, default initialized and not managed by a soap context
        virtual _ns7__getTasks *soap_alloc(void) const { return SOAP_NEW(_ns7__getTasks); }
      public:
        /// Constructor with initializations
        _ns7__getTasks() : soap() { }
        virtual ~_ns7__getTasks() { }
        /// Friend allocator used by soap_new__ns7__getTasks(struct soap*, int)
        friend SOAP_FMAC1 _ns7__getTasks * SOAP_FMAC2 soap_instantiate__ns7__getTasks(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:447 */
#ifndef SOAP_TYPE__ns7__getTasksResponse
#define SOAP_TYPE__ns7__getTasksResponse (108)
/* complex XSD type 'ns7:getTasksResponse': */
class SOAP_CMAC _ns7__getTasksResponse {
      public:
        /// Required element 'tasks' of XSD type 'ns7:SoapTasks'
        ns7__SoapTasks *tasks;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__getTasksResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__getTasksResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__getTasksResponse, default initialized and not managed by a soap context
        virtual _ns7__getTasksResponse *soap_alloc(void) const { return SOAP_NEW(_ns7__getTasksResponse); }
      public:
        /// Constructor with initializations
        _ns7__getTasksResponse() : tasks(), soap() { }
        virtual ~_ns7__getTasksResponse() { }
        /// Friend allocator used by soap_new__ns7__getTasksResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns7__getTasksResponse * SOAP_FMAC2 soap_instantiate__ns7__getTasksResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:450 */
#ifndef SOAP_TYPE__ns7__taskSuspend
#define SOAP_TYPE__ns7__taskSuspend (109)
/* complex XSD type 'ns7:taskSuspend': */
class SOAP_CMAC _ns7__taskSuspend {
      public:
        /// Optional element 'taskName' of XSD type 'xsd:string'
        std::string *taskName;
        /// Optional element 'createdBy' of XSD type 'xsd:string'
        std::string *createdBy;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__taskSuspend
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__taskSuspend; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__taskSuspend, default initialized and not managed by a soap context
        virtual _ns7__taskSuspend *soap_alloc(void) const { return SOAP_NEW(_ns7__taskSuspend); }
      public:
        /// Constructor with initializations
        _ns7__taskSuspend() : taskName(), createdBy(), soap() { }
        virtual ~_ns7__taskSuspend() { }
        /// Friend allocator used by soap_new__ns7__taskSuspend(struct soap*, int)
        friend SOAP_FMAC1 _ns7__taskSuspend * SOAP_FMAC2 soap_instantiate__ns7__taskSuspend(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:453 */
#ifndef SOAP_TYPE__ns7__taskSuspendResponse
#define SOAP_TYPE__ns7__taskSuspendResponse (110)
/* complex XSD type 'ns7:taskSuspendResponse': */
class SOAP_CMAC _ns7__taskSuspendResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__taskSuspendResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__taskSuspendResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__taskSuspendResponse, default initialized and not managed by a soap context
        virtual _ns7__taskSuspendResponse *soap_alloc(void) const { return SOAP_NEW(_ns7__taskSuspendResponse); }
      public:
        /// Constructor with initializations
        _ns7__taskSuspendResponse() : soap() { }
        virtual ~_ns7__taskSuspendResponse() { }
        /// Friend allocator used by soap_new__ns7__taskSuspendResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns7__taskSuspendResponse * SOAP_FMAC2 soap_instantiate__ns7__taskSuspendResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:456 */
#ifndef SOAP_TYPE__ns7__taskResume
#define SOAP_TYPE__ns7__taskResume (111)
/* complex XSD type 'ns7:taskResume': */
class SOAP_CMAC _ns7__taskResume {
      public:
        /// Optional element 'taskName' of XSD type 'xsd:string'
        std::string *taskName;
        /// Optional element 'createdBy' of XSD type 'xsd:string'
        std::string *createdBy;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__taskResume
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__taskResume; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__taskResume, default initialized and not managed by a soap context
        virtual _ns7__taskResume *soap_alloc(void) const { return SOAP_NEW(_ns7__taskResume); }
      public:
        /// Constructor with initializations
        _ns7__taskResume() : taskName(), createdBy(), soap() { }
        virtual ~_ns7__taskResume() { }
        /// Friend allocator used by soap_new__ns7__taskResume(struct soap*, int)
        friend SOAP_FMAC1 _ns7__taskResume * SOAP_FMAC2 soap_instantiate__ns7__taskResume(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:459 */
#ifndef SOAP_TYPE__ns7__taskResumeResponse
#define SOAP_TYPE__ns7__taskResumeResponse (112)
/* complex XSD type 'ns7:taskResumeResponse': */
class SOAP_CMAC _ns7__taskResumeResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__taskResumeResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__taskResumeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__taskResumeResponse, default initialized and not managed by a soap context
        virtual _ns7__taskResumeResponse *soap_alloc(void) const { return SOAP_NEW(_ns7__taskResumeResponse); }
      public:
        /// Constructor with initializations
        _ns7__taskResumeResponse() : soap() { }
        virtual ~_ns7__taskResumeResponse() { }
        /// Friend allocator used by soap_new__ns7__taskResumeResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns7__taskResumeResponse * SOAP_FMAC2 soap_instantiate__ns7__taskResumeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:462 */
#ifndef SOAP_TYPE__ns7__taskKill
#define SOAP_TYPE__ns7__taskKill (113)
/* complex XSD type 'ns7:taskKill': */
class SOAP_CMAC _ns7__taskKill {
      public:
        /// Optional element 'taskName' of XSD type 'xsd:string'
        std::string *taskName;
        /// Optional element 'createdBy' of XSD type 'xsd:string'
        std::string *createdBy;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__taskKill
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__taskKill; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__taskKill, default initialized and not managed by a soap context
        virtual _ns7__taskKill *soap_alloc(void) const { return SOAP_NEW(_ns7__taskKill); }
      public:
        /// Constructor with initializations
        _ns7__taskKill() : taskName(), createdBy(), soap() { }
        virtual ~_ns7__taskKill() { }
        /// Friend allocator used by soap_new__ns7__taskKill(struct soap*, int)
        friend SOAP_FMAC1 _ns7__taskKill * SOAP_FMAC2 soap_instantiate__ns7__taskKill(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:465 */
#ifndef SOAP_TYPE__ns7__taskKillResponse
#define SOAP_TYPE__ns7__taskKillResponse (114)
/* complex XSD type 'ns7:taskKillResponse': */
class SOAP_CMAC _ns7__taskKillResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__taskKillResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__taskKillResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__taskKillResponse, default initialized and not managed by a soap context
        virtual _ns7__taskKillResponse *soap_alloc(void) const { return SOAP_NEW(_ns7__taskKillResponse); }
      public:
        /// Constructor with initializations
        _ns7__taskKillResponse() : soap() { }
        virtual ~_ns7__taskKillResponse() { }
        /// Friend allocator used by soap_new__ns7__taskKillResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns7__taskKillResponse * SOAP_FMAC2 soap_instantiate__ns7__taskKillResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:468 */
#ifndef SOAP_TYPE__ns7__taskStep
#define SOAP_TYPE__ns7__taskStep (115)
/* complex XSD type 'ns7:taskStep': */
class SOAP_CMAC _ns7__taskStep {
      public:
        /// Optional element 'taskName' of XSD type 'xsd:string'
        std::string *taskName;
        /// Optional element 'createdBy' of XSD type 'xsd:string'
        std::string *createdBy;
        /// Required element 'stepType' of XSD type 'ns7:SoapTaskStep'
        enum ns7__SoapTaskStep stepType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__taskStep
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__taskStep; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__taskStep, default initialized and not managed by a soap context
        virtual _ns7__taskStep *soap_alloc(void) const { return SOAP_NEW(_ns7__taskStep); }
      public:
        /// Constructor with initializations
        _ns7__taskStep() : taskName(), createdBy(), stepType(), soap() { }
        virtual ~_ns7__taskStep() { }
        /// Friend allocator used by soap_new__ns7__taskStep(struct soap*, int)
        friend SOAP_FMAC1 _ns7__taskStep * SOAP_FMAC2 soap_instantiate__ns7__taskStep(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:471 */
#ifndef SOAP_TYPE__ns7__taskStepResponse
#define SOAP_TYPE__ns7__taskStepResponse (116)
/* complex XSD type 'ns7:taskStepResponse': */
class SOAP_CMAC _ns7__taskStepResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__taskStepResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__taskStepResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__taskStepResponse, default initialized and not managed by a soap context
        virtual _ns7__taskStepResponse *soap_alloc(void) const { return SOAP_NEW(_ns7__taskStepResponse); }
      public:
        /// Constructor with initializations
        _ns7__taskStepResponse() : soap() { }
        virtual ~_ns7__taskStepResponse() { }
        /// Friend allocator used by soap_new__ns7__taskStepResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns7__taskStepResponse * SOAP_FMAC2 soap_instantiate__ns7__taskStepResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:474 */
#ifndef SOAP_TYPE__ns7__subscribeToControllerEvents
#define SOAP_TYPE__ns7__subscribeToControllerEvents (117)
/* complex XSD type 'ns7:subscribeToControllerEvents': */
class SOAP_CMAC _ns7__subscribeToControllerEvents {
      public:
        /// Optional element 'serviceUrl' of XSD type 'xsd:string'
        std::string *serviceUrl;
        /// Required element 'sendInterval' of XSD type 'xsd:int'
        int sendInterval;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__subscribeToControllerEvents
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__subscribeToControllerEvents; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__subscribeToControllerEvents, default initialized and not managed by a soap context
        virtual _ns7__subscribeToControllerEvents *soap_alloc(void) const { return SOAP_NEW(_ns7__subscribeToControllerEvents); }
      public:
        /// Constructor with initializations
        _ns7__subscribeToControllerEvents() : serviceUrl(), sendInterval(), soap() { }
        virtual ~_ns7__subscribeToControllerEvents() { }
        /// Friend allocator used by soap_new__ns7__subscribeToControllerEvents(struct soap*, int)
        friend SOAP_FMAC1 _ns7__subscribeToControllerEvents * SOAP_FMAC2 soap_instantiate__ns7__subscribeToControllerEvents(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:477 */
#ifndef SOAP_TYPE__ns7__subscribeResponse
#define SOAP_TYPE__ns7__subscribeResponse (118)
/* complex XSD type 'ns7:subscribeResponse': */
class SOAP_CMAC _ns7__subscribeResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__subscribeResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__subscribeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__subscribeResponse, default initialized and not managed by a soap context
        virtual _ns7__subscribeResponse *soap_alloc(void) const { return SOAP_NEW(_ns7__subscribeResponse); }
      public:
        /// Constructor with initializations
        _ns7__subscribeResponse() : soap() { }
        virtual ~_ns7__subscribeResponse() { }
        /// Friend allocator used by soap_new__ns7__subscribeResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns7__subscribeResponse * SOAP_FMAC2 soap_instantiate__ns7__subscribeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:480 */
#ifndef SOAP_TYPE__ns7__unsubscribeToControllerEvents
#define SOAP_TYPE__ns7__unsubscribeToControllerEvents (119)
/* complex XSD type 'ns7:unsubscribeToControllerEvents': */
class SOAP_CMAC _ns7__unsubscribeToControllerEvents {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__unsubscribeToControllerEvents
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__unsubscribeToControllerEvents; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__unsubscribeToControllerEvents, default initialized and not managed by a soap context
        virtual _ns7__unsubscribeToControllerEvents *soap_alloc(void) const { return SOAP_NEW(_ns7__unsubscribeToControllerEvents); }
      public:
        /// Constructor with initializations
        _ns7__unsubscribeToControllerEvents() : soap() { }
        virtual ~_ns7__unsubscribeToControllerEvents() { }
        /// Friend allocator used by soap_new__ns7__unsubscribeToControllerEvents(struct soap*, int)
        friend SOAP_FMAC1 _ns7__unsubscribeToControllerEvents * SOAP_FMAC2 soap_instantiate__ns7__unsubscribeToControllerEvents(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:483 */
#ifndef SOAP_TYPE__ns7__unsubscribeResponse
#define SOAP_TYPE__ns7__unsubscribeResponse (120)
/* complex XSD type 'ns7:unsubscribeResponse': */
class SOAP_CMAC _ns7__unsubscribeResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__unsubscribeResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__unsubscribeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__unsubscribeResponse, default initialized and not managed by a soap context
        virtual _ns7__unsubscribeResponse *soap_alloc(void) const { return SOAP_NEW(_ns7__unsubscribeResponse); }
      public:
        /// Constructor with initializations
        _ns7__unsubscribeResponse() : soap() { }
        virtual ~_ns7__unsubscribeResponse() { }
        /// Friend allocator used by soap_new__ns7__unsubscribeResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns7__unsubscribeResponse * SOAP_FMAC2 soap_instantiate__ns7__unsubscribeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:486 */
#ifndef SOAP_TYPE__ns7__getCallStack
#define SOAP_TYPE__ns7__getCallStack (121)
/* complex XSD type 'ns7:getCallStack': */
class SOAP_CMAC _ns7__getCallStack {
      public:
        /// Optional element 'taskName' of XSD type 'xsd:string'
        std::string *taskName;
        /// Optional element 'createdBy' of XSD type 'xsd:string'
        std::string *createdBy;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__getCallStack
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__getCallStack; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__getCallStack, default initialized and not managed by a soap context
        virtual _ns7__getCallStack *soap_alloc(void) const { return SOAP_NEW(_ns7__getCallStack); }
      public:
        /// Constructor with initializations
        _ns7__getCallStack() : taskName(), createdBy(), soap() { }
        virtual ~_ns7__getCallStack() { }
        /// Friend allocator used by soap_new__ns7__getCallStack(struct soap*, int)
        friend SOAP_FMAC1 _ns7__getCallStack * SOAP_FMAC2 soap_instantiate__ns7__getCallStack(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:489 */
#ifndef SOAP_TYPE__ns7__getCallStackResponse
#define SOAP_TYPE__ns7__getCallStackResponse (122)
/* complex XSD type 'ns7:getCallStackResponse': */
class SOAP_CMAC _ns7__getCallStackResponse {
      public:
        /// Required element 'callStack' of XSD type 'ns7:SoapCallStack'
        ns7__SoapCallStack *callStack;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__getCallStackResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__getCallStackResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__getCallStackResponse, default initialized and not managed by a soap context
        virtual _ns7__getCallStackResponse *soap_alloc(void) const { return SOAP_NEW(_ns7__getCallStackResponse); }
      public:
        /// Constructor with initializations
        _ns7__getCallStackResponse() : callStack(), soap() { }
        virtual ~_ns7__getCallStackResponse() { }
        /// Friend allocator used by soap_new__ns7__getCallStackResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns7__getCallStackResponse * SOAP_FMAC2 soap_instantiate__ns7__getCallStackResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:492 */
#ifndef SOAP_TYPE__ns7__getStackFrame
#define SOAP_TYPE__ns7__getStackFrame (123)
/* complex XSD type 'ns7:getStackFrame': */
class SOAP_CMAC _ns7__getStackFrame {
      public:
        /// Optional element 'taskName' of XSD type 'xsd:string'
        std::string *taskName;
        /// Optional element 'createdBy' of XSD type 'xsd:string'
        std::string *createdBy;
        /// Required element 'stackFrameIndex' of XSD type 'xsd:int'
        int stackFrameIndex;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__getStackFrame
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__getStackFrame; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__getStackFrame, default initialized and not managed by a soap context
        virtual _ns7__getStackFrame *soap_alloc(void) const { return SOAP_NEW(_ns7__getStackFrame); }
      public:
        /// Constructor with initializations
        _ns7__getStackFrame() : taskName(), createdBy(), stackFrameIndex(), soap() { }
        virtual ~_ns7__getStackFrame() { }
        /// Friend allocator used by soap_new__ns7__getStackFrame(struct soap*, int)
        friend SOAP_FMAC1 _ns7__getStackFrame * SOAP_FMAC2 soap_instantiate__ns7__getStackFrame(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:495 */
#ifndef SOAP_TYPE__ns7__getStackFrameResponse
#define SOAP_TYPE__ns7__getStackFrameResponse (124)
/* complex XSD type 'ns7:getStackFrameResponse': */
class SOAP_CMAC _ns7__getStackFrameResponse {
      public:
        /// Required element 'data' of XSD type 'ns7:MimeData'
        ns7__MimeData *data;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__getStackFrameResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__getStackFrameResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__getStackFrameResponse, default initialized and not managed by a soap context
        virtual _ns7__getStackFrameResponse *soap_alloc(void) const { return SOAP_NEW(_ns7__getStackFrameResponse); }
      public:
        /// Constructor with initializations
        _ns7__getStackFrameResponse() : data(), soap() { }
        virtual ~_ns7__getStackFrameResponse() { }
        /// Friend allocator used by soap_new__ns7__getStackFrameResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns7__getStackFrameResponse * SOAP_FMAC2 soap_instantiate__ns7__getStackFrameResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:498 */
#ifndef SOAP_TYPE__ns7__getWatches
#define SOAP_TYPE__ns7__getWatches (125)
/* complex XSD type 'ns7:getWatches': */
class SOAP_CMAC _ns7__getWatches {
      public:
        /// Required element 'watch' of XSD type 'ns7:SoapWatches'
        ns7__SoapWatches *watch;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__getWatches
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__getWatches; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__getWatches, default initialized and not managed by a soap context
        virtual _ns7__getWatches *soap_alloc(void) const { return SOAP_NEW(_ns7__getWatches); }
      public:
        /// Constructor with initializations
        _ns7__getWatches() : watch(), soap() { }
        virtual ~_ns7__getWatches() { }
        /// Friend allocator used by soap_new__ns7__getWatches(struct soap*, int)
        friend SOAP_FMAC1 _ns7__getWatches * SOAP_FMAC2 soap_instantiate__ns7__getWatches(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:501 */
#ifndef SOAP_TYPE__ns7__getWatchResponse
#define SOAP_TYPE__ns7__getWatchResponse (126)
/* complex XSD type 'ns7:getWatchResponse': */
class SOAP_CMAC _ns7__getWatchResponse {
      public:
        /// Required element 'data' of XSD type 'ns7:MimeData'
        ns7__MimeData *data;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__getWatchResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__getWatchResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__getWatchResponse, default initialized and not managed by a soap context
        virtual _ns7__getWatchResponse *soap_alloc(void) const { return SOAP_NEW(_ns7__getWatchResponse); }
      public:
        /// Constructor with initializations
        _ns7__getWatchResponse() : data(), soap() { }
        virtual ~_ns7__getWatchResponse() { }
        /// Friend allocator used by soap_new__ns7__getWatchResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns7__getWatchResponse * SOAP_FMAC2 soap_instantiate__ns7__getWatchResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:504 */
#ifndef SOAP_TYPE__ns7__execVal3
#define SOAP_TYPE__ns7__execVal3 (127)
/* complex XSD type 'ns7:execVal3': */
class SOAP_CMAC _ns7__execVal3 {
      public:
        /// Optional element 'prjName' of XSD type 'xsd:string'
        std::string *prjName;
        /// Optional element 'taskName' of XSD type 'xsd:string'
        std::string *taskName;
        /// Optional element 'createdBy' of XSD type 'xsd:string'
        std::string *createdBy;
        /// Required element 'stackFrameIndex' of XSD type 'xsd:int'
        int stackFrameIndex;
        /// Optional element 'cmd' of XSD type 'xsd:string'
        std::string *cmd;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__execVal3
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__execVal3; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__execVal3, default initialized and not managed by a soap context
        virtual _ns7__execVal3 *soap_alloc(void) const { return SOAP_NEW(_ns7__execVal3); }
      public:
        /// Constructor with initializations
        _ns7__execVal3() : prjName(), taskName(), createdBy(), stackFrameIndex(), cmd(), soap() { }
        virtual ~_ns7__execVal3() { }
        /// Friend allocator used by soap_new__ns7__execVal3(struct soap*, int)
        friend SOAP_FMAC1 _ns7__execVal3 * SOAP_FMAC2 soap_instantiate__ns7__execVal3(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:507 */
#ifndef SOAP_TYPE__ns7__execVal3Response
#define SOAP_TYPE__ns7__execVal3Response (128)
/* complex XSD type 'ns7:execVal3Response': */
class SOAP_CMAC _ns7__execVal3Response {
      public:
        /// Required element 'retCode' of XSD type 'ns7:execVal3ReturnCode'
        enum ns7__execVal3ReturnCode retCode;
        /// Optional element 'strOut' of XSD type 'xsd:string'
        std::string *strOut;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__execVal3Response
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__execVal3Response; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__execVal3Response, default initialized and not managed by a soap context
        virtual _ns7__execVal3Response *soap_alloc(void) const { return SOAP_NEW(_ns7__execVal3Response); }
      public:
        /// Constructor with initializations
        _ns7__execVal3Response() : retCode(), strOut(), soap() { }
        virtual ~_ns7__execVal3Response() { }
        /// Friend allocator used by soap_new__ns7__execVal3Response(struct soap*, int)
        friend SOAP_FMAC1 _ns7__execVal3Response * SOAP_FMAC2 soap_instantiate__ns7__execVal3Response(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:510 */
#ifndef SOAP_TYPE__ns7__setProjectAsModified
#define SOAP_TYPE__ns7__setProjectAsModified (129)
/* complex XSD type 'ns7:setProjectAsModified': */
class SOAP_CMAC _ns7__setProjectAsModified {
      public:
        /// Optional element 'prjName' of XSD type 'xsd:string'
        std::string *prjName;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__setProjectAsModified
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__setProjectAsModified; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__setProjectAsModified, default initialized and not managed by a soap context
        virtual _ns7__setProjectAsModified *soap_alloc(void) const { return SOAP_NEW(_ns7__setProjectAsModified); }
      public:
        /// Constructor with initializations
        _ns7__setProjectAsModified() : prjName(), soap() { }
        virtual ~_ns7__setProjectAsModified() { }
        /// Friend allocator used by soap_new__ns7__setProjectAsModified(struct soap*, int)
        friend SOAP_FMAC1 _ns7__setProjectAsModified * SOAP_FMAC2 soap_instantiate__ns7__setProjectAsModified(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:513 */
#ifndef SOAP_TYPE__ns7__setProjectAsModifiedResponse
#define SOAP_TYPE__ns7__setProjectAsModifiedResponse (130)
/* complex XSD type 'ns7:setProjectAsModifiedResponse': */
class SOAP_CMAC _ns7__setProjectAsModifiedResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__setProjectAsModifiedResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__setProjectAsModifiedResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__setProjectAsModifiedResponse, default initialized and not managed by a soap context
        virtual _ns7__setProjectAsModifiedResponse *soap_alloc(void) const { return SOAP_NEW(_ns7__setProjectAsModifiedResponse); }
      public:
        /// Constructor with initializations
        _ns7__setProjectAsModifiedResponse() : soap() { }
        virtual ~_ns7__setProjectAsModifiedResponse() { }
        /// Friend allocator used by soap_new__ns7__setProjectAsModifiedResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns7__setProjectAsModifiedResponse * SOAP_FMAC2 soap_instantiate__ns7__setProjectAsModifiedResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:516 */
#ifndef SOAP_TYPE__ns7__setCurrentInstruction
#define SOAP_TYPE__ns7__setCurrentInstruction (131)
/* complex XSD type 'ns7:setCurrentInstruction': */
class SOAP_CMAC _ns7__setCurrentInstruction {
      public:
        /// Optional element 'taskName' of XSD type 'xsd:string'
        std::string *taskName;
        /// Optional element 'createdBy' of XSD type 'xsd:string'
        std::string *createdBy;
        /// Required element 'resetMotion' of XSD type 'xsd:boolean'
        bool resetMotion;
        /// Required element 'line' of XSD type 'ns7:SoapProgramLine'
        ns7__SoapProgramLine *line;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__setCurrentInstruction
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__setCurrentInstruction; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__setCurrentInstruction, default initialized and not managed by a soap context
        virtual _ns7__setCurrentInstruction *soap_alloc(void) const { return SOAP_NEW(_ns7__setCurrentInstruction); }
      public:
        /// Constructor with initializations
        _ns7__setCurrentInstruction() : taskName(), createdBy(), resetMotion(), line(), soap() { }
        virtual ~_ns7__setCurrentInstruction() { }
        /// Friend allocator used by soap_new__ns7__setCurrentInstruction(struct soap*, int)
        friend SOAP_FMAC1 _ns7__setCurrentInstruction * SOAP_FMAC2 soap_instantiate__ns7__setCurrentInstruction(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:519 */
#ifndef SOAP_TYPE__ns7__setCurrentInstructionResponse
#define SOAP_TYPE__ns7__setCurrentInstructionResponse (132)
/* complex XSD type 'ns7:setCurrentInstructionResponse': */
class SOAP_CMAC _ns7__setCurrentInstructionResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__setCurrentInstructionResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__setCurrentInstructionResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__setCurrentInstructionResponse, default initialized and not managed by a soap context
        virtual _ns7__setCurrentInstructionResponse *soap_alloc(void) const { return SOAP_NEW(_ns7__setCurrentInstructionResponse); }
      public:
        /// Constructor with initializations
        _ns7__setCurrentInstructionResponse() : soap() { }
        virtual ~_ns7__setCurrentInstructionResponse() { }
        /// Friend allocator used by soap_new__ns7__setCurrentInstructionResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns7__setCurrentInstructionResponse * SOAP_FMAC2 soap_instantiate__ns7__setCurrentInstructionResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:522 */
#ifndef SOAP_TYPE__ns7__replaceLine
#define SOAP_TYPE__ns7__replaceLine (133)
/* complex XSD type 'ns7:replaceLine': */
class SOAP_CMAC _ns7__replaceLine {
      public:
        /// Required element 'line' of XSD type 'ns7:SoapProgramLine'
        ns7__SoapProgramLine *line;
        /// Optional element 'newLine' of XSD type 'xsd:string'
        std::string *newLine;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__replaceLine
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__replaceLine; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__replaceLine, default initialized and not managed by a soap context
        virtual _ns7__replaceLine *soap_alloc(void) const { return SOAP_NEW(_ns7__replaceLine); }
      public:
        /// Constructor with initializations
        _ns7__replaceLine() : line(), newLine(), soap() { }
        virtual ~_ns7__replaceLine() { }
        /// Friend allocator used by soap_new__ns7__replaceLine(struct soap*, int)
        friend SOAP_FMAC1 _ns7__replaceLine * SOAP_FMAC2 soap_instantiate__ns7__replaceLine(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:525 */
#ifndef SOAP_TYPE__ns7__replaceLineResponse
#define SOAP_TYPE__ns7__replaceLineResponse (134)
/* complex XSD type 'ns7:replaceLineResponse': */
class SOAP_CMAC _ns7__replaceLineResponse {
      public:
        /// Required element 'retCode' of XSD type 'ns7:replaceLineReturnCode'
        enum ns7__replaceLineReturnCode retCode;
        /// Optional element 'strOut' of XSD type 'xsd:string'
        std::string *strOut;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__replaceLineResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__replaceLineResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__replaceLineResponse, default initialized and not managed by a soap context
        virtual _ns7__replaceLineResponse *soap_alloc(void) const { return SOAP_NEW(_ns7__replaceLineResponse); }
      public:
        /// Constructor with initializations
        _ns7__replaceLineResponse() : retCode(), strOut(), soap() { }
        virtual ~_ns7__replaceLineResponse() { }
        /// Friend allocator used by soap_new__ns7__replaceLineResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns7__replaceLineResponse * SOAP_FMAC2 soap_instantiate__ns7__replaceLineResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:528 */
#ifndef SOAP_TYPE__ns7__readIos
#define SOAP_TYPE__ns7__readIos (135)
/* complex XSD type 'ns7:readIos': */
class SOAP_CMAC _ns7__readIos {
      public:
        /// Required element 'ios' of XSD type 'ns7:SoapPhysicalIoLinks'
        ns7__SoapPhysicalIoLinks *ios;
        /// Required element 'x-getDescription' of XSD type 'xsd:boolean'
        bool x_getDescription;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__readIos
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__readIos; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__readIos, default initialized and not managed by a soap context
        virtual _ns7__readIos *soap_alloc(void) const { return SOAP_NEW(_ns7__readIos); }
      public:
        /// Constructor with initializations
        _ns7__readIos() : ios(), x_getDescription(), soap() { }
        virtual ~_ns7__readIos() { }
        /// Friend allocator used by soap_new__ns7__readIos(struct soap*, int)
        friend SOAP_FMAC1 _ns7__readIos * SOAP_FMAC2 soap_instantiate__ns7__readIos(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:531 */
#ifndef SOAP_TYPE__ns7__readIosResponse
#define SOAP_TYPE__ns7__readIosResponse (136)
/* complex XSD type 'ns7:readIosResponse': */
class SOAP_CMAC _ns7__readIosResponse {
      public:
        /// Required element 'state' of XSD type 'ns7:SoapPhysicalIosStates'
        ns7__SoapPhysicalIosStates *state;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__readIosResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__readIosResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__readIosResponse, default initialized and not managed by a soap context
        virtual _ns7__readIosResponse *soap_alloc(void) const { return SOAP_NEW(_ns7__readIosResponse); }
      public:
        /// Constructor with initializations
        _ns7__readIosResponse() : state(), soap() { }
        virtual ~_ns7__readIosResponse() { }
        /// Friend allocator used by soap_new__ns7__readIosResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns7__readIosResponse * SOAP_FMAC2 soap_instantiate__ns7__readIosResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:534 */
#ifndef SOAP_TYPE__ns7__writeIos
#define SOAP_TYPE__ns7__writeIos (137)
/* complex XSD type 'ns7:writeIos': */
class SOAP_CMAC _ns7__writeIos {
      public:
        /// Required element 'ios' of XSD type 'ns7:SoapPhysicalIoLinks'
        ns7__SoapPhysicalIoLinks *ios;
        /// Required element 'values' of XSD type 'ns7:SoapPhysicalIoValues'
        ns7__SoapPhysicalIoValues *values;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__writeIos
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__writeIos; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__writeIos, default initialized and not managed by a soap context
        virtual _ns7__writeIos *soap_alloc(void) const { return SOAP_NEW(_ns7__writeIos); }
      public:
        /// Constructor with initializations
        _ns7__writeIos() : ios(), values(), soap() { }
        virtual ~_ns7__writeIos() { }
        /// Friend allocator used by soap_new__ns7__writeIos(struct soap*, int)
        friend SOAP_FMAC1 _ns7__writeIos * SOAP_FMAC2 soap_instantiate__ns7__writeIos(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:537 */
#ifndef SOAP_TYPE__ns7__writeIosResponse
#define SOAP_TYPE__ns7__writeIosResponse (138)
/* complex XSD type 'ns7:writeIosResponse': */
class SOAP_CMAC _ns7__writeIosResponse {
      public:
        /// Required element 'out' of XSD type 'ns7:SoapPhysicalIoResponses'
        ns7__SoapPhysicalIoResponses *out;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__writeIosResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__writeIosResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__writeIosResponse, default initialized and not managed by a soap context
        virtual _ns7__writeIosResponse *soap_alloc(void) const { return SOAP_NEW(_ns7__writeIosResponse); }
      public:
        /// Constructor with initializations
        _ns7__writeIosResponse() : out(), soap() { }
        virtual ~_ns7__writeIosResponse() { }
        /// Friend allocator used by soap_new__ns7__writeIosResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns7__writeIosResponse * SOAP_FMAC2 soap_instantiate__ns7__writeIosResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:540 */
#ifndef SOAP_TYPE__ns7__lockIos
#define SOAP_TYPE__ns7__lockIos (139)
/* complex XSD type 'ns7:lockIos': */
class SOAP_CMAC _ns7__lockIos {
      public:
        /// Required element 'ios' of XSD type 'ns7:SoapPhysicalIoLinks'
        ns7__SoapPhysicalIoLinks *ios;
        /// Required element 'values' of XSD type 'ns7:SoapPhysicalIoValues'
        ns7__SoapPhysicalIoValues *values;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__lockIos
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__lockIos; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__lockIos, default initialized and not managed by a soap context
        virtual _ns7__lockIos *soap_alloc(void) const { return SOAP_NEW(_ns7__lockIos); }
      public:
        /// Constructor with initializations
        _ns7__lockIos() : ios(), values(), soap() { }
        virtual ~_ns7__lockIos() { }
        /// Friend allocator used by soap_new__ns7__lockIos(struct soap*, int)
        friend SOAP_FMAC1 _ns7__lockIos * SOAP_FMAC2 soap_instantiate__ns7__lockIos(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:543 */
#ifndef SOAP_TYPE__ns7__lockIosResponse
#define SOAP_TYPE__ns7__lockIosResponse (140)
/* complex XSD type 'ns7:lockIosResponse': */
class SOAP_CMAC _ns7__lockIosResponse {
      public:
        /// Required element 'out' of XSD type 'ns7:SoapPhysicalIoResponses'
        ns7__SoapPhysicalIoResponses *out;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__lockIosResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__lockIosResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__lockIosResponse, default initialized and not managed by a soap context
        virtual _ns7__lockIosResponse *soap_alloc(void) const { return SOAP_NEW(_ns7__lockIosResponse); }
      public:
        /// Constructor with initializations
        _ns7__lockIosResponse() : out(), soap() { }
        virtual ~_ns7__lockIosResponse() { }
        /// Friend allocator used by soap_new__ns7__lockIosResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns7__lockIosResponse * SOAP_FMAC2 soap_instantiate__ns7__lockIosResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:546 */
#ifndef SOAP_TYPE__ns7__unlockIos
#define SOAP_TYPE__ns7__unlockIos (141)
/* complex XSD type 'ns7:unlockIos': */
class SOAP_CMAC _ns7__unlockIos {
      public:
        /// Required element 'ios' of XSD type 'ns7:SoapPhysicalIoLinks'
        ns7__SoapPhysicalIoLinks *ios;
        /// Required element 'x-getDescription' of XSD type 'xsd:boolean'
        bool x_getDescription;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__unlockIos
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__unlockIos; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__unlockIos, default initialized and not managed by a soap context
        virtual _ns7__unlockIos *soap_alloc(void) const { return SOAP_NEW(_ns7__unlockIos); }
      public:
        /// Constructor with initializations
        _ns7__unlockIos() : ios(), x_getDescription(), soap() { }
        virtual ~_ns7__unlockIos() { }
        /// Friend allocator used by soap_new__ns7__unlockIos(struct soap*, int)
        friend SOAP_FMAC1 _ns7__unlockIos * SOAP_FMAC2 soap_instantiate__ns7__unlockIos(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:549 */
#ifndef SOAP_TYPE__ns7__unlockIosResponse
#define SOAP_TYPE__ns7__unlockIosResponse (142)
/* complex XSD type 'ns7:unlockIosResponse': */
class SOAP_CMAC _ns7__unlockIosResponse {
      public:
        /// Required element 'out' of XSD type 'ns7:SoapPhysicalIoUnlockResponses'
        ns7__SoapPhysicalIoUnlockResponses *out;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__unlockIosResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__unlockIosResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__unlockIosResponse, default initialized and not managed by a soap context
        virtual _ns7__unlockIosResponse *soap_alloc(void) const { return SOAP_NEW(_ns7__unlockIosResponse); }
      public:
        /// Constructor with initializations
        _ns7__unlockIosResponse() : out(), soap() { }
        virtual ~_ns7__unlockIosResponse() { }
        /// Friend allocator used by soap_new__ns7__unlockIosResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns7__unlockIosResponse * SOAP_FMAC2 soap_instantiate__ns7__unlockIosResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:552 */
#ifndef SOAP_TYPE__ns7__lockAllIos
#define SOAP_TYPE__ns7__lockAllIos (143)
/* complex XSD type 'ns7:lockAllIos': */
class SOAP_CMAC _ns7__lockAllIos {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__lockAllIos
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__lockAllIos; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__lockAllIos, default initialized and not managed by a soap context
        virtual _ns7__lockAllIos *soap_alloc(void) const { return SOAP_NEW(_ns7__lockAllIos); }
      public:
        /// Constructor with initializations
        _ns7__lockAllIos() : soap() { }
        virtual ~_ns7__lockAllIos() { }
        /// Friend allocator used by soap_new__ns7__lockAllIos(struct soap*, int)
        friend SOAP_FMAC1 _ns7__lockAllIos * SOAP_FMAC2 soap_instantiate__ns7__lockAllIos(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:555 */
#ifndef SOAP_TYPE__ns7__SoapAllPhysicalIoResponse
#define SOAP_TYPE__ns7__SoapAllPhysicalIoResponse (144)
/* complex XSD type 'ns7:SoapAllPhysicalIoResponse': */
class SOAP_CMAC _ns7__SoapAllPhysicalIoResponse {
      public:
        /// Required element 'nbSuccess' of XSD type 'xsd:int'
        int nbSuccess;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__SoapAllPhysicalIoResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__SoapAllPhysicalIoResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__SoapAllPhysicalIoResponse, default initialized and not managed by a soap context
        virtual _ns7__SoapAllPhysicalIoResponse *soap_alloc(void) const { return SOAP_NEW(_ns7__SoapAllPhysicalIoResponse); }
      public:
        /// Constructor with initializations
        _ns7__SoapAllPhysicalIoResponse() : nbSuccess(), soap() { }
        virtual ~_ns7__SoapAllPhysicalIoResponse() { }
        /// Friend allocator used by soap_new__ns7__SoapAllPhysicalIoResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns7__SoapAllPhysicalIoResponse * SOAP_FMAC2 soap_instantiate__ns7__SoapAllPhysicalIoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:558 */
#ifndef SOAP_TYPE__ns7__unlockAllIos
#define SOAP_TYPE__ns7__unlockAllIos (145)
/* complex XSD type 'ns7:unlockAllIos': */
class SOAP_CMAC _ns7__unlockAllIos {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__unlockAllIos
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__unlockAllIos; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__unlockAllIos, default initialized and not managed by a soap context
        virtual _ns7__unlockAllIos *soap_alloc(void) const { return SOAP_NEW(_ns7__unlockAllIos); }
      public:
        /// Constructor with initializations
        _ns7__unlockAllIos() : soap() { }
        virtual ~_ns7__unlockAllIos() { }
        /// Friend allocator used by soap_new__ns7__unlockAllIos(struct soap*, int)
        friend SOAP_FMAC1 _ns7__unlockAllIos * SOAP_FMAC2 soap_instantiate__ns7__unlockAllIos(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:561 */
#ifndef SOAP_TYPE__ns7__getAllPhysicalIos
#define SOAP_TYPE__ns7__getAllPhysicalIos (146)
/* complex XSD type 'ns7:getAllPhysicalIos': */
class SOAP_CMAC _ns7__getAllPhysicalIos {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__getAllPhysicalIos
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__getAllPhysicalIos; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__getAllPhysicalIos, default initialized and not managed by a soap context
        virtual _ns7__getAllPhysicalIos *soap_alloc(void) const { return SOAP_NEW(_ns7__getAllPhysicalIos); }
      public:
        /// Constructor with initializations
        _ns7__getAllPhysicalIos() : soap() { }
        virtual ~_ns7__getAllPhysicalIos() { }
        /// Friend allocator used by soap_new__ns7__getAllPhysicalIos(struct soap*, int)
        friend SOAP_FMAC1 _ns7__getAllPhysicalIos * SOAP_FMAC2 soap_instantiate__ns7__getAllPhysicalIos(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:564 */
#ifndef SOAP_TYPE__ns7__getAllPhysicalIosResponse
#define SOAP_TYPE__ns7__getAllPhysicalIosResponse (147)
/* complex XSD type 'ns7:getAllPhysicalIosResponse': */
class SOAP_CMAC _ns7__getAllPhysicalIosResponse {
      public:
        /// Required element 'data' of XSD type 'ns7:MimeData'
        ns7__MimeData *data;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__getAllPhysicalIosResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__getAllPhysicalIosResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__getAllPhysicalIosResponse, default initialized and not managed by a soap context
        virtual _ns7__getAllPhysicalIosResponse *soap_alloc(void) const { return SOAP_NEW(_ns7__getAllPhysicalIosResponse); }
      public:
        /// Constructor with initializations
        _ns7__getAllPhysicalIosResponse() : data(), soap() { }
        virtual ~_ns7__getAllPhysicalIosResponse() { }
        /// Friend allocator used by soap_new__ns7__getAllPhysicalIosResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns7__getAllPhysicalIosResponse * SOAP_FMAC2 soap_instantiate__ns7__getAllPhysicalIosResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:567 */
#ifndef SOAP_TYPE__ns7__getRobotDhParameters
#define SOAP_TYPE__ns7__getRobotDhParameters (148)
/* complex XSD type 'ns7:getRobotDhParameters': */
class SOAP_CMAC _ns7__getRobotDhParameters {
      public:
        /// Required element 'robot' of XSD type 'xsd:int'
        int robot;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__getRobotDhParameters
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__getRobotDhParameters; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__getRobotDhParameters, default initialized and not managed by a soap context
        virtual _ns7__getRobotDhParameters *soap_alloc(void) const { return SOAP_NEW(_ns7__getRobotDhParameters); }
      public:
        /// Constructor with initializations
        _ns7__getRobotDhParameters() : robot(), soap() { }
        virtual ~_ns7__getRobotDhParameters() { }
        /// Friend allocator used by soap_new__ns7__getRobotDhParameters(struct soap*, int)
        friend SOAP_FMAC1 _ns7__getRobotDhParameters * SOAP_FMAC2 soap_instantiate__ns7__getRobotDhParameters(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:570 */
#ifndef SOAP_TYPE__ns7__SoapRobotDhParameters
#define SOAP_TYPE__ns7__SoapRobotDhParameters (149)
/* complex XSD type 'ns7:SoapRobotDhParameters': */
class SOAP_CMAC _ns7__SoapRobotDhParameters {
      public:
        /// Required element 'dhParametersArray' of XSD type 'ns7:SoapDhParametersArray'
        ns7__SoapDhParametersArray *dhParametersArray;
        /// Required element 'lastDParam' of XSD type 'xsd:double'
        double lastDParam;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__SoapRobotDhParameters
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__SoapRobotDhParameters; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__SoapRobotDhParameters, default initialized and not managed by a soap context
        virtual _ns7__SoapRobotDhParameters *soap_alloc(void) const { return SOAP_NEW(_ns7__SoapRobotDhParameters); }
      public:
        /// Constructor with initializations
        _ns7__SoapRobotDhParameters() : dhParametersArray(), lastDParam(), soap() { }
        virtual ~_ns7__SoapRobotDhParameters() { }
        /// Friend allocator used by soap_new__ns7__SoapRobotDhParameters(struct soap*, int)
        friend SOAP_FMAC1 _ns7__SoapRobotDhParameters * SOAP_FMAC2 soap_instantiate__ns7__SoapRobotDhParameters(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:573 */
#ifndef SOAP_TYPE__ns7__getProject
#define SOAP_TYPE__ns7__getProject (150)
/* complex XSD type 'ns7:getProject': */
class SOAP_CMAC _ns7__getProject {
      public:
        /// Optional element 'name' of XSD type 'xsd:string'
        std::string *name;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__getProject
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__getProject; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__getProject, default initialized and not managed by a soap context
        virtual _ns7__getProject *soap_alloc(void) const { return SOAP_NEW(_ns7__getProject); }
      public:
        /// Constructor with initializations
        _ns7__getProject() : name(), soap() { }
        virtual ~_ns7__getProject() { }
        /// Friend allocator used by soap_new__ns7__getProject(struct soap*, int)
        friend SOAP_FMAC1 _ns7__getProject * SOAP_FMAC2 soap_instantiate__ns7__getProject(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:576 */
#ifndef SOAP_TYPE__ns7__getProjectResponse
#define SOAP_TYPE__ns7__getProjectResponse (151)
/* complex XSD type 'ns7:getProjectResponse': */
class SOAP_CMAC _ns7__getProjectResponse {
      public:
        /// Required element 'data' of XSD type 'xsd:base64Binary'
        xsd__base64Binary data;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns7__getProjectResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns7__getProjectResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns7__getProjectResponse, default initialized and not managed by a soap context
        virtual _ns7__getProjectResponse *soap_alloc(void) const { return SOAP_NEW(_ns7__getProjectResponse); }
      public:
        /// Constructor with initializations
        _ns7__getProjectResponse() : data(), soap() { }
        virtual ~_ns7__getProjectResponse() { }
        /// Friend allocator used by soap_new__ns7__getProjectResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns7__getProjectResponse * SOAP_FMAC2 soap_instantiate__ns7__getProjectResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:579 */
#ifndef SOAP_TYPE_ns3__Include
#define SOAP_TYPE_ns3__Include (152)
/* complex XSD type 'ns3:Include': */
class SOAP_CMAC ns3__Include {
      public:
        std::vector<char *> __any;
        /// required attribute 'href' of XSD type 'xsd:anyURI'
        std::string href;
        /// optional attribute '-anyAttribute' of XSD type 'xsd:anyType'
        char *__anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__Include
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__Include; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__Include, default initialized and not managed by a soap context
        virtual ns3__Include *soap_alloc(void) const { return SOAP_NEW(ns3__Include); }
      public:
        /// Constructor with initializations
        ns3__Include() : __any(), href(), __anyAttribute(), soap() { }
        virtual ~ns3__Include() { }
        /// Friend allocator used by soap_new_ns3__Include(struct soap*, int)
        friend SOAP_FMAC1 ns3__Include * SOAP_FMAC2 soap_instantiate_ns3__Include(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:582 */
#ifndef SOAP_TYPE_ns2__VALApplication
#define SOAP_TYPE_ns2__VALApplication (153)
/* complex XSD type 'ns2:VALApplication': */
class SOAP_CMAC ns2__VALApplication {
      public:
        /// Optional element 'name' of XSD type 'xsd:string'
        std::string *name;
        /// Required element 'loaded' of XSD type 'xsd:boolean'
        bool loaded;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__VALApplication
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__VALApplication; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__VALApplication, default initialized and not managed by a soap context
        virtual ns2__VALApplication *soap_alloc(void) const { return SOAP_NEW(ns2__VALApplication); }
      public:
        /// Constructor with initializations
        ns2__VALApplication() : name(), loaded(), soap() { }
        virtual ~ns2__VALApplication() { }
        /// Friend allocator used by soap_new_ns2__VALApplication(struct soap*, int)
        friend SOAP_FMAC1 ns2__VALApplication * SOAP_FMAC2 soap_instantiate_ns2__VALApplication(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:585 */
#ifndef SOAP_TYPE_ns2__VALApplications
#define SOAP_TYPE_ns2__VALApplications (154)
/* complex XSD type 'ns2:VALApplications': */
class SOAP_CMAC ns2__VALApplications {
      public:
        /// Optional element 'application' of XSD type 'ns2:VALApplication'
        std::vector<ns2__VALApplication *> application;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__VALApplications
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__VALApplications; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__VALApplications, default initialized and not managed by a soap context
        virtual ns2__VALApplications *soap_alloc(void) const { return SOAP_NEW(ns2__VALApplications); }
      public:
        /// Constructor with initializations
        ns2__VALApplications() : application(), soap() { }
        virtual ~ns2__VALApplications() { }
        /// Friend allocator used by soap_new_ns2__VALApplications(struct soap*, int)
        friend SOAP_FMAC1 ns2__VALApplications * SOAP_FMAC2 soap_instantiate_ns2__VALApplications(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:588 */
#ifndef SOAP_TYPE_ns2__Data
#define SOAP_TYPE_ns2__Data (155)
/* complex XSD type 'ns2:Data': */
class SOAP_CMAC ns2__Data {
      public:
        /// Required element 'ns3:Include' of XSD type 'ns3:Include'
        ns3__Include *ns3__Include_;
        /// optional attribute 'ns4:contentType' of XSD type 'xsd:string'
        std::string *ns4__contentType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Data
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Data; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Data, default initialized and not managed by a soap context
        virtual ns2__Data *soap_alloc(void) const { return SOAP_NEW(ns2__Data); }
      public:
        /// Constructor with initializations
        ns2__Data() : ns3__Include_(), ns4__contentType(), soap() { }
        virtual ~ns2__Data() { }
        /// Friend allocator used by soap_new_ns2__Data(struct soap*, int)
        friend SOAP_FMAC1 ns2__Data * SOAP_FMAC2 soap_instantiate_ns2__Data(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:591 */
#ifndef SOAP_TYPE_ns2__Records
#define SOAP_TYPE_ns2__Records (156)
/* complex XSD type 'ns2:Records': */
class SOAP_CMAC ns2__Records {
      public:
        /// Optional element 'record' of XSD type 'xsd:string'
        std::vector<std::string> record;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Records
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Records; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Records, default initialized and not managed by a soap context
        virtual ns2__Records *soap_alloc(void) const { return SOAP_NEW(ns2__Records); }
      public:
        /// Constructor with initializations
        ns2__Records() : record(), soap() { }
        virtual ~ns2__Records() { }
        /// Friend allocator used by soap_new_ns2__Records(struct soap*, int)
        friend SOAP_FMAC1 ns2__Records * SOAP_FMAC2 soap_instantiate_ns2__Records(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:594 */
#ifndef SOAP_TYPE_ns2__JointRange
#define SOAP_TYPE_ns2__JointRange (157)
/* complex XSD type 'ns2:JointRange': */
class SOAP_CMAC ns2__JointRange {
      public:
        /// Optional element 'min' of XSD type 'xsd:double'
        std::vector<double> min_;
        /// Optional element 'max' of XSD type 'xsd:double'
        std::vector<double> max_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__JointRange
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__JointRange; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__JointRange, default initialized and not managed by a soap context
        virtual ns2__JointRange *soap_alloc(void) const { return SOAP_NEW(ns2__JointRange); }
      public:
        /// Constructor with initializations
        ns2__JointRange() : min_(), max_(), soap() { }
        virtual ~ns2__JointRange() { }
        /// Friend allocator used by soap_new_ns2__JointRange(struct soap*, int)
        friend SOAP_FMAC1 ns2__JointRange * SOAP_FMAC2 soap_instantiate_ns2__JointRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:597 */
#ifndef SOAP_TYPE__ns2__getApplications
#define SOAP_TYPE__ns2__getApplications (158)
/* complex XSD type 'ns2:getApplications': */
class SOAP_CMAC _ns2__getApplications {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns2__getApplications
        virtual int soap_type(void) const { return SOAP_TYPE__ns2__getApplications; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__getApplications, default initialized and not managed by a soap context
        virtual _ns2__getApplications *soap_alloc(void) const { return SOAP_NEW(_ns2__getApplications); }
      public:
        /// Constructor with initializations
        _ns2__getApplications() : soap() { }
        virtual ~_ns2__getApplications() { }
        /// Friend allocator used by soap_new__ns2__getApplications(struct soap*, int)
        friend SOAP_FMAC1 _ns2__getApplications * SOAP_FMAC2 soap_instantiate__ns2__getApplications(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:600 */
#ifndef SOAP_TYPE__ns2__getApplicationsResponse
#define SOAP_TYPE__ns2__getApplicationsResponse (159)
/* complex XSD type 'ns2:getApplicationsResponse': */
class SOAP_CMAC _ns2__getApplicationsResponse {
      public:
        /// Required element 'applications' of XSD type 'ns2:VALApplications'
        ns2__VALApplications *applications;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns2__getApplicationsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns2__getApplicationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__getApplicationsResponse, default initialized and not managed by a soap context
        virtual _ns2__getApplicationsResponse *soap_alloc(void) const { return SOAP_NEW(_ns2__getApplicationsResponse); }
      public:
        /// Constructor with initializations
        _ns2__getApplicationsResponse() : applications(), soap() { }
        virtual ~_ns2__getApplicationsResponse() { }
        /// Friend allocator used by soap_new__ns2__getApplicationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns2__getApplicationsResponse * SOAP_FMAC2 soap_instantiate__ns2__getApplicationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:603 */
#ifndef SOAP_TYPE__ns2__getApplicationDatas
#define SOAP_TYPE__ns2__getApplicationDatas (160)
/* complex XSD type 'ns2:getApplicationDatas': */
class SOAP_CMAC _ns2__getApplicationDatas {
      public:
        /// Optional element 'name' of XSD type 'xsd:string'
        std::string *name;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns2__getApplicationDatas
        virtual int soap_type(void) const { return SOAP_TYPE__ns2__getApplicationDatas; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__getApplicationDatas, default initialized and not managed by a soap context
        virtual _ns2__getApplicationDatas *soap_alloc(void) const { return SOAP_NEW(_ns2__getApplicationDatas); }
      public:
        /// Constructor with initializations
        _ns2__getApplicationDatas() : name(), soap() { }
        virtual ~_ns2__getApplicationDatas() { }
        /// Friend allocator used by soap_new__ns2__getApplicationDatas(struct soap*, int)
        friend SOAP_FMAC1 _ns2__getApplicationDatas * SOAP_FMAC2 soap_instantiate__ns2__getApplicationDatas(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:606 */
#ifndef SOAP_TYPE__ns2__getApplicationDatasResponse
#define SOAP_TYPE__ns2__getApplicationDatasResponse (161)
/* complex XSD type 'ns2:getApplicationDatasResponse': */
class SOAP_CMAC _ns2__getApplicationDatasResponse {
      public:
        /// Required element 'data' of XSD type 'ns2:Data'
        ns2__Data *data;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns2__getApplicationDatasResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns2__getApplicationDatasResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__getApplicationDatasResponse, default initialized and not managed by a soap context
        virtual _ns2__getApplicationDatasResponse *soap_alloc(void) const { return SOAP_NEW(_ns2__getApplicationDatasResponse); }
      public:
        /// Constructor with initializations
        _ns2__getApplicationDatasResponse() : data(), soap() { }
        virtual ~_ns2__getApplicationDatasResponse() { }
        /// Friend allocator used by soap_new__ns2__getApplicationDatasResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns2__getApplicationDatasResponse * SOAP_FMAC2 soap_instantiate__ns2__getApplicationDatasResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:609 */
#ifndef SOAP_TYPE__ns2__getRecords
#define SOAP_TYPE__ns2__getRecords (162)
/* complex XSD type 'ns2:getRecords': */
class SOAP_CMAC _ns2__getRecords {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns2__getRecords
        virtual int soap_type(void) const { return SOAP_TYPE__ns2__getRecords; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__getRecords, default initialized and not managed by a soap context
        virtual _ns2__getRecords *soap_alloc(void) const { return SOAP_NEW(_ns2__getRecords); }
      public:
        /// Constructor with initializations
        _ns2__getRecords() : soap() { }
        virtual ~_ns2__getRecords() { }
        /// Friend allocator used by soap_new__ns2__getRecords(struct soap*, int)
        friend SOAP_FMAC1 _ns2__getRecords * SOAP_FMAC2 soap_instantiate__ns2__getRecords(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:612 */
#ifndef SOAP_TYPE__ns2__getRecordsResponse
#define SOAP_TYPE__ns2__getRecordsResponse (163)
/* complex XSD type 'ns2:getRecordsResponse': */
class SOAP_CMAC _ns2__getRecordsResponse {
      public:
        /// Required element 'records' of XSD type 'ns2:Records'
        ns2__Records *records;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns2__getRecordsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns2__getRecordsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__getRecordsResponse, default initialized and not managed by a soap context
        virtual _ns2__getRecordsResponse *soap_alloc(void) const { return SOAP_NEW(_ns2__getRecordsResponse); }
      public:
        /// Constructor with initializations
        _ns2__getRecordsResponse() : records(), soap() { }
        virtual ~_ns2__getRecordsResponse() { }
        /// Friend allocator used by soap_new__ns2__getRecordsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns2__getRecordsResponse * SOAP_FMAC2 soap_instantiate__ns2__getRecordsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:615 */
#ifndef SOAP_TYPE__ns2__getRecord
#define SOAP_TYPE__ns2__getRecord (164)
/* complex XSD type 'ns2:getRecord': */
class SOAP_CMAC _ns2__getRecord {
      public:
        /// Optional element 'name' of XSD type 'xsd:string'
        std::string *name;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns2__getRecord
        virtual int soap_type(void) const { return SOAP_TYPE__ns2__getRecord; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__getRecord, default initialized and not managed by a soap context
        virtual _ns2__getRecord *soap_alloc(void) const { return SOAP_NEW(_ns2__getRecord); }
      public:
        /// Constructor with initializations
        _ns2__getRecord() : name(), soap() { }
        virtual ~_ns2__getRecord() { }
        /// Friend allocator used by soap_new__ns2__getRecord(struct soap*, int)
        friend SOAP_FMAC1 _ns2__getRecord * SOAP_FMAC2 soap_instantiate__ns2__getRecord(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:618 */
#ifndef SOAP_TYPE__ns2__getRecordResponse
#define SOAP_TYPE__ns2__getRecordResponse (165)
/* complex XSD type 'ns2:getRecordResponse': */
class SOAP_CMAC _ns2__getRecordResponse {
      public:
        /// Required element 'data' of XSD type 'ns2:Data'
        ns2__Data *data;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns2__getRecordResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns2__getRecordResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__getRecordResponse, default initialized and not managed by a soap context
        virtual _ns2__getRecordResponse *soap_alloc(void) const { return SOAP_NEW(_ns2__getRecordResponse); }
      public:
        /// Constructor with initializations
        _ns2__getRecordResponse() : data(), soap() { }
        virtual ~_ns2__getRecordResponse() { }
        /// Friend allocator used by soap_new__ns2__getRecordResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns2__getRecordResponse * SOAP_FMAC2 soap_instantiate__ns2__getRecordResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:621 */
#ifndef SOAP_TYPE__ns2__getJointRange
#define SOAP_TYPE__ns2__getJointRange (166)
/* complex XSD type 'ns2:getJointRange': */
class SOAP_CMAC _ns2__getJointRange {
      public:
        /// Required element 'robot' of XSD type 'xsd:int'
        int robot;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns2__getJointRange
        virtual int soap_type(void) const { return SOAP_TYPE__ns2__getJointRange; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__getJointRange, default initialized and not managed by a soap context
        virtual _ns2__getJointRange *soap_alloc(void) const { return SOAP_NEW(_ns2__getJointRange); }
      public:
        /// Constructor with initializations
        _ns2__getJointRange() : robot(), soap() { }
        virtual ~_ns2__getJointRange() { }
        /// Friend allocator used by soap_new__ns2__getJointRange(struct soap*, int)
        friend SOAP_FMAC1 _ns2__getJointRange * SOAP_FMAC2 soap_instantiate__ns2__getJointRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:624 */
#ifndef SOAP_TYPE__ns2__getJointRangeResponse
#define SOAP_TYPE__ns2__getJointRangeResponse (167)
/* complex XSD type 'ns2:getJointRangeResponse': */
class SOAP_CMAC _ns2__getJointRangeResponse {
      public:
        /// Required element 'range' of XSD type 'ns2:JointRange'
        ns2__JointRange *range;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns2__getJointRangeResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns2__getJointRangeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__getJointRangeResponse, default initialized and not managed by a soap context
        virtual _ns2__getJointRangeResponse *soap_alloc(void) const { return SOAP_NEW(_ns2__getJointRangeResponse); }
      public:
        /// Constructor with initializations
        _ns2__getJointRangeResponse() : range(), soap() { }
        virtual ~_ns2__getJointRangeResponse() { }
        /// Friend allocator used by soap_new__ns2__getJointRangeResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns2__getJointRangeResponse * SOAP_FMAC2 soap_instantiate__ns2__getJointRangeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:627 */
#ifndef SOAP_TYPE_ns4__base64Binary
#define SOAP_TYPE_ns4__base64Binary (168)
/* simple XSD type 'ns4:base64Binary': */
class SOAP_CMAC ns4__base64Binary {
      public:
        /// Simple content of XSD type 'xsd:base64Binary' wrapped by this struct
        xsd__base64Binary __item;
        /// optional attribute 'contentType' of XSD type 'xsd:string'
        std::string *contentType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns4__base64Binary
        virtual int soap_type(void) const { return SOAP_TYPE_ns4__base64Binary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns4__base64Binary, default initialized and not managed by a soap context
        virtual ns4__base64Binary *soap_alloc(void) const { return SOAP_NEW(ns4__base64Binary); }
      public:
        /// Constructor with initializations
        ns4__base64Binary() : __item(), contentType(), soap() { }
        virtual ~ns4__base64Binary() { }
        /// Friend allocator used by soap_new_ns4__base64Binary(struct soap*, int)
        friend SOAP_FMAC1 ns4__base64Binary * SOAP_FMAC2 soap_instantiate_ns4__base64Binary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:630 */
#ifndef SOAP_TYPE_ns4__hexBinary
#define SOAP_TYPE_ns4__hexBinary (169)
/* simple XSD type 'ns4:hexBinary': */
class SOAP_CMAC ns4__hexBinary {
      public:
        /// Simple content of XSD type 'xsd:hexBinary' wrapped by this struct
        xsd__hexBinary __item;
        /// optional attribute 'contentType' of XSD type 'xsd:string'
        std::string *contentType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns4__hexBinary
        virtual int soap_type(void) const { return SOAP_TYPE_ns4__hexBinary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns4__hexBinary, default initialized and not managed by a soap context
        virtual ns4__hexBinary *soap_alloc(void) const { return SOAP_NEW(ns4__hexBinary); }
      public:
        /// Constructor with initializations
        ns4__hexBinary() : __item(), contentType(), soap() { }
        virtual ~ns4__hexBinary() { }
        /// Friend allocator used by soap_new_ns4__hexBinary(struct soap*, int)
        friend SOAP_FMAC1 ns4__hexBinary * SOAP_FMAC2 soap_instantiate_ns4__hexBinary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:2936 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (242)
/* SOAP_ENV__Header: */
struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** MustUnderstand */
        int *ns1__sessionId;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header() : ns1__sessionId() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* CS8Server.h:2958 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (244)
/* SOAP_ENV__Detail: */
struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        /** Optional element 'ns1:ServerException' of XSD type 'ns1:ServerException' */
        ns1__ServerException *ns1__ServerException_;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_T assigned to __type */
        /** Do not create a cyclic data structure throught this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
        char *__any;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail() : ns1__ServerException_(), __type(), fault(), __any() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* CS8Server.h:3039 */
#ifndef SOAP_TYPE___ns1__getSoapServerVersion
#define SOAP_TYPE___ns1__getSoapServerVersion (251)
/* Wrapper: */
struct SOAP_CMAC __ns1__getSoapServerVersion {
      public:
        /** Optional element 'ns1:getSoapServerVersion' of XSD type 'ns1:getSoapServerVersion' */
        _ns1__getSoapServerVersion *ns1__getSoapServerVersion;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getSoapServerVersion */
        int soap_type() const { return SOAP_TYPE___ns1__getSoapServerVersion; }
        /** Constructor with member initializations */
        __ns1__getSoapServerVersion() : ns1__getSoapServerVersion() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getSoapServerVersion * SOAP_FMAC2 soap_instantiate___ns1__getSoapServerVersion(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:3104 */
#ifndef SOAP_TYPE___ns1__findServer
#define SOAP_TYPE___ns1__findServer (255)
/* Wrapper: */
struct SOAP_CMAC __ns1__findServer {
      public:
        /** Optional element 'ns1:findServer' of XSD type 'ns1:findServer' */
        _ns1__findServer *ns1__findServer;
      public:
        /** Return unique type id SOAP_TYPE___ns1__findServer */
        int soap_type() const { return SOAP_TYPE___ns1__findServer; }
        /** Constructor with member initializations */
        __ns1__findServer() : ns1__findServer() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__findServer * SOAP_FMAC2 soap_instantiate___ns1__findServer(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:3169 */
#ifndef SOAP_TYPE___ns1__ping
#define SOAP_TYPE___ns1__ping (259)
/* Wrapper: */
struct SOAP_CMAC __ns1__ping {
      public:
        /** Optional element 'ns1:ping' of XSD type 'ns1:ping' */
        _ns1__ping *ns1__ping;
      public:
        /** Return unique type id SOAP_TYPE___ns1__ping */
        int soap_type() const { return SOAP_TYPE___ns1__ping; }
        /** Constructor with member initializations */
        __ns1__ping() : ns1__ping() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__ping * SOAP_FMAC2 soap_instantiate___ns1__ping(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:3237 */
#ifndef SOAP_TYPE___ns1__getCS8Versions
#define SOAP_TYPE___ns1__getCS8Versions (263)
/* Wrapper: */
struct SOAP_CMAC __ns1__getCS8Versions {
      public:
        /** Optional element 'ns1:getCS8Versions' of XSD type 'ns1:getCS8Versions' */
        _ns1__getCS8Versions *ns1__getCS8Versions;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getCS8Versions */
        int soap_type() const { return SOAP_TYPE___ns1__getCS8Versions; }
        /** Constructor with member initializations */
        __ns1__getCS8Versions() : ns1__getCS8Versions() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getCS8Versions * SOAP_FMAC2 soap_instantiate___ns1__getCS8Versions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:3305 */
#ifndef SOAP_TYPE___ns1__getControllerParameters
#define SOAP_TYPE___ns1__getControllerParameters (267)
/* Wrapper: */
struct SOAP_CMAC __ns1__getControllerParameters {
      public:
        /** Optional element 'ns1:getControllerParameters' of XSD type 'ns1:getControllerParameters' */
        _ns1__getControllerParameters *ns1__getControllerParameters;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getControllerParameters */
        int soap_type() const { return SOAP_TYPE___ns1__getControllerParameters; }
        /** Constructor with member initializations */
        __ns1__getControllerParameters() : ns1__getControllerParameters() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getControllerParameters * SOAP_FMAC2 soap_instantiate___ns1__getControllerParameters(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:3373 */
#ifndef SOAP_TYPE___ns1__getCS8Compatibility
#define SOAP_TYPE___ns1__getCS8Compatibility (271)
/* Wrapper: */
struct SOAP_CMAC __ns1__getCS8Compatibility {
      public:
        /** Optional element 'ns1:getCS8Compatibility' of XSD type 'ns1:getCS8Compatibility' */
        _ns1__getCS8Compatibility *ns1__getCS8Compatibility;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getCS8Compatibility */
        int soap_type() const { return SOAP_TYPE___ns1__getCS8Compatibility; }
        /** Constructor with member initializations */
        __ns1__getCS8Compatibility() : ns1__getCS8Compatibility() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getCS8Compatibility * SOAP_FMAC2 soap_instantiate___ns1__getCS8Compatibility(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:3441 */
#ifndef SOAP_TYPE___ns1__login
#define SOAP_TYPE___ns1__login (275)
/* Wrapper: */
struct SOAP_CMAC __ns1__login {
      public:
        /** Optional element 'ns1:login' of XSD type 'ns1:login' */
        _ns1__login *ns1__login;
      public:
        /** Return unique type id SOAP_TYPE___ns1__login */
        int soap_type() const { return SOAP_TYPE___ns1__login; }
        /** Constructor with member initializations */
        __ns1__login() : ns1__login() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__login * SOAP_FMAC2 soap_instantiate___ns1__login(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:3509 */
#ifndef SOAP_TYPE___ns1__logout
#define SOAP_TYPE___ns1__logout (279)
/* Wrapper: */
struct SOAP_CMAC __ns1__logout {
      public:
        /** Optional element 'ns1:logout' of XSD type 'ns1:logout' */
        _ns1__logout *ns1__logout;
      public:
        /** Return unique type id SOAP_TYPE___ns1__logout */
        int soap_type() const { return SOAP_TYPE___ns1__logout; }
        /** Constructor with member initializations */
        __ns1__logout() : ns1__logout() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__logout * SOAP_FMAC2 soap_instantiate___ns1__logout(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:3577 */
#ifndef SOAP_TYPE___ns1__getRobots
#define SOAP_TYPE___ns1__getRobots (283)
/* Wrapper: */
struct SOAP_CMAC __ns1__getRobots {
      public:
        /** Optional element 'ns1:getRobots' of XSD type 'ns1:getRobots' */
        _ns1__getRobots *ns1__getRobots;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getRobots */
        int soap_type() const { return SOAP_TYPE___ns1__getRobots; }
        /** Constructor with member initializations */
        __ns1__getRobots() : ns1__getRobots() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getRobots * SOAP_FMAC2 soap_instantiate___ns1__getRobots(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:3645 */
#ifndef SOAP_TYPE___ns1__getRobotJointPos
#define SOAP_TYPE___ns1__getRobotJointPos (287)
/* Wrapper: */
struct SOAP_CMAC __ns1__getRobotJointPos {
      public:
        /** Optional element 'ns1:getRobotJointPos' of XSD type 'ns1:getRobotJointPos' */
        _ns1__getRobotJointPos *ns1__getRobotJointPos;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getRobotJointPos */
        int soap_type() const { return SOAP_TYPE___ns1__getRobotJointPos; }
        /** Constructor with member initializations */
        __ns1__getRobotJointPos() : ns1__getRobotJointPos() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getRobotJointPos * SOAP_FMAC2 soap_instantiate___ns1__getRobotJointPos(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:3713 */
#ifndef SOAP_TYPE___ns1__getRobotJntCartPos
#define SOAP_TYPE___ns1__getRobotJntCartPos (291)
/* Wrapper: */
struct SOAP_CMAC __ns1__getRobotJntCartPos {
      public:
        /** Optional element 'ns1:getRobotJntCartPos' of XSD type 'ns1:getRobotJntCartPos' */
        _ns1__getRobotJntCartPos *ns1__getRobotJntCartPos;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getRobotJntCartPos */
        int soap_type() const { return SOAP_TYPE___ns1__getRobotJntCartPos; }
        /** Constructor with member initializations */
        __ns1__getRobotJntCartPos() : ns1__getRobotJntCartPos() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getRobotJntCartPos * SOAP_FMAC2 soap_instantiate___ns1__getRobotJntCartPos(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:3781 */
#ifndef SOAP_TYPE___ns1__setRobotJointPos
#define SOAP_TYPE___ns1__setRobotJointPos (295)
/* Wrapper: */
struct SOAP_CMAC __ns1__setRobotJointPos {
      public:
        /** Optional element 'ns1:setRobotJointPos' of XSD type 'ns1:setRobotJointPos' */
        _ns1__setRobotJointPos *ns1__setRobotJointPos;
      public:
        /** Return unique type id SOAP_TYPE___ns1__setRobotJointPos */
        int soap_type() const { return SOAP_TYPE___ns1__setRobotJointPos; }
        /** Constructor with member initializations */
        __ns1__setRobotJointPos() : ns1__setRobotJointPos() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__setRobotJointPos * SOAP_FMAC2 soap_instantiate___ns1__setRobotJointPos(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:3856 */
#ifndef SOAP_TYPE___ns7__setBreakpoints
#define SOAP_TYPE___ns7__setBreakpoints (299)
/* Wrapper: */
struct SOAP_CMAC __ns7__setBreakpoints {
      public:
        /** Optional element 'ns7:setBreakpoints' of XSD type 'ns7:setBreakpoints' */
        _ns7__setBreakpoints *ns7__setBreakpoints;
      public:
        /** Return unique type id SOAP_TYPE___ns7__setBreakpoints */
        int soap_type() const { return SOAP_TYPE___ns7__setBreakpoints; }
        /** Constructor with member initializations */
        __ns7__setBreakpoints() : ns7__setBreakpoints() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns7__setBreakpoints * SOAP_FMAC2 soap_instantiate___ns7__setBreakpoints(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:3923 */
#ifndef SOAP_TYPE___ns7__getBreakpoints
#define SOAP_TYPE___ns7__getBreakpoints (303)
/* Wrapper: */
struct SOAP_CMAC __ns7__getBreakpoints {
      public:
        /** Optional element 'ns7:getBreakpoints' of XSD type 'ns7:getBreakpoints' */
        _ns7__getBreakpoints *ns7__getBreakpoints;
      public:
        /** Return unique type id SOAP_TYPE___ns7__getBreakpoints */
        int soap_type() const { return SOAP_TYPE___ns7__getBreakpoints; }
        /** Constructor with member initializations */
        __ns7__getBreakpoints() : ns7__getBreakpoints() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns7__getBreakpoints * SOAP_FMAC2 soap_instantiate___ns7__getBreakpoints(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:3990 */
#ifndef SOAP_TYPE___ns7__clearBreakpoints
#define SOAP_TYPE___ns7__clearBreakpoints (307)
/* Wrapper: */
struct SOAP_CMAC __ns7__clearBreakpoints {
      public:
        /** Optional element 'ns7:clearBreakpoints' of XSD type 'ns7:clearBreakpoints' */
        _ns7__clearBreakpoints *ns7__clearBreakpoints;
      public:
        /** Return unique type id SOAP_TYPE___ns7__clearBreakpoints */
        int soap_type() const { return SOAP_TYPE___ns7__clearBreakpoints; }
        /** Constructor with member initializations */
        __ns7__clearBreakpoints() : ns7__clearBreakpoints() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns7__clearBreakpoints * SOAP_FMAC2 soap_instantiate___ns7__clearBreakpoints(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:4057 */
#ifndef SOAP_TYPE___ns7__clearAllBreakpoints
#define SOAP_TYPE___ns7__clearAllBreakpoints (311)
/* Wrapper: */
struct SOAP_CMAC __ns7__clearAllBreakpoints {
      public:
        /** Optional element 'ns7:clearAllBreakpoints' of XSD type 'ns7:clearAllBreakpoints' */
        _ns7__clearAllBreakpoints *ns7__clearAllBreakpoints;
      public:
        /** Return unique type id SOAP_TYPE___ns7__clearAllBreakpoints */
        int soap_type() const { return SOAP_TYPE___ns7__clearAllBreakpoints; }
        /** Constructor with member initializations */
        __ns7__clearAllBreakpoints() : ns7__clearAllBreakpoints() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns7__clearAllBreakpoints * SOAP_FMAC2 soap_instantiate___ns7__clearAllBreakpoints(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:4124 */
#ifndef SOAP_TYPE___ns7__getTasks
#define SOAP_TYPE___ns7__getTasks (315)
/* Wrapper: */
struct SOAP_CMAC __ns7__getTasks {
      public:
        /** Optional element 'ns7:getTasks' of XSD type 'ns7:getTasks' */
        _ns7__getTasks *ns7__getTasks;
      public:
        /** Return unique type id SOAP_TYPE___ns7__getTasks */
        int soap_type() const { return SOAP_TYPE___ns7__getTasks; }
        /** Constructor with member initializations */
        __ns7__getTasks() : ns7__getTasks() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns7__getTasks * SOAP_FMAC2 soap_instantiate___ns7__getTasks(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:4191 */
#ifndef SOAP_TYPE___ns7__taskSuspend
#define SOAP_TYPE___ns7__taskSuspend (319)
/* Wrapper: */
struct SOAP_CMAC __ns7__taskSuspend {
      public:
        /** Optional element 'ns7:taskSuspend' of XSD type 'ns7:taskSuspend' */
        _ns7__taskSuspend *ns7__taskSuspend;
      public:
        /** Return unique type id SOAP_TYPE___ns7__taskSuspend */
        int soap_type() const { return SOAP_TYPE___ns7__taskSuspend; }
        /** Constructor with member initializations */
        __ns7__taskSuspend() : ns7__taskSuspend() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns7__taskSuspend * SOAP_FMAC2 soap_instantiate___ns7__taskSuspend(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:4258 */
#ifndef SOAP_TYPE___ns7__taskResume
#define SOAP_TYPE___ns7__taskResume (323)
/* Wrapper: */
struct SOAP_CMAC __ns7__taskResume {
      public:
        /** Optional element 'ns7:taskResume' of XSD type 'ns7:taskResume' */
        _ns7__taskResume *ns7__taskResume;
      public:
        /** Return unique type id SOAP_TYPE___ns7__taskResume */
        int soap_type() const { return SOAP_TYPE___ns7__taskResume; }
        /** Constructor with member initializations */
        __ns7__taskResume() : ns7__taskResume() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns7__taskResume * SOAP_FMAC2 soap_instantiate___ns7__taskResume(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:4325 */
#ifndef SOAP_TYPE___ns7__taskKill
#define SOAP_TYPE___ns7__taskKill (327)
/* Wrapper: */
struct SOAP_CMAC __ns7__taskKill {
      public:
        /** Optional element 'ns7:taskKill' of XSD type 'ns7:taskKill' */
        _ns7__taskKill *ns7__taskKill;
      public:
        /** Return unique type id SOAP_TYPE___ns7__taskKill */
        int soap_type() const { return SOAP_TYPE___ns7__taskKill; }
        /** Constructor with member initializations */
        __ns7__taskKill() : ns7__taskKill() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns7__taskKill * SOAP_FMAC2 soap_instantiate___ns7__taskKill(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:4392 */
#ifndef SOAP_TYPE___ns7__taskStep
#define SOAP_TYPE___ns7__taskStep (331)
/* Wrapper: */
struct SOAP_CMAC __ns7__taskStep {
      public:
        /** Optional element 'ns7:taskStep' of XSD type 'ns7:taskStep' */
        _ns7__taskStep *ns7__taskStep;
      public:
        /** Return unique type id SOAP_TYPE___ns7__taskStep */
        int soap_type() const { return SOAP_TYPE___ns7__taskStep; }
        /** Constructor with member initializations */
        __ns7__taskStep() : ns7__taskStep() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns7__taskStep * SOAP_FMAC2 soap_instantiate___ns7__taskStep(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:4459 */
#ifndef SOAP_TYPE___ns7__subscribeToControllerEvents
#define SOAP_TYPE___ns7__subscribeToControllerEvents (335)
/* Wrapper: */
struct SOAP_CMAC __ns7__subscribeToControllerEvents {
      public:
        /** Optional element 'ns7:subscribeToControllerEvents' of XSD type 'ns7:subscribeToControllerEvents' */
        _ns7__subscribeToControllerEvents *ns7__subscribeToControllerEvents;
      public:
        /** Return unique type id SOAP_TYPE___ns7__subscribeToControllerEvents */
        int soap_type() const { return SOAP_TYPE___ns7__subscribeToControllerEvents; }
        /** Constructor with member initializations */
        __ns7__subscribeToControllerEvents() : ns7__subscribeToControllerEvents() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns7__subscribeToControllerEvents * SOAP_FMAC2 soap_instantiate___ns7__subscribeToControllerEvents(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:4526 */
#ifndef SOAP_TYPE___ns7__unsubscribeToControllerEvents
#define SOAP_TYPE___ns7__unsubscribeToControllerEvents (339)
/* Wrapper: */
struct SOAP_CMAC __ns7__unsubscribeToControllerEvents {
      public:
        /** Optional element 'ns7:unsubscribeToControllerEvents' of XSD type 'ns7:unsubscribeToControllerEvents' */
        _ns7__unsubscribeToControllerEvents *ns7__unsubscribeToControllerEvents;
      public:
        /** Return unique type id SOAP_TYPE___ns7__unsubscribeToControllerEvents */
        int soap_type() const { return SOAP_TYPE___ns7__unsubscribeToControllerEvents; }
        /** Constructor with member initializations */
        __ns7__unsubscribeToControllerEvents() : ns7__unsubscribeToControllerEvents() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns7__unsubscribeToControllerEvents * SOAP_FMAC2 soap_instantiate___ns7__unsubscribeToControllerEvents(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:4593 */
#ifndef SOAP_TYPE___ns7__getCallStack
#define SOAP_TYPE___ns7__getCallStack (343)
/* Wrapper: */
struct SOAP_CMAC __ns7__getCallStack {
      public:
        /** Optional element 'ns7:getCallStack' of XSD type 'ns7:getCallStack' */
        _ns7__getCallStack *ns7__getCallStack;
      public:
        /** Return unique type id SOAP_TYPE___ns7__getCallStack */
        int soap_type() const { return SOAP_TYPE___ns7__getCallStack; }
        /** Constructor with member initializations */
        __ns7__getCallStack() : ns7__getCallStack() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns7__getCallStack * SOAP_FMAC2 soap_instantiate___ns7__getCallStack(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:4660 */
#ifndef SOAP_TYPE___ns7__getStackFrame
#define SOAP_TYPE___ns7__getStackFrame (347)
/* Wrapper: */
struct SOAP_CMAC __ns7__getStackFrame {
      public:
        /** Optional element 'ns7:getStackFrame' of XSD type 'ns7:getStackFrame' */
        _ns7__getStackFrame *ns7__getStackFrame;
      public:
        /** Return unique type id SOAP_TYPE___ns7__getStackFrame */
        int soap_type() const { return SOAP_TYPE___ns7__getStackFrame; }
        /** Constructor with member initializations */
        __ns7__getStackFrame() : ns7__getStackFrame() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns7__getStackFrame * SOAP_FMAC2 soap_instantiate___ns7__getStackFrame(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:4727 */
#ifndef SOAP_TYPE___ns7__getWatches
#define SOAP_TYPE___ns7__getWatches (351)
/* Wrapper: */
struct SOAP_CMAC __ns7__getWatches {
      public:
        /** Optional element 'ns7:getWatches' of XSD type 'ns7:getWatches' */
        _ns7__getWatches *ns7__getWatches;
      public:
        /** Return unique type id SOAP_TYPE___ns7__getWatches */
        int soap_type() const { return SOAP_TYPE___ns7__getWatches; }
        /** Constructor with member initializations */
        __ns7__getWatches() : ns7__getWatches() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns7__getWatches * SOAP_FMAC2 soap_instantiate___ns7__getWatches(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:4794 */
#ifndef SOAP_TYPE___ns7__execVal3
#define SOAP_TYPE___ns7__execVal3 (355)
/* Wrapper: */
struct SOAP_CMAC __ns7__execVal3 {
      public:
        /** Optional element 'ns7:execVal3' of XSD type 'ns7:execVal3' */
        _ns7__execVal3 *ns7__execVal3;
      public:
        /** Return unique type id SOAP_TYPE___ns7__execVal3 */
        int soap_type() const { return SOAP_TYPE___ns7__execVal3; }
        /** Constructor with member initializations */
        __ns7__execVal3() : ns7__execVal3() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns7__execVal3 * SOAP_FMAC2 soap_instantiate___ns7__execVal3(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:4861 */
#ifndef SOAP_TYPE___ns7__setProjectAsModified
#define SOAP_TYPE___ns7__setProjectAsModified (359)
/* Wrapper: */
struct SOAP_CMAC __ns7__setProjectAsModified {
      public:
        /** Optional element 'ns7:setProjectAsModified' of XSD type 'ns7:setProjectAsModified' */
        _ns7__setProjectAsModified *ns7__setProjectAsModified;
      public:
        /** Return unique type id SOAP_TYPE___ns7__setProjectAsModified */
        int soap_type() const { return SOAP_TYPE___ns7__setProjectAsModified; }
        /** Constructor with member initializations */
        __ns7__setProjectAsModified() : ns7__setProjectAsModified() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns7__setProjectAsModified * SOAP_FMAC2 soap_instantiate___ns7__setProjectAsModified(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:4928 */
#ifndef SOAP_TYPE___ns7__setCurrentInstruction
#define SOAP_TYPE___ns7__setCurrentInstruction (363)
/* Wrapper: */
struct SOAP_CMAC __ns7__setCurrentInstruction {
      public:
        /** Optional element 'ns7:setCurrentInstruction' of XSD type 'ns7:setCurrentInstruction' */
        _ns7__setCurrentInstruction *ns7__setCurrentInstruction;
      public:
        /** Return unique type id SOAP_TYPE___ns7__setCurrentInstruction */
        int soap_type() const { return SOAP_TYPE___ns7__setCurrentInstruction; }
        /** Constructor with member initializations */
        __ns7__setCurrentInstruction() : ns7__setCurrentInstruction() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns7__setCurrentInstruction * SOAP_FMAC2 soap_instantiate___ns7__setCurrentInstruction(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:4995 */
#ifndef SOAP_TYPE___ns7__replaceLine
#define SOAP_TYPE___ns7__replaceLine (367)
/* Wrapper: */
struct SOAP_CMAC __ns7__replaceLine {
      public:
        /** Optional element 'ns7:replaceLine' of XSD type 'ns7:replaceLine' */
        _ns7__replaceLine *ns7__replaceLine;
      public:
        /** Return unique type id SOAP_TYPE___ns7__replaceLine */
        int soap_type() const { return SOAP_TYPE___ns7__replaceLine; }
        /** Constructor with member initializations */
        __ns7__replaceLine() : ns7__replaceLine() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns7__replaceLine * SOAP_FMAC2 soap_instantiate___ns7__replaceLine(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:5062 */
#ifndef SOAP_TYPE___ns7__readIos
#define SOAP_TYPE___ns7__readIos (371)
/* Wrapper: */
struct SOAP_CMAC __ns7__readIos {
      public:
        /** Optional element 'ns7:readIos' of XSD type 'ns7:readIos' */
        _ns7__readIos *ns7__readIos;
      public:
        /** Return unique type id SOAP_TYPE___ns7__readIos */
        int soap_type() const { return SOAP_TYPE___ns7__readIos; }
        /** Constructor with member initializations */
        __ns7__readIos() : ns7__readIos() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns7__readIos * SOAP_FMAC2 soap_instantiate___ns7__readIos(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:5129 */
#ifndef SOAP_TYPE___ns7__writeIos
#define SOAP_TYPE___ns7__writeIos (375)
/* Wrapper: */
struct SOAP_CMAC __ns7__writeIos {
      public:
        /** Optional element 'ns7:writeIos' of XSD type 'ns7:writeIos' */
        _ns7__writeIos *ns7__writeIos;
      public:
        /** Return unique type id SOAP_TYPE___ns7__writeIos */
        int soap_type() const { return SOAP_TYPE___ns7__writeIos; }
        /** Constructor with member initializations */
        __ns7__writeIos() : ns7__writeIos() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns7__writeIos * SOAP_FMAC2 soap_instantiate___ns7__writeIos(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:5196 */
#ifndef SOAP_TYPE___ns7__lockIos
#define SOAP_TYPE___ns7__lockIos (379)
/* Wrapper: */
struct SOAP_CMAC __ns7__lockIos {
      public:
        /** Optional element 'ns7:lockIos' of XSD type 'ns7:lockIos' */
        _ns7__lockIos *ns7__lockIos;
      public:
        /** Return unique type id SOAP_TYPE___ns7__lockIos */
        int soap_type() const { return SOAP_TYPE___ns7__lockIos; }
        /** Constructor with member initializations */
        __ns7__lockIos() : ns7__lockIos() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns7__lockIos * SOAP_FMAC2 soap_instantiate___ns7__lockIos(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:5263 */
#ifndef SOAP_TYPE___ns7__unlockIos
#define SOAP_TYPE___ns7__unlockIos (383)
/* Wrapper: */
struct SOAP_CMAC __ns7__unlockIos {
      public:
        /** Optional element 'ns7:unlockIos' of XSD type 'ns7:unlockIos' */
        _ns7__unlockIos *ns7__unlockIos;
      public:
        /** Return unique type id SOAP_TYPE___ns7__unlockIos */
        int soap_type() const { return SOAP_TYPE___ns7__unlockIos; }
        /** Constructor with member initializations */
        __ns7__unlockIos() : ns7__unlockIos() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns7__unlockIos * SOAP_FMAC2 soap_instantiate___ns7__unlockIos(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:5330 */
#ifndef SOAP_TYPE___ns7__lockAllIos
#define SOAP_TYPE___ns7__lockAllIos (387)
/* Wrapper: */
struct SOAP_CMAC __ns7__lockAllIos {
      public:
        /** Optional element 'ns7:lockAllIos' of XSD type 'ns7:lockAllIos' */
        _ns7__lockAllIos *ns7__lockAllIos;
      public:
        /** Return unique type id SOAP_TYPE___ns7__lockAllIos */
        int soap_type() const { return SOAP_TYPE___ns7__lockAllIos; }
        /** Constructor with member initializations */
        __ns7__lockAllIos() : ns7__lockAllIos() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns7__lockAllIos * SOAP_FMAC2 soap_instantiate___ns7__lockAllIos(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:5397 */
#ifndef SOAP_TYPE___ns7__unlockAllIos
#define SOAP_TYPE___ns7__unlockAllIos (390)
/* Wrapper: */
struct SOAP_CMAC __ns7__unlockAllIos {
      public:
        /** Optional element 'ns7:unlockAllIos' of XSD type 'ns7:unlockAllIos' */
        _ns7__unlockAllIos *ns7__unlockAllIos;
      public:
        /** Return unique type id SOAP_TYPE___ns7__unlockAllIos */
        int soap_type() const { return SOAP_TYPE___ns7__unlockAllIos; }
        /** Constructor with member initializations */
        __ns7__unlockAllIos() : ns7__unlockAllIos() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns7__unlockAllIos * SOAP_FMAC2 soap_instantiate___ns7__unlockAllIos(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:5464 */
#ifndef SOAP_TYPE___ns7__getAllPhysicalIos
#define SOAP_TYPE___ns7__getAllPhysicalIos (394)
/* Wrapper: */
struct SOAP_CMAC __ns7__getAllPhysicalIos {
      public:
        /** Optional element 'ns7:getAllPhysicalIos' of XSD type 'ns7:getAllPhysicalIos' */
        _ns7__getAllPhysicalIos *ns7__getAllPhysicalIos;
      public:
        /** Return unique type id SOAP_TYPE___ns7__getAllPhysicalIos */
        int soap_type() const { return SOAP_TYPE___ns7__getAllPhysicalIos; }
        /** Constructor with member initializations */
        __ns7__getAllPhysicalIos() : ns7__getAllPhysicalIos() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns7__getAllPhysicalIos * SOAP_FMAC2 soap_instantiate___ns7__getAllPhysicalIos(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:5531 */
#ifndef SOAP_TYPE___ns7__getRobotDhParameters
#define SOAP_TYPE___ns7__getRobotDhParameters (398)
/* Wrapper: */
struct SOAP_CMAC __ns7__getRobotDhParameters {
      public:
        /** Optional element 'ns7:getRobotDhParameters' of XSD type 'ns7:getRobotDhParameters' */
        _ns7__getRobotDhParameters *ns7__getRobotDhParameters;
      public:
        /** Return unique type id SOAP_TYPE___ns7__getRobotDhParameters */
        int soap_type() const { return SOAP_TYPE___ns7__getRobotDhParameters; }
        /** Constructor with member initializations */
        __ns7__getRobotDhParameters() : ns7__getRobotDhParameters() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns7__getRobotDhParameters * SOAP_FMAC2 soap_instantiate___ns7__getRobotDhParameters(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:5598 */
#ifndef SOAP_TYPE___ns7__getProject
#define SOAP_TYPE___ns7__getProject (402)
/* Wrapper: */
struct SOAP_CMAC __ns7__getProject {
      public:
        /** Optional element 'ns7:getProject' of XSD type 'ns7:getProject' */
        _ns7__getProject *ns7__getProject;
      public:
        /** Return unique type id SOAP_TYPE___ns7__getProject */
        int soap_type() const { return SOAP_TYPE___ns7__getProject; }
        /** Constructor with member initializations */
        __ns7__getProject() : ns7__getProject() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns7__getProject * SOAP_FMAC2 soap_instantiate___ns7__getProject(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CS8Server.h:6353 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (403)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_CMAC SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XSD type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code() : SOAP_ENV__Value(), SOAP_ENV__Subcode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* CS8Server.h:6353 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (405)
/* SOAP_ENV__Reason: */
struct SOAP_CMAC SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XSD type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason() : SOAP_ENV__Text() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* CS8Server.h:6353 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (406)
/* SOAP_ENV__Fault: */
struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XSD type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XSD type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XSD type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XSD type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XSD type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XSD type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault() : faultcode(), faultstring(), faultactor(), detail(), SOAP_ENV__Code(), SOAP_ENV__Reason(), SOAP_ENV__Node(), SOAP_ENV__Role(), SOAP_ENV__Detail() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* (built-in):0 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
typedef char *_XML;
#endif

/* (built-in):0 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
typedef char *_QName;
#endif

/* CS8Server.h:149 */
#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (9)
typedef std::string xsd__anyURI;
#endif

/* CS8Server.h:681 */
#ifndef SOAP_TYPE_ns1__SessionId
#define SOAP_TYPE_ns1__SessionId (170)
typedef int ns1__SessionId;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* ns1__SessionId has binding name 'ns1__SessionId' for type 'ns1:SessionId' */
#ifndef SOAP_TYPE_ns1__SessionId
#define SOAP_TYPE_ns1__SessionId (170)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* double has binding name 'double' for type 'xsd:double' */
#ifndef SOAP_TYPE_double
#define SOAP_TYPE_double (182)
#endif

/* unsigned char has binding name 'unsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_unsignedByte
#define SOAP_TYPE_unsignedByte (12)
#endif

/* unsigned int has binding name 'unsignedInt' for type 'xsd:unsignedInt' */
#ifndef SOAP_TYPE_unsignedInt
#define SOAP_TYPE_unsignedInt (11)
#endif

/* bool has binding name 'bool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_bool
#define SOAP_TYPE_bool (191)
#endif

/* enum ns7__replaceLineReturnCode has binding name 'ns7__replaceLineReturnCode' for type 'ns7:replaceLineReturnCode' */
#ifndef SOAP_TYPE_ns7__replaceLineReturnCode
#define SOAP_TYPE_ns7__replaceLineReturnCode (180)
#endif

/* enum ns7__execVal3ReturnCode has binding name 'ns7__execVal3ReturnCode' for type 'ns7:execVal3ReturnCode' */
#ifndef SOAP_TYPE_ns7__execVal3ReturnCode
#define SOAP_TYPE_ns7__execVal3ReturnCode (179)
#endif

/* enum ns7__SoapPhysicalIoEnumState has binding name 'ns7__SoapPhysicalIoEnumState' for type 'ns7:SoapPhysicalIoEnumState' */
#ifndef SOAP_TYPE_ns7__SoapPhysicalIoEnumState
#define SOAP_TYPE_ns7__SoapPhysicalIoEnumState (178)
#endif

/* enum ns7__SoapTaskStep has binding name 'ns7__SoapTaskStep' for type 'ns7:SoapTaskStep' */
#ifndef SOAP_TYPE_ns7__SoapTaskStep
#define SOAP_TYPE_ns7__SoapTaskStep (177)
#endif

/* enum ns7__SoapTaskState has binding name 'ns7__SoapTaskState' for type 'ns7:SoapTaskState' */
#ifndef SOAP_TYPE_ns7__SoapTaskState
#define SOAP_TYPE_ns7__SoapTaskState (176)
#endif

/* enum ns1__DiameterAxis3 has binding name 'ns1__DiameterAxis3' for type 'ns1:DiameterAxis3' */
#ifndef SOAP_TYPE_ns1__DiameterAxis3
#define SOAP_TYPE_ns1__DiameterAxis3 (175)
#endif

/* enum ns1__LengthAxis3 has binding name 'ns1__LengthAxis3' for type 'ns1:LengthAxis3' */
#ifndef SOAP_TYPE_ns1__LengthAxis3
#define SOAP_TYPE_ns1__LengthAxis3 (174)
#endif

/* enum ns1__MountType has binding name 'ns1__MountType' for type 'ns1:MountType' */
#ifndef SOAP_TYPE_ns1__MountType
#define SOAP_TYPE_ns1__MountType (173)
#endif

/* enum ns1__Kinematic has binding name 'ns1__Kinematic' for type 'ns1:Kinematic' */
#ifndef SOAP_TYPE_ns1__Kinematic
#define SOAP_TYPE_ns1__Kinematic (172)
#endif

/* enum ns1__ServerExceptionCode has binding name 'ns1__ServerExceptionCode' for type 'ns1:ServerExceptionCode' */
#ifndef SOAP_TYPE_ns1__ServerExceptionCode
#define SOAP_TYPE_ns1__ServerExceptionCode (171)
#endif

/* ns4__hexBinary has binding name 'ns4__hexBinary' for type 'ns4:hexBinary' */
#ifndef SOAP_TYPE_ns4__hexBinary
#define SOAP_TYPE_ns4__hexBinary (169)
#endif

/* ns4__base64Binary has binding name 'ns4__base64Binary' for type 'ns4:base64Binary' */
#ifndef SOAP_TYPE_ns4__base64Binary
#define SOAP_TYPE_ns4__base64Binary (168)
#endif

/* _ns2__getJointRangeResponse has binding name '_ns2__getJointRangeResponse' for type '' */
#ifndef SOAP_TYPE__ns2__getJointRangeResponse
#define SOAP_TYPE__ns2__getJointRangeResponse (167)
#endif

/* _ns2__getJointRange has binding name '_ns2__getJointRange' for type '' */
#ifndef SOAP_TYPE__ns2__getJointRange
#define SOAP_TYPE__ns2__getJointRange (166)
#endif

/* _ns2__getRecordResponse has binding name '_ns2__getRecordResponse' for type '' */
#ifndef SOAP_TYPE__ns2__getRecordResponse
#define SOAP_TYPE__ns2__getRecordResponse (165)
#endif

/* _ns2__getRecord has binding name '_ns2__getRecord' for type '' */
#ifndef SOAP_TYPE__ns2__getRecord
#define SOAP_TYPE__ns2__getRecord (164)
#endif

/* _ns2__getRecordsResponse has binding name '_ns2__getRecordsResponse' for type '' */
#ifndef SOAP_TYPE__ns2__getRecordsResponse
#define SOAP_TYPE__ns2__getRecordsResponse (163)
#endif

/* _ns2__getRecords has binding name '_ns2__getRecords' for type '' */
#ifndef SOAP_TYPE__ns2__getRecords
#define SOAP_TYPE__ns2__getRecords (162)
#endif

/* _ns2__getApplicationDatasResponse has binding name '_ns2__getApplicationDatasResponse' for type '' */
#ifndef SOAP_TYPE__ns2__getApplicationDatasResponse
#define SOAP_TYPE__ns2__getApplicationDatasResponse (161)
#endif

/* _ns2__getApplicationDatas has binding name '_ns2__getApplicationDatas' for type '' */
#ifndef SOAP_TYPE__ns2__getApplicationDatas
#define SOAP_TYPE__ns2__getApplicationDatas (160)
#endif

/* _ns2__getApplicationsResponse has binding name '_ns2__getApplicationsResponse' for type '' */
#ifndef SOAP_TYPE__ns2__getApplicationsResponse
#define SOAP_TYPE__ns2__getApplicationsResponse (159)
#endif

/* _ns2__getApplications has binding name '_ns2__getApplications' for type '' */
#ifndef SOAP_TYPE__ns2__getApplications
#define SOAP_TYPE__ns2__getApplications (158)
#endif

/* ns2__JointRange has binding name 'ns2__JointRange' for type 'ns2:JointRange' */
#ifndef SOAP_TYPE_ns2__JointRange
#define SOAP_TYPE_ns2__JointRange (157)
#endif

/* ns2__Records has binding name 'ns2__Records' for type 'ns2:Records' */
#ifndef SOAP_TYPE_ns2__Records
#define SOAP_TYPE_ns2__Records (156)
#endif

/* ns2__Data has binding name 'ns2__Data' for type 'ns2:Data' */
#ifndef SOAP_TYPE_ns2__Data
#define SOAP_TYPE_ns2__Data (155)
#endif

/* ns2__VALApplications has binding name 'ns2__VALApplications' for type 'ns2:VALApplications' */
#ifndef SOAP_TYPE_ns2__VALApplications
#define SOAP_TYPE_ns2__VALApplications (154)
#endif

/* ns2__VALApplication has binding name 'ns2__VALApplication' for type 'ns2:VALApplication' */
#ifndef SOAP_TYPE_ns2__VALApplication
#define SOAP_TYPE_ns2__VALApplication (153)
#endif

/* ns3__Include has binding name 'ns3__Include' for type 'ns3:Include' */
#ifndef SOAP_TYPE_ns3__Include
#define SOAP_TYPE_ns3__Include (152)
#endif

/* _ns7__getProjectResponse has binding name '_ns7__getProjectResponse' for type '' */
#ifndef SOAP_TYPE__ns7__getProjectResponse
#define SOAP_TYPE__ns7__getProjectResponse (151)
#endif

/* _ns7__getProject has binding name '_ns7__getProject' for type '' */
#ifndef SOAP_TYPE__ns7__getProject
#define SOAP_TYPE__ns7__getProject (150)
#endif

/* _ns7__SoapRobotDhParameters has binding name '_ns7__SoapRobotDhParameters' for type '' */
#ifndef SOAP_TYPE__ns7__SoapRobotDhParameters
#define SOAP_TYPE__ns7__SoapRobotDhParameters (149)
#endif

/* _ns7__getRobotDhParameters has binding name '_ns7__getRobotDhParameters' for type '' */
#ifndef SOAP_TYPE__ns7__getRobotDhParameters
#define SOAP_TYPE__ns7__getRobotDhParameters (148)
#endif

/* _ns7__getAllPhysicalIosResponse has binding name '_ns7__getAllPhysicalIosResponse' for type '' */
#ifndef SOAP_TYPE__ns7__getAllPhysicalIosResponse
#define SOAP_TYPE__ns7__getAllPhysicalIosResponse (147)
#endif

/* _ns7__getAllPhysicalIos has binding name '_ns7__getAllPhysicalIos' for type '' */
#ifndef SOAP_TYPE__ns7__getAllPhysicalIos
#define SOAP_TYPE__ns7__getAllPhysicalIos (146)
#endif

/* _ns7__unlockAllIos has binding name '_ns7__unlockAllIos' for type '' */
#ifndef SOAP_TYPE__ns7__unlockAllIos
#define SOAP_TYPE__ns7__unlockAllIos (145)
#endif

/* _ns7__SoapAllPhysicalIoResponse has binding name '_ns7__SoapAllPhysicalIoResponse' for type '' */
#ifndef SOAP_TYPE__ns7__SoapAllPhysicalIoResponse
#define SOAP_TYPE__ns7__SoapAllPhysicalIoResponse (144)
#endif

/* _ns7__lockAllIos has binding name '_ns7__lockAllIos' for type '' */
#ifndef SOAP_TYPE__ns7__lockAllIos
#define SOAP_TYPE__ns7__lockAllIos (143)
#endif

/* _ns7__unlockIosResponse has binding name '_ns7__unlockIosResponse' for type '' */
#ifndef SOAP_TYPE__ns7__unlockIosResponse
#define SOAP_TYPE__ns7__unlockIosResponse (142)
#endif

/* _ns7__unlockIos has binding name '_ns7__unlockIos' for type '' */
#ifndef SOAP_TYPE__ns7__unlockIos
#define SOAP_TYPE__ns7__unlockIos (141)
#endif

/* _ns7__lockIosResponse has binding name '_ns7__lockIosResponse' for type '' */
#ifndef SOAP_TYPE__ns7__lockIosResponse
#define SOAP_TYPE__ns7__lockIosResponse (140)
#endif

/* _ns7__lockIos has binding name '_ns7__lockIos' for type '' */
#ifndef SOAP_TYPE__ns7__lockIos
#define SOAP_TYPE__ns7__lockIos (139)
#endif

/* _ns7__writeIosResponse has binding name '_ns7__writeIosResponse' for type '' */
#ifndef SOAP_TYPE__ns7__writeIosResponse
#define SOAP_TYPE__ns7__writeIosResponse (138)
#endif

/* _ns7__writeIos has binding name '_ns7__writeIos' for type '' */
#ifndef SOAP_TYPE__ns7__writeIos
#define SOAP_TYPE__ns7__writeIos (137)
#endif

/* _ns7__readIosResponse has binding name '_ns7__readIosResponse' for type '' */
#ifndef SOAP_TYPE__ns7__readIosResponse
#define SOAP_TYPE__ns7__readIosResponse (136)
#endif

/* _ns7__readIos has binding name '_ns7__readIos' for type '' */
#ifndef SOAP_TYPE__ns7__readIos
#define SOAP_TYPE__ns7__readIos (135)
#endif

/* _ns7__replaceLineResponse has binding name '_ns7__replaceLineResponse' for type '' */
#ifndef SOAP_TYPE__ns7__replaceLineResponse
#define SOAP_TYPE__ns7__replaceLineResponse (134)
#endif

/* _ns7__replaceLine has binding name '_ns7__replaceLine' for type '' */
#ifndef SOAP_TYPE__ns7__replaceLine
#define SOAP_TYPE__ns7__replaceLine (133)
#endif

/* _ns7__setCurrentInstructionResponse has binding name '_ns7__setCurrentInstructionResponse' for type '' */
#ifndef SOAP_TYPE__ns7__setCurrentInstructionResponse
#define SOAP_TYPE__ns7__setCurrentInstructionResponse (132)
#endif

/* _ns7__setCurrentInstruction has binding name '_ns7__setCurrentInstruction' for type '' */
#ifndef SOAP_TYPE__ns7__setCurrentInstruction
#define SOAP_TYPE__ns7__setCurrentInstruction (131)
#endif

/* _ns7__setProjectAsModifiedResponse has binding name '_ns7__setProjectAsModifiedResponse' for type '' */
#ifndef SOAP_TYPE__ns7__setProjectAsModifiedResponse
#define SOAP_TYPE__ns7__setProjectAsModifiedResponse (130)
#endif

/* _ns7__setProjectAsModified has binding name '_ns7__setProjectAsModified' for type '' */
#ifndef SOAP_TYPE__ns7__setProjectAsModified
#define SOAP_TYPE__ns7__setProjectAsModified (129)
#endif

/* _ns7__execVal3Response has binding name '_ns7__execVal3Response' for type '' */
#ifndef SOAP_TYPE__ns7__execVal3Response
#define SOAP_TYPE__ns7__execVal3Response (128)
#endif

/* _ns7__execVal3 has binding name '_ns7__execVal3' for type '' */
#ifndef SOAP_TYPE__ns7__execVal3
#define SOAP_TYPE__ns7__execVal3 (127)
#endif

/* _ns7__getWatchResponse has binding name '_ns7__getWatchResponse' for type '' */
#ifndef SOAP_TYPE__ns7__getWatchResponse
#define SOAP_TYPE__ns7__getWatchResponse (126)
#endif

/* _ns7__getWatches has binding name '_ns7__getWatches' for type '' */
#ifndef SOAP_TYPE__ns7__getWatches
#define SOAP_TYPE__ns7__getWatches (125)
#endif

/* _ns7__getStackFrameResponse has binding name '_ns7__getStackFrameResponse' for type '' */
#ifndef SOAP_TYPE__ns7__getStackFrameResponse
#define SOAP_TYPE__ns7__getStackFrameResponse (124)
#endif

/* _ns7__getStackFrame has binding name '_ns7__getStackFrame' for type '' */
#ifndef SOAP_TYPE__ns7__getStackFrame
#define SOAP_TYPE__ns7__getStackFrame (123)
#endif

/* _ns7__getCallStackResponse has binding name '_ns7__getCallStackResponse' for type '' */
#ifndef SOAP_TYPE__ns7__getCallStackResponse
#define SOAP_TYPE__ns7__getCallStackResponse (122)
#endif

/* _ns7__getCallStack has binding name '_ns7__getCallStack' for type '' */
#ifndef SOAP_TYPE__ns7__getCallStack
#define SOAP_TYPE__ns7__getCallStack (121)
#endif

/* _ns7__unsubscribeResponse has binding name '_ns7__unsubscribeResponse' for type '' */
#ifndef SOAP_TYPE__ns7__unsubscribeResponse
#define SOAP_TYPE__ns7__unsubscribeResponse (120)
#endif

/* _ns7__unsubscribeToControllerEvents has binding name '_ns7__unsubscribeToControllerEvents' for type '' */
#ifndef SOAP_TYPE__ns7__unsubscribeToControllerEvents
#define SOAP_TYPE__ns7__unsubscribeToControllerEvents (119)
#endif

/* _ns7__subscribeResponse has binding name '_ns7__subscribeResponse' for type '' */
#ifndef SOAP_TYPE__ns7__subscribeResponse
#define SOAP_TYPE__ns7__subscribeResponse (118)
#endif

/* _ns7__subscribeToControllerEvents has binding name '_ns7__subscribeToControllerEvents' for type '' */
#ifndef SOAP_TYPE__ns7__subscribeToControllerEvents
#define SOAP_TYPE__ns7__subscribeToControllerEvents (117)
#endif

/* _ns7__taskStepResponse has binding name '_ns7__taskStepResponse' for type '' */
#ifndef SOAP_TYPE__ns7__taskStepResponse
#define SOAP_TYPE__ns7__taskStepResponse (116)
#endif

/* _ns7__taskStep has binding name '_ns7__taskStep' for type '' */
#ifndef SOAP_TYPE__ns7__taskStep
#define SOAP_TYPE__ns7__taskStep (115)
#endif

/* _ns7__taskKillResponse has binding name '_ns7__taskKillResponse' for type '' */
#ifndef SOAP_TYPE__ns7__taskKillResponse
#define SOAP_TYPE__ns7__taskKillResponse (114)
#endif

/* _ns7__taskKill has binding name '_ns7__taskKill' for type '' */
#ifndef SOAP_TYPE__ns7__taskKill
#define SOAP_TYPE__ns7__taskKill (113)
#endif

/* _ns7__taskResumeResponse has binding name '_ns7__taskResumeResponse' for type '' */
#ifndef SOAP_TYPE__ns7__taskResumeResponse
#define SOAP_TYPE__ns7__taskResumeResponse (112)
#endif

/* _ns7__taskResume has binding name '_ns7__taskResume' for type '' */
#ifndef SOAP_TYPE__ns7__taskResume
#define SOAP_TYPE__ns7__taskResume (111)
#endif

/* _ns7__taskSuspendResponse has binding name '_ns7__taskSuspendResponse' for type '' */
#ifndef SOAP_TYPE__ns7__taskSuspendResponse
#define SOAP_TYPE__ns7__taskSuspendResponse (110)
#endif

/* _ns7__taskSuspend has binding name '_ns7__taskSuspend' for type '' */
#ifndef SOAP_TYPE__ns7__taskSuspend
#define SOAP_TYPE__ns7__taskSuspend (109)
#endif

/* _ns7__getTasksResponse has binding name '_ns7__getTasksResponse' for type '' */
#ifndef SOAP_TYPE__ns7__getTasksResponse
#define SOAP_TYPE__ns7__getTasksResponse (108)
#endif

/* _ns7__getTasks has binding name '_ns7__getTasks' for type '' */
#ifndef SOAP_TYPE__ns7__getTasks
#define SOAP_TYPE__ns7__getTasks (107)
#endif

/* _ns7__clearAllBreakpointsResponse has binding name '_ns7__clearAllBreakpointsResponse' for type '' */
#ifndef SOAP_TYPE__ns7__clearAllBreakpointsResponse
#define SOAP_TYPE__ns7__clearAllBreakpointsResponse (106)
#endif

/* _ns7__clearAllBreakpoints has binding name '_ns7__clearAllBreakpoints' for type '' */
#ifndef SOAP_TYPE__ns7__clearAllBreakpoints
#define SOAP_TYPE__ns7__clearAllBreakpoints (105)
#endif

/* _ns7__clearBreakpointsResponse has binding name '_ns7__clearBreakpointsResponse' for type '' */
#ifndef SOAP_TYPE__ns7__clearBreakpointsResponse
#define SOAP_TYPE__ns7__clearBreakpointsResponse (104)
#endif

/* _ns7__clearBreakpoints has binding name '_ns7__clearBreakpoints' for type '' */
#ifndef SOAP_TYPE__ns7__clearBreakpoints
#define SOAP_TYPE__ns7__clearBreakpoints (103)
#endif

/* _ns7__getBreakpointsResponse has binding name '_ns7__getBreakpointsResponse' for type '' */
#ifndef SOAP_TYPE__ns7__getBreakpointsResponse
#define SOAP_TYPE__ns7__getBreakpointsResponse (102)
#endif

/* _ns7__getBreakpoints has binding name '_ns7__getBreakpoints' for type '' */
#ifndef SOAP_TYPE__ns7__getBreakpoints
#define SOAP_TYPE__ns7__getBreakpoints (101)
#endif

/* _ns7__setBreakpointsResponse has binding name '_ns7__setBreakpointsResponse' for type '' */
#ifndef SOAP_TYPE__ns7__setBreakpointsResponse
#define SOAP_TYPE__ns7__setBreakpointsResponse (100)
#endif

/* _ns7__setBreakpoints has binding name '_ns7__setBreakpoints' for type '' */
#ifndef SOAP_TYPE__ns7__setBreakpoints
#define SOAP_TYPE__ns7__setBreakpoints (99)
#endif

/* ns7__SoapDhParametersArray has binding name 'ns7__SoapDhParametersArray' for type 'ns7:SoapDhParametersArray' */
#ifndef SOAP_TYPE_ns7__SoapDhParametersArray
#define SOAP_TYPE_ns7__SoapDhParametersArray (98)
#endif

/* ns7__SoapDhParameters has binding name 'ns7__SoapDhParameters' for type 'ns7:SoapDhParameters' */
#ifndef SOAP_TYPE_ns7__SoapDhParameters
#define SOAP_TYPE_ns7__SoapDhParameters (97)
#endif

/* ns7__SoapPhysicalIoUnlockResponses has binding name 'ns7__SoapPhysicalIoUnlockResponses' for type 'ns7:SoapPhysicalIoUnlockResponses' */
#ifndef SOAP_TYPE_ns7__SoapPhysicalIoUnlockResponses
#define SOAP_TYPE_ns7__SoapPhysicalIoUnlockResponses (96)
#endif

/* ns7__SoapPhysicalIoUnlockResponse has binding name 'ns7__SoapPhysicalIoUnlockResponse' for type 'ns7:SoapPhysicalIoUnlockResponse' */
#ifndef SOAP_TYPE_ns7__SoapPhysicalIoUnlockResponse
#define SOAP_TYPE_ns7__SoapPhysicalIoUnlockResponse (95)
#endif

/* ns7__SoapPhysicalIoResponses has binding name 'ns7__SoapPhysicalIoResponses' for type 'ns7:SoapPhysicalIoResponses' */
#ifndef SOAP_TYPE_ns7__SoapPhysicalIoResponses
#define SOAP_TYPE_ns7__SoapPhysicalIoResponses (94)
#endif

/* ns7__SoapPhysicalIoResponse has binding name 'ns7__SoapPhysicalIoResponse' for type 'ns7:SoapPhysicalIoResponse' */
#ifndef SOAP_TYPE_ns7__SoapPhysicalIoResponse
#define SOAP_TYPE_ns7__SoapPhysicalIoResponse (93)
#endif

/* ns7__SoapPhysicalIosStates has binding name 'ns7__SoapPhysicalIosStates' for type 'ns7:SoapPhysicalIosStates' */
#ifndef SOAP_TYPE_ns7__SoapPhysicalIosStates
#define SOAP_TYPE_ns7__SoapPhysicalIosStates (92)
#endif

/* ns7__SoapPhysicalIoValues has binding name 'ns7__SoapPhysicalIoValues' for type 'ns7:SoapPhysicalIoValues' */
#ifndef SOAP_TYPE_ns7__SoapPhysicalIoValues
#define SOAP_TYPE_ns7__SoapPhysicalIoValues (91)
#endif

/* ns7__SoapPhysicalIoState has binding name 'ns7__SoapPhysicalIoState' for type 'ns7:SoapPhysicalIoState' */
#ifndef SOAP_TYPE_ns7__SoapPhysicalIoState
#define SOAP_TYPE_ns7__SoapPhysicalIoState (90)
#endif

/* ns7__SoapPhysicalIoAttrib has binding name 'ns7__SoapPhysicalIoAttrib' for type 'ns7:SoapPhysicalIoAttrib' */
#ifndef SOAP_TYPE_ns7__SoapPhysicalIoAttrib
#define SOAP_TYPE_ns7__SoapPhysicalIoAttrib (89)
#endif

/* ns7__SoapPhysicalAioAttrib has binding name 'ns7__SoapPhysicalAioAttrib' for type 'ns7:SoapPhysicalAioAttrib' */
#ifndef SOAP_TYPE_ns7__SoapPhysicalAioAttrib
#define SOAP_TYPE_ns7__SoapPhysicalAioAttrib (88)
#endif

/* ns7__SoapPhysicalDioAttrib has binding name 'ns7__SoapPhysicalDioAttrib' for type 'ns7:SoapPhysicalDioAttrib' */
#ifndef SOAP_TYPE_ns7__SoapPhysicalDioAttrib
#define SOAP_TYPE_ns7__SoapPhysicalDioAttrib (87)
#endif

/* ns7__SoapPhysicalIoLinks has binding name 'ns7__SoapPhysicalIoLinks' for type 'ns7:SoapPhysicalIoLinks' */
#ifndef SOAP_TYPE_ns7__SoapPhysicalIoLinks
#define SOAP_TYPE_ns7__SoapPhysicalIoLinks (86)
#endif

/* ns7__SoapWatches has binding name 'ns7__SoapWatches' for type 'ns7:SoapWatches' */
#ifndef SOAP_TYPE_ns7__SoapWatches
#define SOAP_TYPE_ns7__SoapWatches (85)
#endif

/* ns7__SoapData has binding name 'ns7__SoapData' for type 'ns7:SoapData' */
#ifndef SOAP_TYPE_ns7__SoapData
#define SOAP_TYPE_ns7__SoapData (84)
#endif

/* ns7__SoapCallStack has binding name 'ns7__SoapCallStack' for type 'ns7:SoapCallStack' */
#ifndef SOAP_TYPE_ns7__SoapCallStack
#define SOAP_TYPE_ns7__SoapCallStack (83)
#endif

/* ns7__SoapStackFrameAbstract has binding name 'ns7__SoapStackFrameAbstract' for type 'ns7:SoapStackFrameAbstract' */
#ifndef SOAP_TYPE_ns7__SoapStackFrameAbstract
#define SOAP_TYPE_ns7__SoapStackFrameAbstract (82)
#endif

/* ns7__SoapInstruction has binding name 'ns7__SoapInstruction' for type 'ns7:SoapInstruction' */
#ifndef SOAP_TYPE_ns7__SoapInstruction
#define SOAP_TYPE_ns7__SoapInstruction (81)
#endif

/* ns7__SoapTasks has binding name 'ns7__SoapTasks' for type 'ns7:SoapTasks' */
#ifndef SOAP_TYPE_ns7__SoapTasks
#define SOAP_TYPE_ns7__SoapTasks (80)
#endif

/* ns7__SoapTask has binding name 'ns7__SoapTask' for type 'ns7:SoapTask' */
#ifndef SOAP_TYPE_ns7__SoapTask
#define SOAP_TYPE_ns7__SoapTask (79)
#endif

/* ns7__MimeData has binding name 'ns7__MimeData' for type 'ns7:MimeData' */
#ifndef SOAP_TYPE_ns7__MimeData
#define SOAP_TYPE_ns7__MimeData (78)
#endif

/* ns7__BreakpointsResponses has binding name 'ns7__BreakpointsResponses' for type 'ns7:BreakpointsResponses' */
#ifndef SOAP_TYPE_ns7__BreakpointsResponses
#define SOAP_TYPE_ns7__BreakpointsResponses (77)
#endif

/* ns7__BreakpointsResponse has binding name 'ns7__BreakpointsResponse' for type 'ns7:BreakpointsResponse' */
#ifndef SOAP_TYPE_ns7__BreakpointsResponse
#define SOAP_TYPE_ns7__BreakpointsResponse (76)
#endif

/* ns7__SoapBreakpoints has binding name 'ns7__SoapBreakpoints' for type 'ns7:SoapBreakpoints' */
#ifndef SOAP_TYPE_ns7__SoapBreakpoints
#define SOAP_TYPE_ns7__SoapBreakpoints (75)
#endif

/* ns7__SoapBreakpoint has binding name 'ns7__SoapBreakpoint' for type 'ns7:SoapBreakpoint' */
#ifndef SOAP_TYPE_ns7__SoapBreakpoint
#define SOAP_TYPE_ns7__SoapBreakpoint (74)
#endif

/* ns7__SoapProgramLine has binding name 'ns7__SoapProgramLine' for type 'ns7:SoapProgramLine' */
#ifndef SOAP_TYPE_ns7__SoapProgramLine
#define SOAP_TYPE_ns7__SoapProgramLine (73)
#endif

/* ns7__Records has binding name 'ns7__Records' for type 'ns7:Records' */
#ifndef SOAP_TYPE_ns7__Records
#define SOAP_TYPE_ns7__Records (72)
#endif

/* ns7__VALApplications has binding name 'ns7__VALApplications' for type 'ns7:VALApplications' */
#ifndef SOAP_TYPE_ns7__VALApplications
#define SOAP_TYPE_ns7__VALApplications (71)
#endif

/* ns7__Robots has binding name 'ns7__Robots' for type 'ns7:Robots' */
#ifndef SOAP_TYPE_ns7__Robots
#define SOAP_TYPE_ns7__Robots (70)
#endif

/* ns7__Versions has binding name 'ns7__Versions' for type 'ns7:Versions' */
#ifndef SOAP_TYPE_ns7__Versions
#define SOAP_TYPE_ns7__Versions (69)
#endif

/* ns7__Parameters has binding name 'ns7__Parameters' for type 'ns7:Parameters' */
#ifndef SOAP_TYPE_ns7__Parameters
#define SOAP_TYPE_ns7__Parameters (68)
#endif

/* ns7__JointPos has binding name 'ns7__JointPos' for type 'ns7:JointPos' */
#ifndef SOAP_TYPE_ns7__JointPos
#define SOAP_TYPE_ns7__JointPos (67)
#endif

/* ns5__SoapDhParametersArray has binding name 'ns5__SoapDhParametersArray' for type 'ns5:SoapDhParametersArray' */
#ifndef SOAP_TYPE_ns5__SoapDhParametersArray
#define SOAP_TYPE_ns5__SoapDhParametersArray (66)
#endif

/* ns5__SoapPhysicalIoUnlockResponses has binding name 'ns5__SoapPhysicalIoUnlockResponses' for type 'ns5:SoapPhysicalIoUnlockResponses' */
#ifndef SOAP_TYPE_ns5__SoapPhysicalIoUnlockResponses
#define SOAP_TYPE_ns5__SoapPhysicalIoUnlockResponses (65)
#endif

/* ns5__SoapPhysicalIoResponses has binding name 'ns5__SoapPhysicalIoResponses' for type 'ns5:SoapPhysicalIoResponses' */
#ifndef SOAP_TYPE_ns5__SoapPhysicalIoResponses
#define SOAP_TYPE_ns5__SoapPhysicalIoResponses (64)
#endif

/* ns5__SoapPhysicalIosStates has binding name 'ns5__SoapPhysicalIosStates' for type 'ns5:SoapPhysicalIosStates' */
#ifndef SOAP_TYPE_ns5__SoapPhysicalIosStates
#define SOAP_TYPE_ns5__SoapPhysicalIosStates (63)
#endif

/* ns5__SoapPhysicalIoValues has binding name 'ns5__SoapPhysicalIoValues' for type 'ns5:SoapPhysicalIoValues' */
#ifndef SOAP_TYPE_ns5__SoapPhysicalIoValues
#define SOAP_TYPE_ns5__SoapPhysicalIoValues (62)
#endif

/* ns5__SoapPhysicalIoLinks has binding name 'ns5__SoapPhysicalIoLinks' for type 'ns5:SoapPhysicalIoLinks' */
#ifndef SOAP_TYPE_ns5__SoapPhysicalIoLinks
#define SOAP_TYPE_ns5__SoapPhysicalIoLinks (61)
#endif

/* ns5__SoapWatches has binding name 'ns5__SoapWatches' for type 'ns5:SoapWatches' */
#ifndef SOAP_TYPE_ns5__SoapWatches
#define SOAP_TYPE_ns5__SoapWatches (60)
#endif

/* ns5__SoapCallStack has binding name 'ns5__SoapCallStack' for type 'ns5:SoapCallStack' */
#ifndef SOAP_TYPE_ns5__SoapCallStack
#define SOAP_TYPE_ns5__SoapCallStack (59)
#endif

/* ns5__SoapTasks has binding name 'ns5__SoapTasks' for type 'ns5:SoapTasks' */
#ifndef SOAP_TYPE_ns5__SoapTasks
#define SOAP_TYPE_ns5__SoapTasks (58)
#endif

/* ns5__BreakpointsResponses has binding name 'ns5__BreakpointsResponses' for type 'ns5:BreakpointsResponses' */
#ifndef SOAP_TYPE_ns5__BreakpointsResponses
#define SOAP_TYPE_ns5__BreakpointsResponses (57)
#endif

/* ns5__SoapBreakpoints has binding name 'ns5__SoapBreakpoints' for type 'ns5:SoapBreakpoints' */
#ifndef SOAP_TYPE_ns5__SoapBreakpoints
#define SOAP_TYPE_ns5__SoapBreakpoints (56)
#endif

/* ns5__Records has binding name 'ns5__Records' for type 'ns5:Records' */
#ifndef SOAP_TYPE_ns5__Records
#define SOAP_TYPE_ns5__Records (55)
#endif

/* ns5__VALApplications has binding name 'ns5__VALApplications' for type 'ns5:VALApplications' */
#ifndef SOAP_TYPE_ns5__VALApplications
#define SOAP_TYPE_ns5__VALApplications (54)
#endif

/* ns5__Robots has binding name 'ns5__Robots' for type 'ns5:Robots' */
#ifndef SOAP_TYPE_ns5__Robots
#define SOAP_TYPE_ns5__Robots (53)
#endif

/* ns5__Versions has binding name 'ns5__Versions' for type 'ns5:Versions' */
#ifndef SOAP_TYPE_ns5__Versions
#define SOAP_TYPE_ns5__Versions (52)
#endif

/* ns5__Parameters has binding name 'ns5__Parameters' for type 'ns5:Parameters' */
#ifndef SOAP_TYPE_ns5__Parameters
#define SOAP_TYPE_ns5__Parameters (51)
#endif

/* ns5__JointPos has binding name 'ns5__JointPos' for type 'ns5:JointPos' */
#ifndef SOAP_TYPE_ns5__JointPos
#define SOAP_TYPE_ns5__JointPos (50)
#endif

/* _ns1__setRobotPosResponse has binding name '_ns1__setRobotPosResponse' for type '' */
#ifndef SOAP_TYPE__ns1__setRobotPosResponse
#define SOAP_TYPE__ns1__setRobotPosResponse (49)
#endif

/* _ns1__setRobotJointPos has binding name '_ns1__setRobotJointPos' for type '' */
#ifndef SOAP_TYPE__ns1__setRobotJointPos
#define SOAP_TYPE__ns1__setRobotJointPos (48)
#endif

/* _ns1__getRobotJntCartPosResponse has binding name '_ns1__getRobotJntCartPosResponse' for type '' */
#ifndef SOAP_TYPE__ns1__getRobotJntCartPosResponse
#define SOAP_TYPE__ns1__getRobotJntCartPosResponse (47)
#endif

/* _ns1__getRobotJntCartPos has binding name '_ns1__getRobotJntCartPos' for type '' */
#ifndef SOAP_TYPE__ns1__getRobotJntCartPos
#define SOAP_TYPE__ns1__getRobotJntCartPos (46)
#endif

/* _ns1__getRobotJointPosResponse has binding name '_ns1__getRobotJointPosResponse' for type '' */
#ifndef SOAP_TYPE__ns1__getRobotJointPosResponse
#define SOAP_TYPE__ns1__getRobotJointPosResponse (45)
#endif

/* _ns1__getRobotJointPos has binding name '_ns1__getRobotJointPos' for type '' */
#ifndef SOAP_TYPE__ns1__getRobotJointPos
#define SOAP_TYPE__ns1__getRobotJointPos (44)
#endif

/* _ns1__getRobotsResponse has binding name '_ns1__getRobotsResponse' for type '' */
#ifndef SOAP_TYPE__ns1__getRobotsResponse
#define SOAP_TYPE__ns1__getRobotsResponse (43)
#endif

/* _ns1__getRobots has binding name '_ns1__getRobots' for type '' */
#ifndef SOAP_TYPE__ns1__getRobots
#define SOAP_TYPE__ns1__getRobots (42)
#endif

/* _ns1__logoutResponse has binding name '_ns1__logoutResponse' for type '' */
#ifndef SOAP_TYPE__ns1__logoutResponse
#define SOAP_TYPE__ns1__logoutResponse (41)
#endif

/* _ns1__logout has binding name '_ns1__logout' for type '' */
#ifndef SOAP_TYPE__ns1__logout
#define SOAP_TYPE__ns1__logout (40)
#endif

/* _ns1__loginResponse has binding name '_ns1__loginResponse' for type '' */
#ifndef SOAP_TYPE__ns1__loginResponse
#define SOAP_TYPE__ns1__loginResponse (39)
#endif

/* _ns1__login has binding name '_ns1__login' for type '' */
#ifndef SOAP_TYPE__ns1__login
#define SOAP_TYPE__ns1__login (38)
#endif

/* _ns1__getCS8CompatibilityResponse has binding name '_ns1__getCS8CompatibilityResponse' for type '' */
#ifndef SOAP_TYPE__ns1__getCS8CompatibilityResponse
#define SOAP_TYPE__ns1__getCS8CompatibilityResponse (37)
#endif

/* _ns1__getCS8Compatibility has binding name '_ns1__getCS8Compatibility' for type '' */
#ifndef SOAP_TYPE__ns1__getCS8Compatibility
#define SOAP_TYPE__ns1__getCS8Compatibility (36)
#endif

/* _ns1__getControllerParametersResponse has binding name '_ns1__getControllerParametersResponse' for type '' */
#ifndef SOAP_TYPE__ns1__getControllerParametersResponse
#define SOAP_TYPE__ns1__getControllerParametersResponse (35)
#endif

/* _ns1__getControllerParameters has binding name '_ns1__getControllerParameters' for type '' */
#ifndef SOAP_TYPE__ns1__getControllerParameters
#define SOAP_TYPE__ns1__getControllerParameters (34)
#endif

/* _ns1__getCS8VersionsResponse has binding name '_ns1__getCS8VersionsResponse' for type '' */
#ifndef SOAP_TYPE__ns1__getCS8VersionsResponse
#define SOAP_TYPE__ns1__getCS8VersionsResponse (33)
#endif

/* _ns1__getCS8Versions has binding name '_ns1__getCS8Versions' for type '' */
#ifndef SOAP_TYPE__ns1__getCS8Versions
#define SOAP_TYPE__ns1__getCS8Versions (32)
#endif

/* _ns1__pingResponse has binding name '_ns1__pingResponse' for type '' */
#ifndef SOAP_TYPE__ns1__pingResponse
#define SOAP_TYPE__ns1__pingResponse (31)
#endif

/* _ns1__ping has binding name '_ns1__ping' for type '' */
#ifndef SOAP_TYPE__ns1__ping
#define SOAP_TYPE__ns1__ping (30)
#endif

/* _ns1__findServerResponse has binding name '_ns1__findServerResponse' for type '' */
#ifndef SOAP_TYPE__ns1__findServerResponse
#define SOAP_TYPE__ns1__findServerResponse (29)
#endif

/* _ns1__findServer has binding name '_ns1__findServer' for type '' */
#ifndef SOAP_TYPE__ns1__findServer
#define SOAP_TYPE__ns1__findServer (28)
#endif

/* _ns1__getSoapServerVersionResponse has binding name '_ns1__getSoapServerVersionResponse' for type '' */
#ifndef SOAP_TYPE__ns1__getSoapServerVersionResponse
#define SOAP_TYPE__ns1__getSoapServerVersionResponse (27)
#endif

/* _ns1__getSoapServerVersion has binding name '_ns1__getSoapServerVersion' for type '' */
#ifndef SOAP_TYPE__ns1__getSoapServerVersion
#define SOAP_TYPE__ns1__getSoapServerVersion (26)
#endif

/* ns1__Robots has binding name 'ns1__Robots' for type 'ns1:Robots' */
#ifndef SOAP_TYPE_ns1__Robots
#define SOAP_TYPE_ns1__Robots (25)
#endif

/* ns1__SoapServerVersion has binding name 'ns1__SoapServerVersion' for type 'ns1:SoapServerVersion' */
#ifndef SOAP_TYPE_ns1__SoapServerVersion
#define SOAP_TYPE_ns1__SoapServerVersion (24)
#endif

/* ns1__Versions has binding name 'ns1__Versions' for type 'ns1:Versions' */
#ifndef SOAP_TYPE_ns1__Versions
#define SOAP_TYPE_ns1__Versions (23)
#endif

/* ns1__Parameters has binding name 'ns1__Parameters' for type 'ns1:Parameters' */
#ifndef SOAP_TYPE_ns1__Parameters
#define SOAP_TYPE_ns1__Parameters (22)
#endif

/* ns1__Parameter has binding name 'ns1__Parameter' for type 'ns1:Parameter' */
#ifndef SOAP_TYPE_ns1__Parameter
#define SOAP_TYPE_ns1__Parameter (21)
#endif

/* ns1__Version has binding name 'ns1__Version' for type 'ns1:Version' */
#ifndef SOAP_TYPE_ns1__Version
#define SOAP_TYPE_ns1__Version (20)
#endif

/* ns1__Robot has binding name 'ns1__Robot' for type 'ns1:Robot' */
#ifndef SOAP_TYPE_ns1__Robot
#define SOAP_TYPE_ns1__Robot (19)
#endif

/* ns1__CartesianPos has binding name 'ns1__CartesianPos' for type 'ns1:CartesianPos' */
#ifndef SOAP_TYPE_ns1__CartesianPos
#define SOAP_TYPE_ns1__CartesianPos (18)
#endif

/* ns1__JointPos has binding name 'ns1__JointPos' for type 'ns1:JointPos' */
#ifndef SOAP_TYPE_ns1__JointPos
#define SOAP_TYPE_ns1__JointPos (17)
#endif

/* ns1__ServerException has binding name 'ns1__ServerException' for type 'ns1:ServerException' */
#ifndef SOAP_TYPE_ns1__ServerException
#define SOAP_TYPE_ns1__ServerException (16)
#endif

/* xsd__hexBinary has binding name 'xsd__hexBinary' for type 'xsd:hexBinary' */
#ifndef SOAP_TYPE_xsd__hexBinary
#define SOAP_TYPE_xsd__hexBinary (15)
#endif

/* xsd__base64Binary has binding name 'xsd__base64Binary' for type 'xsd:base64Binary' */
#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (10)
#endif

/* xsd__anyURI has binding name 'xsd__anyURI' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (9)
#endif

/* std::string has binding name 'std__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__string
#define SOAP_TYPE_std__string (8)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (406)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (405)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (403)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (244)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (242)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (408)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (407)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (404)
#endif

/* _ns7__getProjectResponse * has binding name 'PointerTo_ns7__getProjectResponse' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__getProjectResponse
#define SOAP_TYPE_PointerTo_ns7__getProjectResponse (400)
#endif

/* _ns7__getProject * has binding name 'PointerTo_ns7__getProject' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__getProject
#define SOAP_TYPE_PointerTo_ns7__getProject (399)
#endif

/* _ns7__SoapRobotDhParameters * has binding name 'PointerTo_ns7__SoapRobotDhParameters' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__SoapRobotDhParameters
#define SOAP_TYPE_PointerTo_ns7__SoapRobotDhParameters (396)
#endif

/* _ns7__getRobotDhParameters * has binding name 'PointerTo_ns7__getRobotDhParameters' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__getRobotDhParameters
#define SOAP_TYPE_PointerTo_ns7__getRobotDhParameters (395)
#endif

/* _ns7__getAllPhysicalIosResponse * has binding name 'PointerTo_ns7__getAllPhysicalIosResponse' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__getAllPhysicalIosResponse
#define SOAP_TYPE_PointerTo_ns7__getAllPhysicalIosResponse (392)
#endif

/* _ns7__getAllPhysicalIos * has binding name 'PointerTo_ns7__getAllPhysicalIos' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__getAllPhysicalIos
#define SOAP_TYPE_PointerTo_ns7__getAllPhysicalIos (391)
#endif

/* _ns7__unlockAllIos * has binding name 'PointerTo_ns7__unlockAllIos' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__unlockAllIos
#define SOAP_TYPE_PointerTo_ns7__unlockAllIos (388)
#endif

/* _ns7__SoapAllPhysicalIoResponse * has binding name 'PointerTo_ns7__SoapAllPhysicalIoResponse' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__SoapAllPhysicalIoResponse
#define SOAP_TYPE_PointerTo_ns7__SoapAllPhysicalIoResponse (385)
#endif

/* _ns7__lockAllIos * has binding name 'PointerTo_ns7__lockAllIos' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__lockAllIos
#define SOAP_TYPE_PointerTo_ns7__lockAllIos (384)
#endif

/* _ns7__unlockIosResponse * has binding name 'PointerTo_ns7__unlockIosResponse' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__unlockIosResponse
#define SOAP_TYPE_PointerTo_ns7__unlockIosResponse (381)
#endif

/* _ns7__unlockIos * has binding name 'PointerTo_ns7__unlockIos' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__unlockIos
#define SOAP_TYPE_PointerTo_ns7__unlockIos (380)
#endif

/* _ns7__lockIosResponse * has binding name 'PointerTo_ns7__lockIosResponse' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__lockIosResponse
#define SOAP_TYPE_PointerTo_ns7__lockIosResponse (377)
#endif

/* _ns7__lockIos * has binding name 'PointerTo_ns7__lockIos' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__lockIos
#define SOAP_TYPE_PointerTo_ns7__lockIos (376)
#endif

/* _ns7__writeIosResponse * has binding name 'PointerTo_ns7__writeIosResponse' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__writeIosResponse
#define SOAP_TYPE_PointerTo_ns7__writeIosResponse (373)
#endif

/* _ns7__writeIos * has binding name 'PointerTo_ns7__writeIos' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__writeIos
#define SOAP_TYPE_PointerTo_ns7__writeIos (372)
#endif

/* _ns7__readIosResponse * has binding name 'PointerTo_ns7__readIosResponse' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__readIosResponse
#define SOAP_TYPE_PointerTo_ns7__readIosResponse (369)
#endif

/* _ns7__readIos * has binding name 'PointerTo_ns7__readIos' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__readIos
#define SOAP_TYPE_PointerTo_ns7__readIos (368)
#endif

/* _ns7__replaceLineResponse * has binding name 'PointerTo_ns7__replaceLineResponse' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__replaceLineResponse
#define SOAP_TYPE_PointerTo_ns7__replaceLineResponse (365)
#endif

/* _ns7__replaceLine * has binding name 'PointerTo_ns7__replaceLine' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__replaceLine
#define SOAP_TYPE_PointerTo_ns7__replaceLine (364)
#endif

/* _ns7__setCurrentInstructionResponse * has binding name 'PointerTo_ns7__setCurrentInstructionResponse' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__setCurrentInstructionResponse
#define SOAP_TYPE_PointerTo_ns7__setCurrentInstructionResponse (361)
#endif

/* _ns7__setCurrentInstruction * has binding name 'PointerTo_ns7__setCurrentInstruction' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__setCurrentInstruction
#define SOAP_TYPE_PointerTo_ns7__setCurrentInstruction (360)
#endif

/* _ns7__setProjectAsModifiedResponse * has binding name 'PointerTo_ns7__setProjectAsModifiedResponse' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__setProjectAsModifiedResponse
#define SOAP_TYPE_PointerTo_ns7__setProjectAsModifiedResponse (357)
#endif

/* _ns7__setProjectAsModified * has binding name 'PointerTo_ns7__setProjectAsModified' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__setProjectAsModified
#define SOAP_TYPE_PointerTo_ns7__setProjectAsModified (356)
#endif

/* _ns7__execVal3Response * has binding name 'PointerTo_ns7__execVal3Response' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__execVal3Response
#define SOAP_TYPE_PointerTo_ns7__execVal3Response (353)
#endif

/* _ns7__execVal3 * has binding name 'PointerTo_ns7__execVal3' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__execVal3
#define SOAP_TYPE_PointerTo_ns7__execVal3 (352)
#endif

/* _ns7__getWatchResponse * has binding name 'PointerTo_ns7__getWatchResponse' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__getWatchResponse
#define SOAP_TYPE_PointerTo_ns7__getWatchResponse (349)
#endif

/* _ns7__getWatches * has binding name 'PointerTo_ns7__getWatches' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__getWatches
#define SOAP_TYPE_PointerTo_ns7__getWatches (348)
#endif

/* _ns7__getStackFrameResponse * has binding name 'PointerTo_ns7__getStackFrameResponse' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__getStackFrameResponse
#define SOAP_TYPE_PointerTo_ns7__getStackFrameResponse (345)
#endif

/* _ns7__getStackFrame * has binding name 'PointerTo_ns7__getStackFrame' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__getStackFrame
#define SOAP_TYPE_PointerTo_ns7__getStackFrame (344)
#endif

/* _ns7__getCallStackResponse * has binding name 'PointerTo_ns7__getCallStackResponse' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__getCallStackResponse
#define SOAP_TYPE_PointerTo_ns7__getCallStackResponse (341)
#endif

/* _ns7__getCallStack * has binding name 'PointerTo_ns7__getCallStack' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__getCallStack
#define SOAP_TYPE_PointerTo_ns7__getCallStack (340)
#endif

/* _ns7__unsubscribeResponse * has binding name 'PointerTo_ns7__unsubscribeResponse' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__unsubscribeResponse
#define SOAP_TYPE_PointerTo_ns7__unsubscribeResponse (337)
#endif

/* _ns7__unsubscribeToControllerEvents * has binding name 'PointerTo_ns7__unsubscribeToControllerEvents' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__unsubscribeToControllerEvents
#define SOAP_TYPE_PointerTo_ns7__unsubscribeToControllerEvents (336)
#endif

/* _ns7__subscribeResponse * has binding name 'PointerTo_ns7__subscribeResponse' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__subscribeResponse
#define SOAP_TYPE_PointerTo_ns7__subscribeResponse (333)
#endif

/* _ns7__subscribeToControllerEvents * has binding name 'PointerTo_ns7__subscribeToControllerEvents' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__subscribeToControllerEvents
#define SOAP_TYPE_PointerTo_ns7__subscribeToControllerEvents (332)
#endif

/* _ns7__taskStepResponse * has binding name 'PointerTo_ns7__taskStepResponse' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__taskStepResponse
#define SOAP_TYPE_PointerTo_ns7__taskStepResponse (329)
#endif

/* _ns7__taskStep * has binding name 'PointerTo_ns7__taskStep' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__taskStep
#define SOAP_TYPE_PointerTo_ns7__taskStep (328)
#endif

/* _ns7__taskKillResponse * has binding name 'PointerTo_ns7__taskKillResponse' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__taskKillResponse
#define SOAP_TYPE_PointerTo_ns7__taskKillResponse (325)
#endif

/* _ns7__taskKill * has binding name 'PointerTo_ns7__taskKill' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__taskKill
#define SOAP_TYPE_PointerTo_ns7__taskKill (324)
#endif

/* _ns7__taskResumeResponse * has binding name 'PointerTo_ns7__taskResumeResponse' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__taskResumeResponse
#define SOAP_TYPE_PointerTo_ns7__taskResumeResponse (321)
#endif

/* _ns7__taskResume * has binding name 'PointerTo_ns7__taskResume' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__taskResume
#define SOAP_TYPE_PointerTo_ns7__taskResume (320)
#endif

/* _ns7__taskSuspendResponse * has binding name 'PointerTo_ns7__taskSuspendResponse' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__taskSuspendResponse
#define SOAP_TYPE_PointerTo_ns7__taskSuspendResponse (317)
#endif

/* _ns7__taskSuspend * has binding name 'PointerTo_ns7__taskSuspend' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__taskSuspend
#define SOAP_TYPE_PointerTo_ns7__taskSuspend (316)
#endif

/* _ns7__getTasksResponse * has binding name 'PointerTo_ns7__getTasksResponse' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__getTasksResponse
#define SOAP_TYPE_PointerTo_ns7__getTasksResponse (313)
#endif

/* _ns7__getTasks * has binding name 'PointerTo_ns7__getTasks' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__getTasks
#define SOAP_TYPE_PointerTo_ns7__getTasks (312)
#endif

/* _ns7__clearAllBreakpointsResponse * has binding name 'PointerTo_ns7__clearAllBreakpointsResponse' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__clearAllBreakpointsResponse
#define SOAP_TYPE_PointerTo_ns7__clearAllBreakpointsResponse (309)
#endif

/* _ns7__clearAllBreakpoints * has binding name 'PointerTo_ns7__clearAllBreakpoints' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__clearAllBreakpoints
#define SOAP_TYPE_PointerTo_ns7__clearAllBreakpoints (308)
#endif

/* _ns7__clearBreakpointsResponse * has binding name 'PointerTo_ns7__clearBreakpointsResponse' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__clearBreakpointsResponse
#define SOAP_TYPE_PointerTo_ns7__clearBreakpointsResponse (305)
#endif

/* _ns7__clearBreakpoints * has binding name 'PointerTo_ns7__clearBreakpoints' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__clearBreakpoints
#define SOAP_TYPE_PointerTo_ns7__clearBreakpoints (304)
#endif

/* _ns7__getBreakpointsResponse * has binding name 'PointerTo_ns7__getBreakpointsResponse' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__getBreakpointsResponse
#define SOAP_TYPE_PointerTo_ns7__getBreakpointsResponse (301)
#endif

/* _ns7__getBreakpoints * has binding name 'PointerTo_ns7__getBreakpoints' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__getBreakpoints
#define SOAP_TYPE_PointerTo_ns7__getBreakpoints (300)
#endif

/* _ns7__setBreakpointsResponse * has binding name 'PointerTo_ns7__setBreakpointsResponse' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__setBreakpointsResponse
#define SOAP_TYPE_PointerTo_ns7__setBreakpointsResponse (297)
#endif

/* _ns7__setBreakpoints * has binding name 'PointerTo_ns7__setBreakpoints' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns7__setBreakpoints
#define SOAP_TYPE_PointerTo_ns7__setBreakpoints (296)
#endif

/* _ns1__setRobotPosResponse * has binding name 'PointerTo_ns1__setRobotPosResponse' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__setRobotPosResponse
#define SOAP_TYPE_PointerTo_ns1__setRobotPosResponse (293)
#endif

/* _ns1__setRobotJointPos * has binding name 'PointerTo_ns1__setRobotJointPos' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__setRobotJointPos
#define SOAP_TYPE_PointerTo_ns1__setRobotJointPos (292)
#endif

/* _ns1__getRobotJntCartPosResponse * has binding name 'PointerTo_ns1__getRobotJntCartPosResponse' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__getRobotJntCartPosResponse
#define SOAP_TYPE_PointerTo_ns1__getRobotJntCartPosResponse (289)
#endif

/* _ns1__getRobotJntCartPos * has binding name 'PointerTo_ns1__getRobotJntCartPos' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__getRobotJntCartPos
#define SOAP_TYPE_PointerTo_ns1__getRobotJntCartPos (288)
#endif

/* _ns1__getRobotJointPosResponse * has binding name 'PointerTo_ns1__getRobotJointPosResponse' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__getRobotJointPosResponse
#define SOAP_TYPE_PointerTo_ns1__getRobotJointPosResponse (285)
#endif

/* _ns1__getRobotJointPos * has binding name 'PointerTo_ns1__getRobotJointPos' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__getRobotJointPos
#define SOAP_TYPE_PointerTo_ns1__getRobotJointPos (284)
#endif

/* _ns1__getRobotsResponse * has binding name 'PointerTo_ns1__getRobotsResponse' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__getRobotsResponse
#define SOAP_TYPE_PointerTo_ns1__getRobotsResponse (281)
#endif

/* _ns1__getRobots * has binding name 'PointerTo_ns1__getRobots' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__getRobots
#define SOAP_TYPE_PointerTo_ns1__getRobots (280)
#endif

/* _ns1__logoutResponse * has binding name 'PointerTo_ns1__logoutResponse' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__logoutResponse
#define SOAP_TYPE_PointerTo_ns1__logoutResponse (277)
#endif

/* _ns1__logout * has binding name 'PointerTo_ns1__logout' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__logout
#define SOAP_TYPE_PointerTo_ns1__logout (276)
#endif

/* _ns1__loginResponse * has binding name 'PointerTo_ns1__loginResponse' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__loginResponse
#define SOAP_TYPE_PointerTo_ns1__loginResponse (273)
#endif

/* _ns1__login * has binding name 'PointerTo_ns1__login' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__login
#define SOAP_TYPE_PointerTo_ns1__login (272)
#endif

/* _ns1__getCS8CompatibilityResponse * has binding name 'PointerTo_ns1__getCS8CompatibilityResponse' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__getCS8CompatibilityResponse
#define SOAP_TYPE_PointerTo_ns1__getCS8CompatibilityResponse (269)
#endif

/* _ns1__getCS8Compatibility * has binding name 'PointerTo_ns1__getCS8Compatibility' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__getCS8Compatibility
#define SOAP_TYPE_PointerTo_ns1__getCS8Compatibility (268)
#endif

/* _ns1__getControllerParametersResponse * has binding name 'PointerTo_ns1__getControllerParametersResponse' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__getControllerParametersResponse
#define SOAP_TYPE_PointerTo_ns1__getControllerParametersResponse (265)
#endif

/* _ns1__getControllerParameters * has binding name 'PointerTo_ns1__getControllerParameters' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__getControllerParameters
#define SOAP_TYPE_PointerTo_ns1__getControllerParameters (264)
#endif

/* _ns1__getCS8VersionsResponse * has binding name 'PointerTo_ns1__getCS8VersionsResponse' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__getCS8VersionsResponse
#define SOAP_TYPE_PointerTo_ns1__getCS8VersionsResponse (261)
#endif

/* _ns1__getCS8Versions * has binding name 'PointerTo_ns1__getCS8Versions' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__getCS8Versions
#define SOAP_TYPE_PointerTo_ns1__getCS8Versions (260)
#endif

/* _ns1__pingResponse * has binding name 'PointerTo_ns1__pingResponse' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__pingResponse
#define SOAP_TYPE_PointerTo_ns1__pingResponse (257)
#endif

/* _ns1__ping * has binding name 'PointerTo_ns1__ping' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__ping
#define SOAP_TYPE_PointerTo_ns1__ping (256)
#endif

/* _ns1__findServerResponse * has binding name 'PointerTo_ns1__findServerResponse' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__findServerResponse
#define SOAP_TYPE_PointerTo_ns1__findServerResponse (253)
#endif

/* _ns1__findServer * has binding name 'PointerTo_ns1__findServer' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__findServer
#define SOAP_TYPE_PointerTo_ns1__findServer (252)
#endif

/* _ns1__getSoapServerVersionResponse * has binding name 'PointerTo_ns1__getSoapServerVersionResponse' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__getSoapServerVersionResponse
#define SOAP_TYPE_PointerTo_ns1__getSoapServerVersionResponse (249)
#endif

/* _ns1__getSoapServerVersion * has binding name 'PointerTo_ns1__getSoapServerVersion' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__getSoapServerVersion
#define SOAP_TYPE_PointerTo_ns1__getSoapServerVersion (248)
#endif

/* ns1__ServerException * has binding name 'PointerTons1__ServerException' for type 'ns1:ServerException' */
#ifndef SOAP_TYPE_PointerTons1__ServerException
#define SOAP_TYPE_PointerTons1__ServerException (245)
#endif

/* int * has binding name 'PointerTons1__SessionId' for type 'ns1:SessionId' */
#ifndef SOAP_TYPE_PointerTons1__SessionId
#define SOAP_TYPE_PointerTons1__SessionId (243)
#endif

/* ns2__JointRange * has binding name 'PointerTons2__JointRange' for type 'ns2:JointRange' */
#ifndef SOAP_TYPE_PointerTons2__JointRange
#define SOAP_TYPE_PointerTons2__JointRange (241)
#endif

/* ns2__Records * has binding name 'PointerTons2__Records' for type 'ns2:Records' */
#ifndef SOAP_TYPE_PointerTons2__Records
#define SOAP_TYPE_PointerTons2__Records (240)
#endif

/* ns2__Data * has binding name 'PointerTons2__Data' for type 'ns2:Data' */
#ifndef SOAP_TYPE_PointerTons2__Data
#define SOAP_TYPE_PointerTons2__Data (239)
#endif

/* ns2__VALApplications * has binding name 'PointerTons2__VALApplications' for type 'ns2:VALApplications' */
#ifndef SOAP_TYPE_PointerTons2__VALApplications
#define SOAP_TYPE_PointerTons2__VALApplications (238)
#endif

/* ns3__Include * has binding name 'PointerTons3__Include' for type 'ns3:Include' */
#ifndef SOAP_TYPE_PointerTons3__Include
#define SOAP_TYPE_PointerTons3__Include (237)
#endif

/* ns7__SoapDhParametersArray * has binding name 'PointerTons7__SoapDhParametersArray' for type 'ns7:SoapDhParametersArray' */
#ifndef SOAP_TYPE_PointerTons7__SoapDhParametersArray
#define SOAP_TYPE_PointerTons7__SoapDhParametersArray (235)
#endif

/* ns7__SoapPhysicalIoUnlockResponses * has binding name 'PointerTons7__SoapPhysicalIoUnlockResponses' for type 'ns7:SoapPhysicalIoUnlockResponses' */
#ifndef SOAP_TYPE_PointerTons7__SoapPhysicalIoUnlockResponses
#define SOAP_TYPE_PointerTons7__SoapPhysicalIoUnlockResponses (234)
#endif

/* ns7__SoapPhysicalIoResponses * has binding name 'PointerTons7__SoapPhysicalIoResponses' for type 'ns7:SoapPhysicalIoResponses' */
#ifndef SOAP_TYPE_PointerTons7__SoapPhysicalIoResponses
#define SOAP_TYPE_PointerTons7__SoapPhysicalIoResponses (233)
#endif

/* ns7__SoapPhysicalIoValues * has binding name 'PointerTons7__SoapPhysicalIoValues' for type 'ns7:SoapPhysicalIoValues' */
#ifndef SOAP_TYPE_PointerTons7__SoapPhysicalIoValues
#define SOAP_TYPE_PointerTons7__SoapPhysicalIoValues (232)
#endif

/* ns7__SoapPhysicalIosStates * has binding name 'PointerTons7__SoapPhysicalIosStates' for type 'ns7:SoapPhysicalIosStates' */
#ifndef SOAP_TYPE_PointerTons7__SoapPhysicalIosStates
#define SOAP_TYPE_PointerTons7__SoapPhysicalIosStates (231)
#endif

/* ns7__SoapPhysicalIoLinks * has binding name 'PointerTons7__SoapPhysicalIoLinks' for type 'ns7:SoapPhysicalIoLinks' */
#ifndef SOAP_TYPE_PointerTons7__SoapPhysicalIoLinks
#define SOAP_TYPE_PointerTons7__SoapPhysicalIoLinks (230)
#endif

/* ns7__SoapWatches * has binding name 'PointerTons7__SoapWatches' for type 'ns7:SoapWatches' */
#ifndef SOAP_TYPE_PointerTons7__SoapWatches
#define SOAP_TYPE_PointerTons7__SoapWatches (229)
#endif

/* ns7__MimeData * has binding name 'PointerTons7__MimeData' for type 'ns7:MimeData' */
#ifndef SOAP_TYPE_PointerTons7__MimeData
#define SOAP_TYPE_PointerTons7__MimeData (228)
#endif

/* ns7__SoapCallStack * has binding name 'PointerTons7__SoapCallStack' for type 'ns7:SoapCallStack' */
#ifndef SOAP_TYPE_PointerTons7__SoapCallStack
#define SOAP_TYPE_PointerTons7__SoapCallStack (227)
#endif

/* ns7__SoapTasks * has binding name 'PointerTons7__SoapTasks' for type 'ns7:SoapTasks' */
#ifndef SOAP_TYPE_PointerTons7__SoapTasks
#define SOAP_TYPE_PointerTons7__SoapTasks (226)
#endif

/* ns7__BreakpointsResponses * has binding name 'PointerTons7__BreakpointsResponses' for type 'ns7:BreakpointsResponses' */
#ifndef SOAP_TYPE_PointerTons7__BreakpointsResponses
#define SOAP_TYPE_PointerTons7__BreakpointsResponses (225)
#endif

/* ns7__SoapBreakpoints * has binding name 'PointerTons7__SoapBreakpoints' for type 'ns7:SoapBreakpoints' */
#ifndef SOAP_TYPE_PointerTons7__SoapBreakpoints
#define SOAP_TYPE_PointerTons7__SoapBreakpoints (224)
#endif

/* ns7__SoapPhysicalIoAttrib * has binding name 'PointerTons7__SoapPhysicalIoAttrib' for type 'ns7:SoapPhysicalIoAttrib' */
#ifndef SOAP_TYPE_PointerTons7__SoapPhysicalIoAttrib
#define SOAP_TYPE_PointerTons7__SoapPhysicalIoAttrib (223)
#endif

/* ns7__SoapPhysicalAioAttrib * has binding name 'PointerTons7__SoapPhysicalAioAttrib' for type 'ns7:SoapPhysicalAioAttrib' */
#ifndef SOAP_TYPE_PointerTons7__SoapPhysicalAioAttrib
#define SOAP_TYPE_PointerTons7__SoapPhysicalAioAttrib (221)
#endif

/* ns7__SoapPhysicalDioAttrib * has binding name 'PointerTons7__SoapPhysicalDioAttrib' for type 'ns7:SoapPhysicalDioAttrib' */
#ifndef SOAP_TYPE_PointerTons7__SoapPhysicalDioAttrib
#define SOAP_TYPE_PointerTons7__SoapPhysicalDioAttrib (220)
#endif

/* ns7__SoapInstruction * has binding name 'PointerTons7__SoapInstruction' for type 'ns7:SoapInstruction' */
#ifndef SOAP_TYPE_PointerTons7__SoapInstruction
#define SOAP_TYPE_PointerTons7__SoapInstruction (219)
#endif

/* ns7__SoapProgramLine * has binding name 'PointerTons7__SoapProgramLine' for type 'ns7:SoapProgramLine' */
#ifndef SOAP_TYPE_PointerTons7__SoapProgramLine
#define SOAP_TYPE_PointerTons7__SoapProgramLine (218)
#endif

/* ns7__SoapDhParameters * has binding name 'PointerTons7__SoapDhParameters' for type 'ns7:SoapDhParameters' */
#ifndef SOAP_TYPE_PointerTons7__SoapDhParameters
#define SOAP_TYPE_PointerTons7__SoapDhParameters (216)
#endif

/* ns7__SoapPhysicalIoUnlockResponse * has binding name 'PointerTons7__SoapPhysicalIoUnlockResponse' for type 'ns7:SoapPhysicalIoUnlockResponse' */
#ifndef SOAP_TYPE_PointerTons7__SoapPhysicalIoUnlockResponse
#define SOAP_TYPE_PointerTons7__SoapPhysicalIoUnlockResponse (214)
#endif

/* ns7__SoapPhysicalIoResponse * has binding name 'PointerTons7__SoapPhysicalIoResponse' for type 'ns7:SoapPhysicalIoResponse' */
#ifndef SOAP_TYPE_PointerTons7__SoapPhysicalIoResponse
#define SOAP_TYPE_PointerTons7__SoapPhysicalIoResponse (212)
#endif

/* ns7__SoapPhysicalIoState * has binding name 'PointerTons7__SoapPhysicalIoState' for type 'ns7:SoapPhysicalIoState' */
#ifndef SOAP_TYPE_PointerTons7__SoapPhysicalIoState
#define SOAP_TYPE_PointerTons7__SoapPhysicalIoState (210)
#endif

/* ns7__SoapData * has binding name 'PointerTons7__SoapData' for type 'ns7:SoapData' */
#ifndef SOAP_TYPE_PointerTons7__SoapData
#define SOAP_TYPE_PointerTons7__SoapData (208)
#endif

/* ns7__SoapStackFrameAbstract * has binding name 'PointerTons7__SoapStackFrameAbstract' for type 'ns7:SoapStackFrameAbstract' */
#ifndef SOAP_TYPE_PointerTons7__SoapStackFrameAbstract
#define SOAP_TYPE_PointerTons7__SoapStackFrameAbstract (206)
#endif

/* ns7__SoapTask * has binding name 'PointerTons7__SoapTask' for type 'ns7:SoapTask' */
#ifndef SOAP_TYPE_PointerTons7__SoapTask
#define SOAP_TYPE_PointerTons7__SoapTask (204)
#endif

/* ns7__BreakpointsResponse * has binding name 'PointerTons7__BreakpointsResponse' for type 'ns7:BreakpointsResponse' */
#ifndef SOAP_TYPE_PointerTons7__BreakpointsResponse
#define SOAP_TYPE_PointerTons7__BreakpointsResponse (202)
#endif

/* ns7__SoapBreakpoint * has binding name 'PointerTons7__SoapBreakpoint' for type 'ns7:SoapBreakpoint' */
#ifndef SOAP_TYPE_PointerTons7__SoapBreakpoint
#define SOAP_TYPE_PointerTons7__SoapBreakpoint (200)
#endif

/* ns2__VALApplication * has binding name 'PointerTons2__VALApplication' for type 'ns2:VALApplication' */
#ifndef SOAP_TYPE_PointerTons2__VALApplication
#define SOAP_TYPE_PointerTons2__VALApplication (197)
#endif

/* ns1__CartesianPos * has binding name 'PointerTons1__CartesianPos' for type 'ns1:CartesianPos' */
#ifndef SOAP_TYPE_PointerTons1__CartesianPos
#define SOAP_TYPE_PointerTons1__CartesianPos (196)
#endif

/* ns1__JointPos * has binding name 'PointerTons1__JointPos' for type 'ns1:JointPos' */
#ifndef SOAP_TYPE_PointerTons1__JointPos
#define SOAP_TYPE_PointerTons1__JointPos (195)
#endif

/* ns1__Robots * has binding name 'PointerTons1__Robots' for type 'ns1:Robots' */
#ifndef SOAP_TYPE_PointerTons1__Robots
#define SOAP_TYPE_PointerTons1__Robots (194)
#endif

/* ns1__Parameters * has binding name 'PointerTons1__Parameters' for type 'ns1:Parameters' */
#ifndef SOAP_TYPE_PointerTons1__Parameters
#define SOAP_TYPE_PointerTons1__Parameters (193)
#endif

/* ns1__Versions * has binding name 'PointerTons1__Versions' for type 'ns1:Versions' */
#ifndef SOAP_TYPE_PointerTons1__Versions
#define SOAP_TYPE_PointerTons1__Versions (192)
#endif

/* ns1__SoapServerVersion * has binding name 'PointerTons1__SoapServerVersion' for type 'ns1:SoapServerVersion' */
#ifndef SOAP_TYPE_PointerTons1__SoapServerVersion
#define SOAP_TYPE_PointerTons1__SoapServerVersion (190)
#endif

/* ns1__Robot * has binding name 'PointerTons1__Robot' for type 'ns1:Robot' */
#ifndef SOAP_TYPE_PointerTons1__Robot
#define SOAP_TYPE_PointerTons1__Robot (188)
#endif

/* ns1__Version * has binding name 'PointerTons1__Version' for type 'ns1:Version' */
#ifndef SOAP_TYPE_PointerTons1__Version
#define SOAP_TYPE_PointerTons1__Version (186)
#endif

/* ns1__Parameter * has binding name 'PointerTons1__Parameter' for type 'ns1:Parameter' */
#ifndef SOAP_TYPE_PointerTons1__Parameter
#define SOAP_TYPE_PointerTons1__Parameter (184)
#endif

/* std::string * has binding name 'PointerTostd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_PointerTostd__string
#define SOAP_TYPE_PointerTostd__string (181)
#endif

/* unsigned char * has binding name 'PointerTounsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_PointerTounsignedByte
#define SOAP_TYPE_PointerTounsignedByte (13)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/* std::vector<char *>  has binding name 'std__vectorTemplateOf_XML' for type '' */
#ifndef SOAP_TYPE_std__vectorTemplateOf_XML
#define SOAP_TYPE_std__vectorTemplateOf_XML (236)
#endif

/* std::vector<ns7__SoapDhParameters *>  has binding name 'std__vectorTemplateOfPointerTons7__SoapDhParameters' for type 'ns7:SoapDhParameters' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapDhParameters
#define SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapDhParameters (217)
#endif

/* std::vector<ns7__SoapPhysicalIoUnlockResponse *>  has binding name 'std__vectorTemplateOfPointerTons7__SoapPhysicalIoUnlockResponse' for type 'ns7:SoapPhysicalIoUnlockResponse' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapPhysicalIoUnlockResponse
#define SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapPhysicalIoUnlockResponse (215)
#endif

/* std::vector<ns7__SoapPhysicalIoResponse *>  has binding name 'std__vectorTemplateOfPointerTons7__SoapPhysicalIoResponse' for type 'ns7:SoapPhysicalIoResponse' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapPhysicalIoResponse
#define SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapPhysicalIoResponse (213)
#endif

/* std::vector<ns7__SoapPhysicalIoState *>  has binding name 'std__vectorTemplateOfPointerTons7__SoapPhysicalIoState' for type 'ns7:SoapPhysicalIoState' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapPhysicalIoState
#define SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapPhysicalIoState (211)
#endif

/* std::vector<ns7__SoapData *>  has binding name 'std__vectorTemplateOfPointerTons7__SoapData' for type 'ns7:SoapData' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapData
#define SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapData (209)
#endif

/* std::vector<ns7__SoapStackFrameAbstract *>  has binding name 'std__vectorTemplateOfPointerTons7__SoapStackFrameAbstract' for type 'ns7:SoapStackFrameAbstract' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapStackFrameAbstract
#define SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapStackFrameAbstract (207)
#endif

/* std::vector<ns7__SoapTask *>  has binding name 'std__vectorTemplateOfPointerTons7__SoapTask' for type 'ns7:SoapTask' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapTask
#define SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapTask (205)
#endif

/* std::vector<ns7__BreakpointsResponse *>  has binding name 'std__vectorTemplateOfPointerTons7__BreakpointsResponse' for type 'ns7:BreakpointsResponse' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons7__BreakpointsResponse
#define SOAP_TYPE_std__vectorTemplateOfPointerTons7__BreakpointsResponse (203)
#endif

/* std::vector<ns7__SoapBreakpoint *>  has binding name 'std__vectorTemplateOfPointerTons7__SoapBreakpoint' for type 'ns7:SoapBreakpoint' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapBreakpoint
#define SOAP_TYPE_std__vectorTemplateOfPointerTons7__SoapBreakpoint (201)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfstd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__vectorTemplateOfstd__string
#define SOAP_TYPE_std__vectorTemplateOfstd__string (199)
#endif

/* std::vector<ns2__VALApplication *>  has binding name 'std__vectorTemplateOfPointerTons2__VALApplication' for type 'ns2:VALApplication' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__VALApplication
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__VALApplication (198)
#endif

/* std::vector<ns1__Robot *>  has binding name 'std__vectorTemplateOfPointerTons1__Robot' for type 'ns1:Robot' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__Robot
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__Robot (189)
#endif

/* std::vector<ns1__Version *>  has binding name 'std__vectorTemplateOfPointerTons1__Version' for type 'ns1:Version' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__Version
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__Version (187)
#endif

/* std::vector<ns1__Parameter *>  has binding name 'std__vectorTemplateOfPointerTons1__Parameter' for type 'ns1:Parameter' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__Parameter
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__Parameter (185)
#endif

/* std::vector<double>  has binding name 'std__vectorTemplateOfdouble' for type 'xsd:double' */
#ifndef SOAP_TYPE_std__vectorTemplateOfdouble
#define SOAP_TYPE_std__vectorTemplateOfdouble (183)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
